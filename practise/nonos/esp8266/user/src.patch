Binary files src/.DS_Store and src_ok/.DS_Store differ
diff -uNr src/agenttime_esp8266.c src_ok/agenttime_esp8266.c
--- src/agenttime_esp8266.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/agenttime_esp8266.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,10 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include "azure_c_shared_utility/agenttime.h"
-#include "azure_c_shared_utility/xlogging.h"
-#include "lwip/apps/sntp.h"
-#include "lwip/apps/sntp_time.h"
+#include "agenttime.h"
+#include "xlogging.h"
+#include "sntp.h"
 
 time_t get_time(time_t* currentTime)
 {
diff -uNr src/buffer.c src_ok/buffer.c
--- src/buffer.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/buffer.c	2018-09-03 16:45:36.000000000 +0800
@@ -5,10 +5,10 @@
 #include <stddef.h>
 #include <string.h>
 #include <stdbool.h>
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/buffer_.h"
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/xlogging.h"
+#include "esp_types.h"
+#include "buffer_.h"
+//#include "azure_c_shared_utility/optimize_size.h"
+//#include "azure_c_shared_utility/xlogging.h"
 
 typedef struct BUFFER_TAG
 {
@@ -17,7 +17,7 @@
 } BUFFER;
 
 /* Codes_SRS_BUFFER_07_001: [BUFFER_new shall allocate a BUFFER_HANDLE that will contain a NULL unsigned char*.] */
-BUFFER_HANDLE BUFFER_new(void)
+BUFFER_HANDLE  ICACHE_FLASH_ATTR BUFFER_new(void)
 {
     BUFFER* temp = (BUFFER*)malloc(sizeof(BUFFER));
     /* Codes_SRS_BUFFER_07_002: [BUFFER_new shall return NULL on any error that occurs.] */
@@ -29,7 +29,7 @@
     return (BUFFER_HANDLE)temp;
 }
 
-static int BUFFER_safemalloc(BUFFER* handleptr, size_t size)
+static int  ICACHE_FLASH_ATTR BUFFER_safemalloc(BUFFER* handleptr, size_t size)
 {
     int result;
     size_t sizetomalloc = size;
@@ -41,7 +41,7 @@
     if (handleptr->buffer == NULL)
     {
         /*Codes_SRS_BUFFER_02_003: [If allocating memory fails, then BUFFER_create shall return NULL.]*/
-        LogError("Failure allocating data");
+        printf("Failure allocating data");
         result = __FAILURE__;
     }
     else
@@ -53,13 +53,13 @@
     return result;
 }
 
-BUFFER_HANDLE BUFFER_create(const unsigned char* source, size_t size)
+BUFFER_HANDLE  ICACHE_FLASH_ATTR BUFFER_create(const unsigned char* source, size_t size)
 {
     BUFFER* result;
     /*Codes_SRS_BUFFER_02_001: [If source is NULL then BUFFER_create shall return NULL.]*/
     if (source == NULL)
     {
-        LogError("invalid parameter source: %p", source);
+        printf("invalid parameter source: %p", source);
         result = NULL;
     }
     else
@@ -70,14 +70,14 @@
         {
             /*Codes_SRS_BUFFER_02_003: [If allocating memory fails, then BUFFER_create shall return NULL.] */
             /*fallthrough*/
-            LogError("Failure allocating BUFFER structure");
+            printf("Failure allocating BUFFER structure");
         }
         else
         {
             /* Codes_SRS_BUFFER_02_005: [If size parameter is 0 then 1 byte of memory shall be allocated yet size of the buffer shall be set to 0.]*/
             if (BUFFER_safemalloc(result, size) != 0)
             {
-                LogError("unable to BUFFER_safemalloc ");
+                printf("unable to BUFFER_safemalloc ");
                 free(result);
                 result = NULL;
             }
@@ -92,7 +92,7 @@
 }
 
 /* Codes_SRS_BUFFER_07_003: [BUFFER_delete shall delete the data associated with the BUFFER_HANDLE along with the Buffer.] */
-void BUFFER_delete(BUFFER_HANDLE handle)
+void  ICACHE_FLASH_ATTR BUFFER_delete(BUFFER_HANDLE handle)
 {
     /* Codes_SRS_BUFFER_07_004: [BUFFER_delete shall not delete any BUFFER_HANDLE that is NULL.] */
     if (handle != NULL)
@@ -110,7 +110,7 @@
 /*return 0 if the buffer was copied*/
 /*else return different than zero*/
 /* Codes_SRS_BUFFER_07_008: [BUFFER_build allocates size_t bytes, copies the unsigned char* into the buffer and returns zero on success.] */
-int BUFFER_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)
+int ICACHE_FLASH_ATTR  BUFFER_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)
 {
     int result;
     if (handle == NULL)
@@ -144,7 +144,7 @@
             if (newBuffer == NULL)
             {
                 /* Codes_SRS_BUFFER_07_010: [BUFFER_build shall return nonzero if any error is encountered.] */
-                LogError("Failure reallocating buffer");
+                printf("Failure reallocating buffer");
                 result = __FAILURE__;
             }
             else
@@ -162,13 +162,13 @@
     return result;
 }
 
-int BUFFER_append_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)
+int  ICACHE_FLASH_ATTR BUFFER_append_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)
 {
     int result;
     if (handle == NULL || source == NULL || size == 0)
     {
         /* Codes_SRS_BUFFER_07_029: [ BUFFER_append_build shall return nonzero if handle or source are NULL or if size is 0. ] */
-        LogError("BUFFER_append_build failed invalid parameter handle: %p, source: %p, size: %uz", handle, source, size);
+        printf("BUFFER_append_build failed invalid parameter handle: %p, source: %p, size: %uz", handle, source, size);
         result = __FAILURE__;
     }
     else
@@ -179,7 +179,7 @@
             if (BUFFER_safemalloc(handle, size) != 0)
             {
                 /* Codes_SRS_BUFFER_07_035: [ If any error is encountered BUFFER_append_build shall return a non-null value. ] */
-                LogError("Failure with BUFFER_safemalloc");
+                printf("Failure with BUFFER_safemalloc");
                 result = __FAILURE__;
             }
             else
@@ -197,7 +197,7 @@
             if (temp == NULL)
             {
                 /* Codes_SRS_BUFFER_07_035: [ If any error is encountered BUFFER_append_build shall return a non-null value. ] */
-                LogError("Failure reallocating temporary buffer");
+                printf("Failure reallocating temporary buffer");
                 result = __FAILURE__;
             }
             else
@@ -218,7 +218,7 @@
 /*return 0 if the buffer was pre-build(that is, had its space allocated)*/
 /*else return different than zero*/
 /* Codes_SRS_BUFFER_07_005: [BUFFER_pre_build allocates size_t bytes of BUFFER_HANDLE and returns zero on success.] */
-int BUFFER_pre_build(BUFFER_HANDLE handle, size_t size)
+int  ICACHE_FLASH_ATTR BUFFER_pre_build(BUFFER_HANDLE handle, size_t size)
 {
     int result;
     if (handle == NULL)
@@ -237,7 +237,7 @@
         if (b->buffer != NULL)
         {
             /* Codes_SRS_BUFFER_07_007: [BUFFER_pre_build shall return nonzero if the buffer has been previously allocated and is not NULL.] */
-            LogError("Failure buffer data is NULL");
+            printf("Failure buffer data is NULL");
             result = __FAILURE__;
         }
         else
@@ -245,7 +245,7 @@
             if ((b->buffer = (unsigned char*)malloc(size)) == NULL)
             {
                 /* Codes_SRS_BUFFER_07_013: [BUFFER_pre_build shall return nonzero if any error is encountered.] */
-                LogError("Failure allocating buffer");
+                printf("Failure allocating buffer");
                 result = __FAILURE__;
             }
             else
@@ -259,7 +259,7 @@
 }
 
 /* Codes_SRS_BUFFER_07_019: [BUFFER_content shall return the data contained within the BUFFER_HANDLE.] */
-int BUFFER_content(BUFFER_HANDLE handle, const unsigned char** content)
+int  ICACHE_FLASH_ATTR BUFFER_content(BUFFER_HANDLE handle, const unsigned char** content)
 {
     int result;
     if ((handle == NULL) || (content == NULL))
@@ -278,7 +278,7 @@
 
 /*return 0 if everything went ok and whatever was built in the buffer was unbuilt*/
 /* Codes_SRS_BUFFER_07_012: [BUFFER_unbuild shall clear the underlying unsigned char* data associated with the BUFFER_HANDLE this will return zero on success.] */
-extern int BUFFER_unbuild(BUFFER_HANDLE handle)
+extern int ICACHE_FLASH_ATTR  BUFFER_unbuild(BUFFER_HANDLE handle)
 {
     int result;
     if (handle == NULL)
@@ -291,7 +291,7 @@
         BUFFER* b = (BUFFER*)handle;
         if (b->buffer != NULL)
         {
-            LogError("Failure buffer data is NULL");
+            printf("Failure buffer data is NULL");
             free(b->buffer);
             b->buffer = NULL;
             b->size = 0;
@@ -307,19 +307,19 @@
 }
 
 /* Codes_SRS_BUFFER_07_016: [BUFFER_enlarge shall increase the size of the unsigned char* referenced by BUFFER_HANDLE.] */
-int BUFFER_enlarge(BUFFER_HANDLE handle, size_t enlargeSize)
+int  ICACHE_FLASH_ATTR BUFFER_enlarge(BUFFER_HANDLE handle, size_t enlargeSize)
 {
     int result;
     if (handle == NULL)
     {
         /* Codes_SRS_BUFFER_07_017: [BUFFER_enlarge shall return a nonzero result if any parameters are NULL or zero.] */
-        LogError("Failure: handle is invalid.");
+        printf("Failure: handle is invalid.");
         result = __FAILURE__;
     }
     else if (enlargeSize == 0)
     {
         /* Codes_SRS_BUFFER_07_017: [BUFFER_enlarge shall return a nonzero result if any parameters are NULL or zero.] */
-        LogError("Failure: enlargeSize size is 0.");
+        printf("Failure: enlargeSize size is 0.");
         result = __FAILURE__;
     }
     else
@@ -329,7 +329,7 @@
         if (temp == NULL)
         {
             /* Codes_SRS_BUFFER_07_018: [BUFFER_enlarge shall return a nonzero result if any error is encountered.] */
-            LogError("Failure: allocating temp buffer.");
+            printf("Failure: allocating temp buffer.");
             result = __FAILURE__;
         }
         else
@@ -342,25 +342,25 @@
     return result;
 }
 
-int BUFFER_shrink(BUFFER_HANDLE handle, size_t decreaseSize, bool fromEnd)
+int ICACHE_FLASH_ATTR  BUFFER_shrink(BUFFER_HANDLE handle, size_t decreaseSize, bool fromEnd)
 {
     int result;
     if (handle == NULL)
     {
         /* Codes_SRS_BUFFER_07_036: [ if handle is NULL, BUFFER_shrink shall return a non-null value ]*/
-        LogError("Failure: handle is invalid.");
+        printf("Failure: handle is invalid.");
         result = __FAILURE__;
     }
     else if (decreaseSize == 0)
     {
         /* Codes_SRS_BUFFER_07_037: [ If decreaseSize is equal zero, BUFFER_shrink shall return a non-null value ] */
-        LogError("Failure: decrease size is 0.");
+        printf("Failure: decrease size is 0.");
         result = __FAILURE__;
     }
     else if (decreaseSize > handle->size)
     {
         /* Codes_SRS_BUFFER_07_038: [ If decreaseSize is less than the size of the buffer, BUFFER_shrink shall return a non-null value ] */
-        LogError("Failure: decrease size is less than buffer size.");
+        printf("Failure: decrease size is less than buffer size.");
         result = __FAILURE__;
     }
     else
@@ -381,7 +381,7 @@
             if (tmp == NULL)
             {
                 /* Codes_SRS_BUFFER_07_042: [ If a failure is encountered, BUFFER_shrink shall return a non-null value ] */
-                LogError("Failure: allocating temp buffer.");
+                printf("Failure: allocating temp buffer.");
                 result = __FAILURE__;
             }
             else
@@ -411,7 +411,7 @@
 }
 
 /* Codes_SRS_BUFFER_07_021: [BUFFER_size shall place the size of the associated buffer in the size variable and return zero on success.] */
-int BUFFER_size(BUFFER_HANDLE handle, size_t* size)
+int  ICACHE_FLASH_ATTR BUFFER_size(BUFFER_HANDLE handle, size_t* size)
 {
     int result;
     if ((handle == NULL) || (size == NULL))
@@ -429,7 +429,7 @@
 }
 
 /* Codes_SRS_BUFFER_07_024: [BUFFER_append concatenates b2 onto b1 without modifying b2 and shall return zero on success.] */
-int BUFFER_append(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)
+int ICACHE_FLASH_ATTR  BUFFER_append(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)
 {
     int result;
     if ( (handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2) )
@@ -465,7 +465,7 @@
                 if (temp == NULL)
                 {
                     /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */
-                    LogError("Failure: allocating temp buffer.");
+                    printf("Failure: allocating temp buffer.");
                     result = __FAILURE__;
                 }
                 else
@@ -483,7 +483,7 @@
     return result;
 }
 
-int BUFFER_prepend(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)
+int ICACHE_FLASH_ATTR  BUFFER_prepend(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)
 {
     int result;
     if ((handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2))
@@ -520,7 +520,7 @@
                 if (temp == NULL)
                 {
                     /* Codes_SRS_BUFFER_01_005: [ BUFFER_prepend shall return a non-zero upon value any error that is encountered. ]*/
-                    LogError("Failure: allocating temp buffer.");
+                    printf("Failure: allocating temp buffer.");
                     result = __FAILURE__;
                 }
                 else
@@ -541,13 +541,13 @@
     return result;
 }
 
-int BUFFER_fill(BUFFER_HANDLE handle, unsigned char fill_char)
+int  ICACHE_FLASH_ATTR BUFFER_fill(BUFFER_HANDLE handle, unsigned char fill_char)
 {
     int result;
     if (handle == NULL)
     {
         /* Codes_SRS_BUFFER_07_002: [ If handle is NULL BUFFER_fill shall return a non-zero value. ] */
-        LogError("Invalid parameter specified, handle == NULL.");
+        printf("Invalid parameter specified, handle == NULL.");
         result = __FAILURE__;
     }
     else
@@ -566,7 +566,7 @@
 
 
 /* Codes_SRS_BUFFER_07_025: [BUFFER_u_char shall return a pointer to the underlying unsigned char*.] */
-unsigned char* BUFFER_u_char(BUFFER_HANDLE handle)
+unsigned char* ICACHE_FLASH_ATTR  BUFFER_u_char(BUFFER_HANDLE handle)
 {
     BUFFER* handleData = (BUFFER*)handle;
     unsigned char* result;
@@ -584,7 +584,7 @@
 }
 
 /* Codes_SRS_BUFFER_07_027: [BUFFER_length shall return the size of the underlying buffer.] */
-size_t BUFFER_length(BUFFER_HANDLE handle)
+size_t ICACHE_FLASH_ATTR  BUFFER_length(BUFFER_HANDLE handle)
 {
     size_t result;
     if (handle == NULL)
@@ -600,7 +600,7 @@
     return result;
 }
 
-BUFFER_HANDLE BUFFER_clone(BUFFER_HANDLE handle)
+BUFFER_HANDLE  ICACHE_FLASH_ATTR BUFFER_clone(BUFFER_HANDLE handle)
 {
     BUFFER_HANDLE result;
     if (handle == NULL)
@@ -615,7 +615,7 @@
         {
             if (BUFFER_safemalloc(b, suppliedBuff->size) != 0)
             {
-                LogError("Failure: allocating temp buffer.");
+                printf("Failure: allocating temp buffer.");
                 result = NULL;
             }
             else
diff -uNr src/certs.c src_ok/certs.c
--- src/certs.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/certs.c	2018-09-03 16:45:36.000000000 +0800
@@ -20,45 +20,130 @@
 /* This file contains cert trust chain needed to communicate with Baidu (IoT Hub) */
 
 #include "certs.h"
-
+#if 1
 const char certificates[] =
         // Comodo RSA Domain Validation Secure Server CA
         "-----BEGIN CERTIFICATE-----\n"
-        "MIIGCDCCA/CgAwIBAgIQKy5u6tl1NmwUim7bo3yMBzANBgkqhkiG9w0BAQwFADCB\n"
-        "hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G\n"
-        "A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV\n"
-        "BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTQwMjEy\n"
-        "MDAwMDAwWhcNMjkwMjExMjM1OTU5WjCBkDELMAkGA1UEBhMCR0IxGzAZBgNVBAgT\n"
-        "EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR\n"
-        "Q09NT0RPIENBIExpbWl0ZWQxNjA0BgNVBAMTLUNPTU9ETyBSU0EgRG9tYWluIFZh\n"
-        "bGlkYXRpb24gU2VjdXJlIFNlcnZlciBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n"
-        "ADCCAQoCggEBAI7CAhnhoFmk6zg1jSz9AdDTScBkxwtiBUUWOqigwAwCfx3M28Sh\n"
-        "bXcDow+G+eMGnD4LgYqbSRutA776S9uMIO3Vzl5ljj4Nr0zCsLdFXlIvNN5IJGS0\n"
-        "Qa4Al/e+Z96e0HqnU4A7fK31llVvl0cKfIWLIpeNs4TgllfQcBhglo/uLQeTnaG6\n"
-        "ytHNe+nEKpooIZFNb5JPJaXyejXdJtxGpdCsWTWM/06RQ1A/WZMebFEh7lgUq/51\n"
-        "UHg+TLAchhP6a5i84DuUHoVS3AOTJBhuyydRReZw3iVDpA3hSqXttn7IzW3uLh0n\n"
-        "c13cRTCAquOyQQuvvUSH2rnlG51/ruWFgqUCAwEAAaOCAWUwggFhMB8GA1UdIwQY\n"
-        "MBaAFLuvfgI9+qbxPISOre44mOzZMjLUMB0GA1UdDgQWBBSQr2o6lFoL2JDqElZz\n"
-        "30O0Oija5zAOBgNVHQ8BAf8EBAMCAYYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNV\n"
-        "HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwGwYDVR0gBBQwEjAGBgRVHSAAMAgG\n"
-        "BmeBDAECATBMBgNVHR8ERTBDMEGgP6A9hjtodHRwOi8vY3JsLmNvbW9kb2NhLmNv\n"
-        "bS9DT01PRE9SU0FDZXJ0aWZpY2F0aW9uQXV0aG9yaXR5LmNybDBxBggrBgEFBQcB\n"
-        "AQRlMGMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9jcnQuY29tb2RvY2EuY29tL0NPTU9E\n"
-        "T1JTQUFkZFRydXN0Q0EuY3J0MCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5jb21v\n"
-        "ZG9jYS5jb20wDQYJKoZIhvcNAQEMBQADggIBAE4rdk+SHGI2ibp3wScF9BzWRJ2p\n"
-        "mj6q1WZmAT7qSeaiNbz69t2Vjpk1mA42GHWx3d1Qcnyu3HeIzg/3kCDKo2cuH1Z/\n"
-        "e+FE6kKVxF0NAVBGFfKBiVlsit2M8RKhjTpCipj4SzR7JzsItG8kO3KdY3RYPBps\n"
-        "P0/HEZrIqPW1N+8QRcZs2eBelSaz662jue5/DJpmNXMyYE7l3YphLG5SEXdoltMY\n"
-        "dVEVABt0iN3hxzgEQyjpFv3ZBdRdRydg1vs4O2xyopT4Qhrf7W8GjEXCBgCq5Ojc\n"
-        "2bXhc3js9iPc0d1sjhqPpepUfJa3w/5Vjo1JXvxku88+vZbrac2/4EjxYoIQ5QxG\n"
-        "V/Iz2tDIY+3GH5QFlkoakdH368+PUq4NCNk+qKBR6cGHdNXJ93SrLlP7u3r7l+L4\n"
-        "HyaPs9Kg4DdbKDsx5Q5XLVq4rXmsXiBmGqW5prU5wfWYQ//u+aen/e7KJD2AFsQX\n"
-        "j4rBYKEMrltDR5FL1ZoXX/nUh8HCjLfn4g8wGTeGrODcQgPmlKidrv0PJFGUzpII\n"
-        "0fxQ8ANAe4hZ7Q7drNJ3gjTcBpUC2JD5Leo31Rpg0Gcg19hCC0Wvgmje3WYkN5Ap\n"
-        "lBlGGSW4gNfL1IYoakRwJiNiqZ+Gb7+6kHDSVneFeO/qJakXzlByjAA6quPbYzSf\n"
-        "+AZxAeKCINT+b72x\n"
+"MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEU\n"
+"MBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFs\n"
+"IFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290\n"
+"MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0Ux\n"
+"FDASBgNVBAoTC0FkZFRydXN0IEFCMSYwJAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5h\n"
+"bCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1c3QgRXh0ZXJuYWwgQ0EgUm9v\n"
+"dDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3GjPm8gAELTngTlvt\n"
+"H7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCwSXrbLpX9\n"
+"uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX\n"
+"mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LX\n"
+"a0Tkx63ubUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzN\n"
+"E0S3ySvdQwAl+mG5aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0\n"
+"WicCAwEAAaOB3DCB2TAdBgNVHQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYD\n"
+"VR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgZkGA1UdIwSBkTCBjoAUrb2YejS0\n"
+"Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRU\n"
+"cnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwgVFRQIE5ldHdvcmsx\n"
+"IjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJKoZIhvcN\n"
+"AQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH\n"
+"YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw5\n"
+"6wwCURQtjr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvC\n"
+"Nr4TDea9Y355e6cJDUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEX\n"
+"c4g/VhsxOBi0cQ+azcgOno4uG+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5a\n"
+"mnkPIAou1Z5jJh5VkpTYghdae9C8x49OhgQ=\n"
         "-----END CERTIFICATE-----\n";
-
+#else
+const char certificates[] =
+        // Comodo RSA Domain Validation Secure Server CA
+"-----BEGIN CERTIFICATE-----\n"
+"MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEU\n"
+"MBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFs\n"
+"IFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290\n"
+"MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0Ux\n"
+"FDASBgNVBAoTC0FkZFRydXN0IEFCMSYwJAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5h\n"
+"bCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1c3QgRXh0ZXJuYWwgQ0EgUm9v\n"
+"dDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3GjPm8gAELTngTlvt\n"
+"H7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCwSXrbLpX9\n"
+"uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX\n"
+"mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LX\n"
+"a0Tkx63ubUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzN\n"
+"E0S3ySvdQwAl+mG5aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0\n"
+"WicCAwEAAaOB3DCB2TAdBgNVHQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYD\n"
+"VR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgZkGA1UdIwSBkTCBjoAUrb2YejS0\n"
+"Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRU\n"
+"cnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwgVFRQIE5ldHdvcmsx\n"
+"IjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJKoZIhvcN\n"
+"AQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH\n"
+"YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw5\n"
+"6wwCURQtjr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvC\n"
+"Nr4TDea9Y355e6cJDUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEX\n"
+"c4g/VhsxOBi0cQ+azcgOno4uG+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5a\n"
+"mnkPIAou1Z5jJh5VkpTYghdae9C8x49OhgQ=\n"
+"-----END CERTIFICATE-----\n"
+"-----BEGIN CERTIFICATE-----\n"
+"MIIFdDCCBFygAwIBAgIQJ2buVutJ846r13Ci/ITeIjANBgkqhkiG9w0BAQwFADBv\n"
+"MQswCQYDVQQGEwJTRTEUMBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFk\n"
+"ZFRydXN0IEV4dGVybmFsIFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBF\n"
+"eHRlcm5hbCBDQSBSb290MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFow\n"
+"gYUxCzAJBgNVBAYTAkdCMRswGQYDVQQIExJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAO\n"
+"BgNVBAcTB1NhbGZvcmQxGjAYBgNVBAoTEUNPTU9ETyBDQSBMaW1pdGVkMSswKQYD\n"
+"VQQDEyJDT01PRE8gUlNBIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIICIjANBgkq\n"
+"hkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAkehUktIKVrGsDSTdxc9EZ3SZKzejfSNw\n"
+"AHG8U9/E+ioSj0t/EFa9n3Byt2F/yUsPF6c947AEYe7/EZfH9IY+Cvo+XPmT5jR6\n"
+"2RRr55yzhaCCenavcZDX7P0N+pxs+t+wgvQUfvm+xKYvT3+Zf7X8Z0NyvQwA1onr\n"
+"ayzT7Y+YHBSrfuXjbvzYqOSSJNpDa2K4Vf3qwbxstovzDo2a5JtsaZn4eEgwRdWt\n"
+"4Q08RWD8MpZRJ7xnw8outmvqRsfHIKCxH2XeSAi6pE6p8oNGN4Tr6MyBSENnTnIq\n"
+"m1y9TBsoilwie7SrmNnu4FGDwwlGTm0+mfqVF9p8M1dBPI1R7Qu2XK8sYxrfV8g/\n"
+"vOldxJuvRZnio1oktLqpVj3Pb6r/SVi+8Kj/9Lit6Tf7urj0Czr56ENCHonYhMsT\n"
+"8dm74YlguIwoVqwUHZwK53Hrzw7dPamWoUi9PPevtQ0iTMARgexWO/bTouJbt7IE\n"
+"IlKVgJNp6I5MZfGRAy1wdALqi2cVKWlSArvX31BqVUa/oKMoYX9w0MOiqiwhqkfO\n"
+"KJwGRXa/ghgntNWutMtQ5mv0TIZxMOmm3xaG4Nj/QN370EKIf6MzOi5cHkERgWPO\n"
+"GHFrK+ymircxXDpqR+DDeVnWIBqv8mqYqnK8V0rSS527EPywTEHl7R09XiidnMy/\n"
+"s1Hap0flhFMCAwEAAaOB9DCB8TAfBgNVHSMEGDAWgBStvZh6NLQm9/rEJlTvA73g\n"
+"JMtUGjAdBgNVHQ4EFgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQD\n"
+"AgGGMA8GA1UdEwEB/wQFMAMBAf8wEQYDVR0gBAowCDAGBgRVHSAAMEQGA1UdHwQ9\n"
+"MDswOaA3oDWGM2h0dHA6Ly9jcmwudXNlcnRydXN0LmNvbS9BZGRUcnVzdEV4dGVy\n"
+"bmFsQ0FSb290LmNybDA1BggrBgEFBQcBAQQpMCcwJQYIKwYBBQUHMAGGGWh0dHA6\n"
+"Ly9vY3NwLnVzZXJ0cnVzdC5jb20wDQYJKoZIhvcNAQEMBQADggEBAGS/g/FfmoXQ\n"
+"zbihKVcN6Fr30ek+8nYEbvFScLsePP9NDXRqzIGCJdPDoCpdTPW6i6FtxFQJdcfj\n"
+"Jw5dhHk3QBN39bSsHNA7qxcS1u80GH4r6XnTq1dFDK8o+tDb5VCViLvfhVdpfZLY\n"
+"Uspzgb8c8+a4bmYRBbMelC1/kZWSWfFMzqORcUx8Rww7Cxn2obFshj5cqsQugsv5\n"
+"B5a6SE2Q8pTIqXOi6wZ7I53eovNNVZ96YUWYGGjHXkBrI/V5eu+MtWuLt29G9Hvx\n"
+"PUsE2JOAWVrgQSQdso8VYFhH2+9uRv0V9dlfmrPb2LjkQLPNlzmuhbsdjrzch5vR\n"
+"pu/xO28QOG8=\n"
+"-----END CERTIFICATE-----\n"
+"-----BEGIN CERTIFICATE-----\n"
+"MIIGCDCCA/CgAwIBAgIQKy5u6tl1NmwUim7bo3yMBzANBgkqhkiG9w0BAQwFADCB\n"
+"hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G\n"
+"A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV\n"
+"BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTQwMjEy\n"
+"MDAwMDAwWhcNMjkwMjExMjM1OTU5WjCBkDELMAkGA1UEBhMCR0IxGzAZBgNVBAgT\n"
+"EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR\n"
+"Q09NT0RPIENBIExpbWl0ZWQxNjA0BgNVBAMTLUNPTU9ETyBSU0EgRG9tYWluIFZh\n"
+"bGlkYXRpb24gU2VjdXJlIFNlcnZlciBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\n"
+"ADCCAQoCggEBAI7CAhnhoFmk6zg1jSz9AdDTScBkxwtiBUUWOqigwAwCfx3M28Sh\n"
+"bXcDow+G+eMGnD4LgYqbSRutA776S9uMIO3Vzl5ljj4Nr0zCsLdFXlIvNN5IJGS0\n"
+"Qa4Al/e+Z96e0HqnU4A7fK31llVvl0cKfIWLIpeNs4TgllfQcBhglo/uLQeTnaG6\n"
+"ytHNe+nEKpooIZFNb5JPJaXyejXdJtxGpdCsWTWM/06RQ1A/WZMebFEh7lgUq/51\n"
+"UHg+TLAchhP6a5i84DuUHoVS3AOTJBhuyydRReZw3iVDpA3hSqXttn7IzW3uLh0n\n"
+"c13cRTCAquOyQQuvvUSH2rnlG51/ruWFgqUCAwEAAaOCAWUwggFhMB8GA1UdIwQY\n"
+"MBaAFLuvfgI9+qbxPISOre44mOzZMjLUMB0GA1UdDgQWBBSQr2o6lFoL2JDqElZz\n"
+"30O0Oija5zAOBgNVHQ8BAf8EBAMCAYYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNV\n"
+"HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwGwYDVR0gBBQwEjAGBgRVHSAAMAgG\n"
+"BmeBDAECATBMBgNVHR8ERTBDMEGgP6A9hjtodHRwOi8vY3JsLmNvbW9kb2NhLmNv\n"
+"bS9DT01PRE9SU0FDZXJ0aWZpY2F0aW9uQXV0aG9yaXR5LmNybDBxBggrBgEFBQcB\n"
+"AQRlMGMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9jcnQuY29tb2RvY2EuY29tL0NPTU9E\n"
+"T1JTQUFkZFRydXN0Q0EuY3J0MCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5jb21v\n"
+"ZG9jYS5jb20wDQYJKoZIhvcNAQEMBQADggIBAE4rdk+SHGI2ibp3wScF9BzWRJ2p\n"
+"mj6q1WZmAT7qSeaiNbz69t2Vjpk1mA42GHWx3d1Qcnyu3HeIzg/3kCDKo2cuH1Z/\n"
+"e+FE6kKVxF0NAVBGFfKBiVlsit2M8RKhjTpCipj4SzR7JzsItG8kO3KdY3RYPBps\n"
+"P0/HEZrIqPW1N+8QRcZs2eBelSaz662jue5/DJpmNXMyYE7l3YphLG5SEXdoltMY\n"
+"dVEVABt0iN3hxzgEQyjpFv3ZBdRdRydg1vs4O2xyopT4Qhrf7W8GjEXCBgCq5Ojc\n"
+"2bXhc3js9iPc0d1sjhqPpepUfJa3w/5Vjo1JXvxku88+vZbrac2/4EjxYoIQ5QxG\n"
+"V/Iz2tDIY+3GH5QFlkoakdH368+PUq4NCNk+qKBR6cGHdNXJ93SrLlP7u3r7l+L4\n"
+"HyaPs9Kg4DdbKDsx5Q5XLVq4rXmsXiBmGqW5prU5wfWYQ//u+aen/e7KJD2AFsQX\n"
+"j4rBYKEMrltDR5FL1ZoXX/nUh8HCjLfn4g8wGTeGrODcQgPmlKidrv0PJFGUzpII\n"
+"0fxQ8ANAe4hZ7Q7drNJ3gjTcBpUC2JD5Leo31Rpg0Gcg19hCC0Wvgmje3WYkN5Ap\n"
+"lBlGGSW4gNfL1IYoakRwJiNiqZ+Gb7+6kHDSVneFeO/qJakXzlByjAA6quPbYzSf\n"
+"+AZxAeKCINT+b72x\n"
+"-----END CERTIFICATE-----\n";
+#endif
 const char bos_root_ca[] = "-----BEGIN CERTIFICATE-----\n"
     "MIIE0zCCA7ugAwIBAgIQGNrRniZ96LtKIVjNzGs7SjANBgkqhkiG9w0BAQUFADCB\n"
     "yjELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQL\n"
diff -uNr src/crt_abstractions.c src_ok/crt_abstractions.c
--- src/crt_abstractions.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/crt_abstractions.c	2018-09-03 16:45:36.000000000 +0800
@@ -3,16 +3,9 @@
 
 #define __STDC_WANT_LIB_EXT1__ 1
 
-#include <stdlib.h>
-#include <stddef.h>
-#include <stdarg.h>
-#include <limits.h>
-#include <float.h>
-#include <math.h>
-#include <errno.h>
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/crt_abstractions.h"
+#include "esp_types.h"
+#include "crt_abstractions.h"
+#include "errno.h"
 
 // VS 2008 does not have INFINITY and all the nice goodies...
 #if defined (TIZENRT) || defined (WINCE)
@@ -45,7 +38,7 @@
 #else
 
 /*Codes_SRS_CRT_ABSTRACTIONS_99_008: [strcat_s shall append the src to dst and terminates the resulting string with a null character.]*/
-int strcat_s(char* dst, size_t dstSizeInBytes, const char* src)
+int  ICACHE_FLASH_ATTR strcat_s(char* dst, size_t dstSizeInBytes, const char* src)
 {
     int result;
     /*Codes_SRS_CRT_ABSTRACTIONS_99_004: [If dst is NULL or unterminated, the error code returned shall be EINVAL & dst shall not be modified.]*/
@@ -105,7 +98,7 @@
 
     return result;
 }
-
+#if 0
 /*Codes_SRS_CRT_ABSTRACTIONS_99_025: [strncpy_s shall copy the first N characters of src to dst, where N is the lesser of MaxCount and the length of src.]*/
 int strncpy_s(char* dst, size_t dstSizeInBytes, const char* src, size_t maxCount)
 {
@@ -174,9 +167,10 @@
 
     return result;
 }
+#endif
 
 /* Codes_SRS_CRT_ABSTRACTIONS_99_016: [strcpy_s shall copy the contents in the address of src, including the terminating null character, to the location that's specified by dst.]*/
-int strcpy_s(char* dst, size_t dstSizeInBytes, const char* src)
+int  ICACHE_FLASH_ATTR strcpy_s(char* dst, size_t dstSizeInBytes, const char* src)
 {
     int result;
 
@@ -219,6 +213,7 @@
 
 /*Codes_SRS_CRT_ABSTRACTIONS_99_029: [The sprintf_s function shall format and store series of characters and values in dst.  Each argument (if any) is converted and output according to the corresponding Format Specification in the format variable.]*/
 /*Codes_SRS_CRT_ABSTRACTIONS_99_031: [A null character is appended after the last character written.]*/
+#if 0
 int sprintf_s(char* dst, size_t dstSizeInBytes, const char* format, ...)
 {
     int result;
@@ -274,6 +269,7 @@
     }
     return result;
 }
+#endif
 #endif /* _MSC_VER */
 
 /*Codes_SRS_CRT_ABSTRACTIONS_21_006: [The strtoull_s must use the letters from a(or A) through z(or Z) to represent the numbers between 10 to 35.]*/
@@ -287,6 +283,7 @@
 /*Codes_SRS_CRT_ABSTRACTIONS_21_001: [The strtoull_s must convert the initial portion of the string pointed to by nptr to unsigned long long int representation.]*/
 /*Codes_SRS_CRT_ABSTRACTIONS_21_002: [The strtoull_s must resembling an integer represented in some radix determined by the value of base.]*/
 /*Codes_SRS_CRT_ABSTRACTIONS_21_003: [The strtoull_s must return the integer that represents the value in the initial part of the string. If any.]*/
+#if 0
 unsigned long long strtoull_s(const char* nptr, char** endptr, int base)
 {
     unsigned long long result = 0ULL;
@@ -387,12 +384,13 @@
 
     return result;
 }
+#endif
 
 /*Codes_SRS_CRT_ABSTRACTIONS_21_023: [If the string is 'INF' of 'INFINITY' (ignoring case), the strtof_s must return the INFINITY value for float.]*/
 /*Codes_SRS_CRT_ABSTRACTIONS_21_024: [If the string is 'NAN' or 'NAN(...)' (ignoring case), the strtof_s must return 0.0f and points endptr to the first character after the 'NAN' sequence.]*/
 /*Codes_SRS_CRT_ABSTRACTIONS_21_033: [If the string is 'INF' of 'INFINITY' (ignoring case), the strtold_s must return the INFINITY value for long double.]*/
 /*Codes_SRS_CRT_ABSTRACTIONS_21_034: [If the string is 'NAN' or 'NAN(...)' (ignoring case), the strtold_s must return 0.0 and points endptr to the first character after the 'NAN' sequence.]*/
-static int substricmp(const char* nptr, const char* subsrt)
+static int  ICACHE_FLASH_ATTR substricmp(const char* nptr, const char* subsrt)
 {
     int result = 0;
     while (((*subsrt) != '\0') && (result == 0))
@@ -406,7 +404,7 @@
 
 /*Codes_SRS_CRT_ABSTRACTIONS_21_023: [If the string is 'INF' of 'INFINITY' (ignoring case), the strtof_s must return the INFINITY value for float.]*/
 /*Codes_SRS_CRT_ABSTRACTIONS_21_033: [If the string is 'INF' of 'INFINITY' (ignoring case), the strtold_s must return the INFINITY value for long double.]*/
-static bool isInfinity(const char** endptr)
+static bool  ICACHE_FLASH_ATTR isInfinity(const char** endptr)
 {
     bool result = false;
     if (substricmp((*endptr), "INF") == 0)
@@ -423,7 +421,7 @@
 
 /*Codes_SRS_CRT_ABSTRACTIONS_21_024: [If the string is 'NAN' or 'NAN(...)' (ignoring case), the strtof_s must return 0.0f and points endptr to the first character after the 'NAN' sequence.]*/
 /*Codes_SRS_CRT_ABSTRACTIONS_21_034: [If the string is 'NAN' or 'NAN(...)' (ignoring case), the strtold_s must return 0.0 and points endptr to the first character after the 'NAN' sequence.]*/
-static bool isNaN(const char** endptr)
+static bool  ICACHE_FLASH_ATTR isNaN(const char** endptr)
 {
     const char* runner = (*endptr);
     bool result = false;
@@ -457,6 +455,7 @@
 
 DEFINE_ENUM(FLOAT_STRING_TYPE, FLOAT_STRING_TYPE_VALUES);
 
+#if 0
 static FLOAT_STRING_TYPE splitFloatString(const char* nptr, char** endptr, int *signal, double *fraction, int *exponential)
 {
     FLOAT_STRING_TYPE result = FST_ERROR;
@@ -552,9 +551,11 @@
 
     return result;
 }
+#endif
 
 /*Codes_SRS_CRT_ABSTRACTIONS_21_015: [The strtof_s must convert the initial portion of the string pointed to by nptr to float representation.]*/
 /*Codes_SRS_CRT_ABSTRACTIONS_21_016: [The strtof_s must return the float that represents the value in the initial part of the string. If any.]*/
+#if 0
 float strtof_s(const char* nptr, char** endptr)
 {
     int signal = 1;
@@ -676,9 +677,9 @@
     return result;
 }
 
-
+#endif
 /*Codes_SRS_CRT_ABSTRACTIONS_99_038: [mallocAndstrcpy_s shall allocate memory for destination buffer to fit the string in the source parameter.]*/
-int mallocAndStrcpy_s(char** destination, const char* source)
+int ICACHE_FLASH_ATTR  mallocAndStrcpy_s(char** destination, const char* source)
 {
     int result;
 	int copied_result;
@@ -723,7 +724,7 @@
 /*10 => "10"*/
 /*return 0 when everything went ok*/
 /*Codes_SRS_CRT_ABSTRACTIONS_02_001: [unsignedIntToString shall convert the parameter value to its decimal representation as a string in the buffer indicated by parameter destination having the size indicated by parameter destinationSize.] */
-int unsignedIntToString(char* destination, size_t destinationSize, unsigned int value)
+int  ICACHE_FLASH_ATTR unsignedIntToString(char* destination, size_t destinationSize, unsigned int value)
 {
     int result;
     size_t pos;
@@ -774,7 +775,7 @@
 /*10 => "10"*/
 /*return 0 when everything went ok*/
 /*Codes_SRS_CRT_ABSTRACTIONS_02_001: [unsignedIntToString shall convert the parameter value to its decimal representation as a string in the buffer indicated by parameter destination having the size indicated by parameter destinationSize.] */
-int size_tToString(char* destination, size_t destinationSize, size_t value)
+int  ICACHE_FLASH_ATTR size_tToString(char* destination, size_t destinationSize, size_t value)
 {
     int result;
     size_t pos;
diff -uNr src/doublylinkedlist.c src_ok/doublylinkedlist.c
--- src/doublylinkedlist.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/doublylinkedlist.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,9 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include "azure_c_shared_utility/doublylinkedlist.h"
+#include "doublylinkedlist.h"
 
-void
+void  ICACHE_FLASH_ATTR 
 DList_InitializeListHead(
     PDLIST_ENTRY ListHead
 )
@@ -13,7 +13,7 @@
     return;
 }
 
-int
+int ICACHE_FLASH_ATTR 
 DList_IsListEmpty(
     const PDLIST_ENTRY ListHead
 )
@@ -23,7 +23,7 @@
     return (ListHead->Flink == ListHead);
 }
 
-int
+int ICACHE_FLASH_ATTR 
 DList_RemoveEntryList(
     PDLIST_ENTRY Entry
 )
@@ -42,7 +42,7 @@
     return (Flink == Blink);
 }
 
-PDLIST_ENTRY
+PDLIST_ENTRY ICACHE_FLASH_ATTR 
 DList_RemoveHeadList(
     PDLIST_ENTRY ListHead
 )
@@ -62,7 +62,7 @@
 
 
 
-void
+void ICACHE_FLASH_ATTR 
 DList_InsertTailList(
     PDLIST_ENTRY ListHead,
     PDLIST_ENTRY Entry
@@ -80,7 +80,7 @@
 }
 
 
-void
+void ICACHE_FLASH_ATTR 
 DList_AppendTailList(
     PDLIST_ENTRY ListHead,
     PDLIST_ENTRY ListToAppend
@@ -98,7 +98,7 @@
 
 
 /*Codes_SRS_DLIST_02_002: [DList_InsertHeadList inserts a singular entry in the list having as head listHead after "head".]*/
-void DList_InsertHeadList(PDLIST_ENTRY listHead, PDLIST_ENTRY entry)
+void  ICACHE_FLASH_ATTR DList_InsertHeadList(PDLIST_ENTRY listHead, PDLIST_ENTRY entry)
 {
     entry->Blink = listHead;
     entry->Flink = listHead->Flink;
diff -uNr src/iothub_client_persistence.c src_ok/iothub_client_persistence.c
--- src/iothub_client_persistence.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/iothub_client_persistence.c	2018-09-03 16:45:36.000000000 +0800
@@ -26,7 +26,7 @@
 #include "iothub_client_persistence_sqlite.h"
 #endif
 
-const PERSIST_INTERFACE_DESCRIPTION* get_default_persist_interface_description()
+const PERSIST_INTERFACE_DESCRIPTION*  ICACHE_FLASH_ATTR get_default_persist_interface_description()
 {
 #ifdef USE_SQLITE_PERSISTENCE
     return sqlite_get_persist_interface_description();
diff -uNr src/iothub_mqtt_client.c src_ok/iothub_mqtt_client.c
--- src/iothub_mqtt_client.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/iothub_mqtt_client.c	2018-09-03 16:45:36.000000000 +0800
@@ -17,12 +17,13 @@
 * limitations under the License.
 */
 
+#include "esp_types.h"
 #include "iothub_mqtt_client.h"
-#include <azure_c_shared_utility/tlsio.h>
-#include <azure_c_shared_utility/threadapi.h>
-#include "azure_c_shared_utility/socketio.h"
-#include "azure_c_shared_utility/platform.h"
-#include "certs.h"
+#include <tlsio.h>
+#include <threadapi.h>
+#include "socketio.h"
+#include "inc/platform.h"
+#include "inc/certs.h"
 
 #define EPOCH_TIME_T_VALUE          0
 #define EPOCH_TIME_T_VALUE          0
@@ -32,6 +33,8 @@
 #define MQTT_CONNECTION_TCP_PORT 1883
 #define MQTT_CONNECTION_TLS_PORT 1884
 
+#define USHRT_MAX 65535
+
 struct RETRY_LOGIC_TAG
 {
     IOTHUB_CLIENT_RETRY_POLICY retryPolicy; // Type of policy we're using
@@ -63,7 +66,10 @@
     DLIST_ENTRY entry;
 } MQTT_SUB_CALLBACK_INFO,* PMQTT_SUB_CALLBACK_INFO;
 
-static int RetryPolicy_Exponential_BackOff_With_Jitter(bool *permit, size_t* delay, void* retryContextCallback)
+
+IOTHUB_MQTT_CLIENT_HANDLE g_iotHubClient;
+
+static int  ICACHE_FLASH_ATTR RetryPolicy_Exponential_BackOff_With_Jitter(bool *permit, size_t* delay, void* retryContextCallback)
 {
     int result;
 
@@ -99,7 +105,7 @@
     return result;
 }
 
-static RETRY_LOGIC* CreateRetryLogic(IOTHUB_CLIENT_RETRY_POLICY retryPolicy, size_t retryTimeoutLimitInSeconds)
+static RETRY_LOGIC*  ICACHE_FLASH_ATTR CreateRetryLogic(IOTHUB_CLIENT_RETRY_POLICY retryPolicy, size_t retryTimeoutLimitInSeconds)
 {
     RETRY_LOGIC *retryLogic;
     retryLogic = (RETRY_LOGIC*)malloc(sizeof(RETRY_LOGIC));
@@ -110,27 +116,27 @@
         switch (retryLogic->retryPolicy)
         {
             case IOTHUB_CLIENT_RETRY_NONE:
-                // LogError("Not implemented chosing default");
+                // printf("Not implemented chosing default");
                 retryLogic->fnRetryPolicy = &RetryPolicy_Exponential_BackOff_With_Jitter;
                 break;
             case IOTHUB_CLIENT_RETRY_IMMEDIATE:
-                // LogError("Not implemented chosing default");
+                // printf("Not implemented chosing default");
                 retryLogic->fnRetryPolicy = &RetryPolicy_Exponential_BackOff_With_Jitter;
                 break;
             case IOTHUB_CLIENT_RETRY_INTERVAL:
-                // LogError("Not implemented chosing default");
+                // printf("Not implemented chosing default");
                 retryLogic->fnRetryPolicy = &RetryPolicy_Exponential_BackOff_With_Jitter;
                 break;
             case IOTHUB_CLIENT_RETRY_LINEAR_BACKOFF:
-                // LogError("Not implemented chosing default");
+                // printf("Not implemented chosing default");
                 retryLogic->fnRetryPolicy = &RetryPolicy_Exponential_BackOff_With_Jitter;
                 break;
             case IOTHUB_CLIENT_RETRY_EXPONENTIAL_BACKOFF:
-                // LogError("Not implemented chosing default");
+                // printf("Not implemented chosing default");
                 retryLogic->fnRetryPolicy = &RetryPolicy_Exponential_BackOff_With_Jitter;
                 break;
             case IOTHUB_CLIENT_RETRY_RANDOM:
-                // LogError("Not implemented chosing default");
+                // printf("Not implemented chosing default");
                 retryLogic->fnRetryPolicy = &RetryPolicy_Exponential_BackOff_With_Jitter;
                 break;
             case IOTHUB_CLIENT_RETRY_EXPONENTIAL_BACKOFF_WITH_JITTER:
@@ -148,12 +154,12 @@
     }
     else
     {
-        LogError("Init retry logic failed");
+        printf("Init retry logic failed");
     }
     return retryLogic;
 }
 
-static void DestroyRetryLogic(RETRY_LOGIC *retryLogic)
+static void ICACHE_FLASH_ATTR  DestroyRetryLogic(RETRY_LOGIC *retryLogic)
 {
     if (retryLogic != NULL)
     {
@@ -163,7 +169,7 @@
 }
 
 // Called when first attempted to re-connect
-static void StartRetryTimer(RETRY_LOGIC *retryLogic)
+static void  ICACHE_FLASH_ATTR StartRetryTimer(RETRY_LOGIC *retryLogic)
 {
     if (retryLogic != NULL)
     {
@@ -178,12 +184,12 @@
     }
     else
     {
-        LogError("Retry Logic parameter. NULL.");
+        printf("Retry Logic parameter. NULL.");
     }
 }
 
 // Called when connected
-static void StopRetryTimer(RETRY_LOGIC *retryLogic)
+static void  ICACHE_FLASH_ATTR StopRetryTimer(RETRY_LOGIC *retryLogic)
 {
     if (retryLogic != NULL)
     {
@@ -196,29 +202,29 @@
         }
         else
         {
-            LogError("Start retry logic before stopping");
+            printf("Start retry logic before stopping");
         }
     }
     else
     {
-        LogError("Retry Logic parameter. NULL.");
+        printf("Retry Logic parameter. NULL.");
     }
 }
 
 // Called for every do_work when connection is broken
-static bool CanRetry(RETRY_LOGIC *retryLogic)
+static bool ICACHE_FLASH_ATTR  CanRetry(RETRY_LOGIC *retryLogic)
 {
     bool result;
     time_t now = get_time(NULL);
 
     if (retryLogic == NULL)
     {
-        LogError("Retry Logic is not created, retrying forever");
+        printf("Retry Logic is not created, retrying forever");
         result = true;
     }
     else if (now < 0 || retryLogic->start < 0)
     {
-        LogError("Time could not be retrieved, retrying forever");
+        printf("Time could not be retrieved, retrying forever");
         result = true;
     }
     else if (retryLogic->retryExpired)
@@ -293,7 +299,7 @@
                     else
                     {
                         // Retry expired.  Stop trying.
-                        LogError("Retry timeout expired after %d attempts", retryLogic->retrycount);
+                        printf("Retry timeout expired after %d attempts", retryLogic->retrycount);
                         retryLogic->retryExpired = true;
                         StopRetryTimer(retryLogic);
                         result = false;
@@ -302,7 +308,7 @@
                 else
                 {
                     // We don't have a retry policy.  Sorry, can't even guess.  Don't bother even trying to retry.
-                    LogError("Cannot evaluate the next best time to retry");
+                    printf("Cannot evaluate the next best time to retry");
                     result = false;
                 }
             }
@@ -321,7 +327,7 @@
 }
 
 
-static uint16_t GetNextPacketId(IOTHUB_MQTT_CLIENT_HANDLE transport_data)
+static uint16_t  ICACHE_FLASH_ATTR GetNextPacketId(IOTHUB_MQTT_CLIENT_HANDLE transport_data)
 {
     if (transport_data->packetId+1 >= USHRT_MAX)
     {
@@ -334,7 +340,7 @@
     return transport_data->packetId;
 }
 
-static const char* RetrieveMqttReturnCodes(CONNECT_RETURN_CODE rtn_code)
+static const char*  ICACHE_FLASH_ATTR RetrieveMqttReturnCodes(CONNECT_RETURN_CODE rtn_code)
 {
     switch (rtn_code)
     {
@@ -356,7 +362,7 @@
     }
 }
 
-static void OnMqttOperationComplete(MQTT_CLIENT_HANDLE handle, MQTT_CLIENT_EVENT_RESULT actionResult, const void* msgInfo, void* callbackCtx)
+static void ICACHE_FLASH_ATTR  OnMqttOperationComplete(MQTT_CLIENT_HANDLE handle, MQTT_CLIENT_EVENT_RESULT actionResult, const void* msgInfo, void* callbackCtx)
 {
     (void)msgInfo;
     IOTHUB_MQTT_CLIENT_HANDLE iotHubClient = (IOTHUB_MQTT_CLIENT_HANDLE)callbackCtx;
@@ -374,6 +380,7 @@
                     iotHubClient->isConnectionLost = false;
                     iotHubClient->needPublishPersistMsg = true;
                     iotHubClient->mqttClientStatus = MQTT_CLIENT_STATUS_CONNECTED;
+                    printf("underlying mqtt connected!!!\n");
                     StopRetryTimer(iotHubClient->retryLogic);
                 }
                 else
@@ -391,14 +398,14 @@
                     {
                         iotHubClient->isRecoverableError = false;
                     }
-                    LogError("Connection Not Accepted: 0x%x: %s", connack->returnCode, RetrieveMqttReturnCodes(connack->returnCode));
+                    printf("Connection Not Accepted: 0x%x: %s", connack->returnCode, RetrieveMqttReturnCodes(connack->returnCode));
                     (void)mqtt_client_disconnect(iotHubClient->mqttClient, NULL, NULL);
                     iotHubClient->mqttClientStatus = MQTT_CLIENT_STATUS_NOT_CONNECTED;
                 }
             }
             else
             {
-                LogError("MQTT_CLIENT_ON_CONNACK CONNACK parameter is NULL.");
+                printf("MQTT_CLIENT_ON_CONNACK CONNACK parameter is NULL.");
             }
             break;
         }
@@ -412,7 +419,7 @@
                 {
                     if (suback->qosReturn[index] == DELIVER_FAILURE)
                     {
-                        LogError("Subscribe delivery failure of subscribe %zu", index);
+                        printf("Subscribe delivery failure of subscribe %zu", index);
                     }
                 }
 
@@ -436,7 +443,7 @@
             }
             else
             {
-                LogError("Failure: MQTT_CLIENT_ON_SUBSCRIBE_ACK SUBSCRIBE_ACK parameter is NULL.");
+                printf("Failure: MQTT_CLIENT_ON_SUBSCRIBE_ACK SUBSCRIBE_ACK parameter is NULL.");
             }
             break;
         }
@@ -467,7 +474,7 @@
             }
             else
             {
-                LogError("Failure: MQTT_CLIENT_ON_PUBLISH_ACK publish_ack structure NULL.");
+                printf("Failure: MQTT_CLIENT_ON_PUBLISH_ACK publish_ack structure NULL.");
             }
             break;
         }
@@ -500,7 +507,7 @@
             }
             else
             {
-                LogError("Failure: MQTT_CLIENT_ON_UNSUBSCRIBE_ACK UNSUBSCRIBE_ACK parameter is NULL.");
+                printf("Failure: MQTT_CLIENT_ON_UNSUBSCRIBE_ACK UNSUBSCRIBE_ACK parameter is NULL.");
             }
             break;
         }
@@ -510,19 +517,19 @@
         }
         default:
         {
-            (void)printf("unexpected value received for enumeration (%d)\n", (int)actionResult);
+            printf("unexpected value received for enumeration (%d)\n", (int)actionResult);
         }
     }
 }
 
-int publish_mqtt_message(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, const char* topicName,
+int  ICACHE_FLASH_ATTR publish_mqtt_message(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, const char* topicName,
                          QOS_VALUE qosValue, const uint8_t* appMsg, size_t appMsgLength, PUB_CALLBACK pubCallback, void* context)
 {
     int result = 0;
 
     if ( qosValue == DELIVER_EXACTLY_ONCE)
     {
-        LogError("Does not support qos = DELIVER_EXACTLY_ONCE");
+        printf("Does not support qos = DELIVER_EXACTLY_ONCE");
         result = __FAILURE__;
         return result;
     }
@@ -538,7 +545,7 @@
                                                                  topicName, strlen(topicName), qosValue,
                                                                  (const char*)appMsg, appMsgLength) != 0)
             {
-                LogError("Fail to write publish message to persistent storage");
+                printf("Fail to write publish message to persistent storage");
                 result = __FAILURE__;
                 return result;
             }
@@ -548,7 +555,7 @@
     MQTT_MESSAGE_HANDLE mqtt_get_msg = mqttmessage_create(packet_id, topicName, qosValue, appMsg, appMsgLength);
     if (mqtt_get_msg == NULL)
     {
-        LogError("Failed constructing mqtt message.");
+        printf("Failed constructing mqtt message.");
         result = __FAILURE__;
     }
     else
@@ -559,7 +566,7 @@
             pubCallbackHandle = (PMQTT_PUB_CALLBACK_INFO)malloc(sizeof(MQTT_PUB_CALLBACK_INFO));
             if (pubCallbackHandle == NULL)
             {
-                LogError("Fail to allocate memory for MQTT_PUB_CALLBACK_INFO");
+                printf("Fail to allocate memory for MQTT_PUB_CALLBACK_INFO");
                 mqttmessage_destroy(mqtt_get_msg);
                 result = __FAILURE__;
                 return result;
@@ -588,7 +595,7 @@
             {
                 pubCallback(MQTT_PUB_FAILED, context);
             }
-            LogError("Failed publishing to mqtt client.");
+            printf("Failed publishing to mqtt client.");
             result = __FAILURE__;
         }
         else
@@ -609,7 +616,7 @@
 }
 
 
-int subscribe_mqtt_topics(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, SUBSCRIBE_PAYLOAD *subPayloads,
+int ICACHE_FLASH_ATTR  subscribe_mqtt_topics(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, SUBSCRIBE_PAYLOAD *subPayloads,
                           size_t subSize, SUB_CALLBACK subCallback, void* context)
 {
 
@@ -617,16 +624,17 @@
 
     if (subPayloads == NULL || subSize == 0) {
         result = __FAILURE__;
-        LogError("Failure: maybe subPayload is invalid, or subSize is zero.");
+        printf("Failure: maybe subPayload is invalid, or subSize is zero.");
     }
     else
     {
+        int i;
         bool isQosCheckSuccess = true;
-        for (int i = 0; i< subSize; ++i)
+        for (i = 0; i< subSize; ++i)
         {
             if(subPayloads[i].qosReturn == DELIVER_EXACTLY_ONCE)
             {
-                LogError("IoT Hub does not support qos = DELIVER_EXACTLY_ONCE");
+                printf("IoT Hub does not support qos = DELIVER_EXACTLY_ONCE");
                 result = __FAILURE__;
                 isQosCheckSuccess = false;
                 break;
@@ -640,7 +648,7 @@
                 subCallbackHandle = (PMQTT_SUB_CALLBACK_INFO)malloc(sizeof(MQTT_SUB_CALLBACK_INFO));
                 if (subCallbackHandle == NULL)
                 {
-                    LogError("Fail to allocate memory for MQTT_PUB_CALLBACK_INFO");
+                    printf("Fail to allocate memory for MQTT_PUB_CALLBACK_INFO");
                     result = __FAILURE__;
                     return result;
                 }
@@ -655,7 +663,7 @@
 
             if (mqtt_client_subscribe(iotHubClient->mqttClient, packet_id, subPayloads, subSize) != 0)
             {
-                LogError("Failure: mqtt_client_subscribe returned error.");
+                printf("Failure: mqtt_client_subscribe returned error.");
                 result = __FAILURE__;
             }
         }
@@ -665,26 +673,26 @@
 }
 
 
-int unsubscribe_mqtt_topics(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, const char** unsubscribeList, size_t count)
+int ICACHE_FLASH_ATTR  unsubscribe_mqtt_topics(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, const char** unsubscribeList, size_t count)
 {
     int result = 0;
 
     if (unsubscribeList == NULL || count == 0)
     {
-        LogError("Failure: maybe unsubscribeList is invalid, or count is zero.");
+        printf("Failure: maybe unsubscribeList is invalid, or count is zero.");
         result = __FAILURE__;
     }
     else if (mqtt_client_unsubscribe(iotHubClient->mqttClient, GetNextPacketId(iotHubClient), unsubscribeList, count))
     {
-        LogError("Failure: mqtt_client_unsubscribe returned error.");
+        printf("Failure: mqtt_client_unsubscribe returned error.");
         result = __FAILURE__;
     }
 
     return result;
 }
 
-static void NotifySubscribeAckFailure(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient) {
-    LogError("notify all waiting for subscribe ack messages as failure");
+static void  ICACHE_FLASH_ATTR NotifySubscribeAckFailure(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient) {
+    printf("notify all waiting for subscribe ack messages as failure");
     PDLIST_ENTRY currentListEntry = iotHubClient->sub_ack_waiting_queue.Flink;
     // when ack_waiting_queue.Flink points to itself, return directly
     while (currentListEntry != &iotHubClient->sub_ack_waiting_queue) {
@@ -699,9 +707,9 @@
     }
 }
 
-static void NotifyPublishAckFailure(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
+static void ICACHE_FLASH_ATTR  NotifyPublishAckFailure(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
 {
-    LogError("notify all waiting for publish ack messages as failure");
+    printf("notify all waiting for publish ack messages as failure");
     PDLIST_ENTRY currentListEntry = iotHubClient->pub_ack_waiting_queue.Flink;
     // when ack_waiting_queue.Flink points to itself, return directly
     while (currentListEntry != &iotHubClient->pub_ack_waiting_queue)
@@ -726,7 +734,7 @@
 
             if (rc != 0)
             {
-                LogError("Fail to insert message into persitent storage when handle miss pub ack message");
+                printf("Fail to insert message into persitent storage when handle miss pub ack message");
             }
         }
         mqttmessage_destroy(mqttMsgEntry->msgHandle);
@@ -735,29 +743,29 @@
     }
 }
 
-static void OnMqttErrorComplete(MQTT_CLIENT_HANDLE handle, MQTT_CLIENT_EVENT_ERROR error, void* callbackCtx)
+static void ICACHE_FLASH_ATTR  OnMqttErrorComplete(MQTT_CLIENT_HANDLE handle, MQTT_CLIENT_EVENT_ERROR error, void* callbackCtx)
 {
     IOTHUB_MQTT_CLIENT_HANDLE iotHubClient = (IOTHUB_MQTT_CLIENT_HANDLE)callbackCtx;
     (void)handle;
     switch (error)
     {
         case MQTT_CLIENT_CONNECTION_ERROR:
-            LogError("receive mqtt client connection error");
+            printf("receive mqtt client connection error");
             break;
         case MQTT_CLIENT_PARSE_ERROR:
-            LogError("receive mqtt client parse error");
+            printf("receive mqtt client parse error");
             break;
         case MQTT_CLIENT_MEMORY_ERROR:
-            LogError("receive mqtt client memory error");
+            printf("receive mqtt client memory error");
             break;
         case MQTT_CLIENT_COMMUNICATION_ERROR:
-            LogError("receive mqtt client communication error");
+            printf("receive mqtt client communication error");
             break;
         case MQTT_CLIENT_NO_PING_RESPONSE:
-            LogError("receive mqtt client ping error");
+            printf("receive mqtt client ping error");
             break;
         case MQTT_CLIENT_UNKNOWN_ERROR:
-            LogError("receive mqtt client unknown error");
+            printf("receive mqtt client unknown error");
             break;
     }
     // mark connection as not connected
@@ -769,7 +777,7 @@
     NotifyPublishAckFailure(iotHubClient);
 }
 
-static void ClearMqttOptions(MQTT_CLIENT_OPTIONS* mqttOptions)
+static void  ICACHE_FLASH_ATTR ClearMqttOptions(MQTT_CLIENT_OPTIONS* mqttOptions)
 {
     free(mqttOptions->clientId);
     mqttOptions->clientId = NULL;
@@ -784,7 +792,7 @@
     free(mqttOptions);
 }
 
-static void InitMqttOptions(MQTT_CLIENT_OPTIONS* mqttOptions)
+static void ICACHE_FLASH_ATTR  InitMqttOptions(MQTT_CLIENT_OPTIONS* mqttOptions)
 {
     mqttOptions->clientId = NULL;
     mqttOptions->willTopic = NULL;
@@ -798,7 +806,7 @@
     mqttOptions->log_trace = false;
 }
 
-static int CloneMqttOptions(MQTT_CLIENT_OPTIONS** newMqttOptions, const MQTT_CLIENT_OPTIONS* mqttOptions)
+static int  ICACHE_FLASH_ATTR CloneMqttOptions(MQTT_CLIENT_OPTIONS** newMqttOptions, const MQTT_CLIENT_OPTIONS* mqttOptions)
 {
     int result = 0;
     *newMqttOptions = (MQTT_CLIENT_OPTIONS *)malloc(sizeof(MQTT_CLIENT_OPTIONS));
@@ -867,7 +875,7 @@
     return result;
 }
 
-static XIO_HANDLE CreateTcpConnection(const char *endpoint)
+static XIO_HANDLE  ICACHE_FLASH_ATTR CreateTcpConnection(const char *endpoint)
 {
     SOCKETIO_CONFIG config = {endpoint, MQTT_CONNECTION_TCP_PORT, NULL};
 
@@ -876,7 +884,7 @@
     return xio;
 }
 
-static XIO_HANDLE CreateTlsConnection(const char *endpoint)
+static XIO_HANDLE ICACHE_FLASH_ATTR  CreateTlsConnection(const char *endpoint)
 {
     TLSIO_CONFIG tlsio_config = { endpoint, MQTT_CONNECTION_TLS_PORT };
     // enable wolfssl by set certificates
@@ -891,7 +899,7 @@
     return xio;
 }
 
-static XIO_HANDLE CreateMutualTlsConnection(const char *endpoint, const char *client_cert_in_option, const char *client_key_in_option)
+static XIO_HANDLE ICACHE_FLASH_ATTR  CreateMutualTlsConnection(const char *endpoint, const char *client_cert_in_option, const char *client_key_in_option)
 {
     TLSIO_CONFIG tlsio_config = { endpoint, MQTT_CONNECTION_TLS_PORT };
     // enable wolfssl by set certificates
@@ -914,7 +922,7 @@
     return xio;
 }
 
-static void DisconnectFromClient(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
+static void  ICACHE_FLASH_ATTR DisconnectFromClient(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
 {
     (void)mqtt_client_disconnect(iotHubClient->mqttClient, NULL, NULL);
     xio_destroy(iotHubClient->xioTransport);
@@ -923,10 +931,11 @@
     iotHubClient->mqttClientStatus = MQTT_CLIENT_STATUS_NOT_CONNECTED;
 }
 
-static int SendMqttConnectMessage(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
+static int  ICACHE_FLASH_ATTR SendMqttConnectMessage(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
 {
     int result = 0;
 
+    printf("==> SendMqttConnectMessage\n");
     switch (iotHubClient->connType)
     {
         case MQTT_CONNECTION_TCP:
@@ -943,7 +952,7 @@
 
     if (iotHubClient->xioTransport == NULL)
     {
-        LogError("failed to create connection with server");
+        printf("failed to create connection with server");
         // TODO: add code to handle release data for IOTHUB_MQTT_CLIENT_HANDLE
         result = __FAILURE__;
     }
@@ -951,7 +960,7 @@
     {
         if (mqtt_client_connect(iotHubClient->mqttClient, iotHubClient->xioTransport, iotHubClient->options) != 0)
         {
-            LogError("failed to initialize mqtt connection with server");
+            printf("failed to initialize mqtt connection with server");
             // TODO: add code to handle release data for IOTHUB_MQTT_CLIENT_HANDLE
             result = __FAILURE__;
         }
@@ -965,11 +974,12 @@
     return result;
 }
 
-IOTHUB_MQTT_CLIENT_HANDLE initialize_mqtt_client_handle(const MQTT_CLIENT_OPTIONS *options, const char* endpoint,
+IOTHUB_MQTT_CLIENT_HANDLE  ICACHE_FLASH_ATTR initialize_mqtt_client_handle(const MQTT_CLIENT_OPTIONS *options, const char* endpoint,
                                                         MQTT_CONNECTION_TYPE connType, ON_MQTT_MESSAGE_RECV_CALLBACK callback,
                                                         IOTHUB_CLIENT_RETRY_POLICY retryPolicy, size_t retryTimeoutLimitInSeconds )
 {
-    IOTHUB_MQTT_CLIENT_HANDLE iotHubClient = (IOTHUB_MQTT_CLIENT_HANDLE)malloc(sizeof(IOTHUB_MQTT_CLIENT));
+    printf("==> initialize_mqtt_client_handle\n");
+    IOTHUB_MQTT_CLIENT_HANDLE iotHubClient = g_iotHubClient = (IOTHUB_MQTT_CLIENT_HANDLE)malloc(sizeof(IOTHUB_MQTT_CLIENT));
 
     if (iotHubClient == NULL) {
         LOG(AZ_LOG_ERROR, LOG_LINE, "malloc IOTHUB_MQTT_CLIENT failed");
@@ -1017,7 +1027,7 @@
 
     if(iotHubClient->mqttClient == NULL)
     {
-        LogError("failure initializing mqtt client.");
+        printf("failure initializing mqtt client.");
         tickcounter_destroy(iotHubClient->msgTickCounter);
         ClearMqttOptions(iotHubClient->options);
         free(iotHubClient->endpoint);
@@ -1039,7 +1049,7 @@
     {
         if (iotHubClient->persistInterDesc->concrete_initialize_handle(&iotHubClient->persistHandle, options->clientId, PERSIST_NAME_SUFFIX) != 0)
         {
-            LogError("fail to initialize persist handle");
+            printf("fail to initialize persist handle");
             free(iotHubClient->endpoint);
             ClearMqttOptions(iotHubClient->options);
             mqtt_client_deinit(iotHubClient->mqttClient);
@@ -1052,13 +1062,14 @@
     return iotHubClient;
 }
 
-void set_client_cert(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, const char* client_cert, const char* client_key) {
+void  ICACHE_FLASH_ATTR set_client_cert(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, const char* client_cert, const char* client_key) {
     iotHubClient->client_cert = (char *) client_cert;
     iotHubClient->client_key = (char *) client_key;
 }
 
-int initialize_mqtt_connection(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
+int ICACHE_FLASH_ATTR  initialize_mqtt_connection(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
 {
+    printf("==> initialize_mqtt_connection\n");
     int result = 0;
 
     // Make sure we're not destroying the object
@@ -1070,6 +1081,7 @@
             && iotHubClient->mqttClientStatus == MQTT_CLIENT_STATUS_NOT_CONNECTED
             && CanRetry(iotHubClient->retryLogic))
         {
+            printf("not connected and will SendMqttConnectMessage\n");
             if (tickcounter_get_current_ms(iotHubClient->msgTickCounter, &iotHubClient->connectTick) != 0)
             {
                 iotHubClient->connectFailCount++;
@@ -1101,21 +1113,23 @@
             // Codes_SRS_IOTHUB_TRANSPORT_MQTT_COMMON_09_001: [ IoTHubTransport_MQTT_Common_DoWork shall trigger reconnection if the mqtt_client_connect does not complete within `keepalive` seconds]
         else if (iotHubClient->mqttClientStatus == MQTT_CLIENT_STATUS_CONNECTING)
         {
+            printf("MQTT_CLIENT_STATUS_CONNECTING\n");
             tickcounter_ms_t current_time;
             if (tickcounter_get_current_ms(iotHubClient->msgTickCounter, &current_time) != 0)
             {
-                LogError("failed verifying MQTT_CLIENT_STATUS_CONNECTING timeout");
+                printf("failed verifying MQTT_CLIENT_STATUS_CONNECTING timeout");
                 result = __FAILURE__;
             }
-            else if ((current_time - iotHubClient->mqtt_connect_time) / 1000 > iotHubClient->options->keepAliveInterval)
+            /*else if ((current_time - iotHubClient->mqtt_connect_time) / 1000 > iotHubClient->options->keepAliveInterval)
             {
-                LogError("mqtt_client timed out waiting for CONNACK");
+                printf("mqtt_client timed out waiting for CONNACK");
                 DisconnectFromClient(iotHubClient);
                 result = 0;
-            }
+            }*/
         }
         else if (iotHubClient->mqttClientStatus == MQTT_CLIENT_STATUS_CONNECTED)
         {
+            printf("MQTT_CLIENT_STATUS_CONNECTED\n");
             // We are connected and not being closed
             tickcounter_ms_t current_time;
             if (tickcounter_get_current_ms(iotHubClient->msgTickCounter, &current_time) != 0)
@@ -1129,46 +1143,72 @@
 
 }
 
-// timeout is used to set timeout window for connection in seconds
-int iothub_mqtt_doconnect(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, size_t timeout)
+static tickcounter_ms_t g_lastSendTime;
+static size_t g_timeout;
+static os_timer_t dowork_timer;
+
+void dowork_func(void *arg)
 {
-    int result = 0;
-    tickcounter_ms_t currentTime, lastSendTime;
-    tickcounter_get_current_ms(iotHubClient->msgTickCounter, &lastSendTime);
+    printf("==> dowork_func in iothub_mqtt_client.c\n");
+    int result;
+    tickcounter_ms_t currentTime;
+    IOT_CONN_DONEXT_CB cb = (IOT_CONN_DONEXT_CB)arg;
 
-    do
-    {
-        iothub_mqtt_dowork(iotHubClient);
-        ThreadAPI_Sleep(10);
-        tickcounter_get_current_ms(iotHubClient->msgTickCounter, &currentTime);
-    } while (iotHubClient->mqttClientStatus != MQTT_CLIENT_STATUS_CONNECTED
-             && iotHubClient->isRecoverableError
-             && (currentTime - lastSendTime) / 1000 <= timeout);
+    iothub_mqtt_dowork(g_iotHubClient);
+    tickcounter_get_current_ms(g_iotHubClient->msgTickCounter, &currentTime);
+    printf("cur ts: %d, last ts: %d, timout: %d\n", currentTime, g_lastSendTime, g_timeout);
+
+    if (g_iotHubClient->mqttClientStatus != MQTT_CLIENT_STATUS_CONNECTED
+             && g_iotHubClient->isRecoverableError
+             && (currentTime - g_lastSendTime) / 1000 <= g_timeout) {
+                 printf("continue 5s waiting...\n");
+    } else {
+        os_timer_disarm(&dowork_timer);
 
-    if ((currentTime - lastSendTime) / 1000 > timeout)
-    {
-        LogError("failed to waitfor connection complete in %d seconds", timeout);
-        result = __FAILURE__;
-        return result;
+        if ((currentTime - g_lastSendTime) / 1000 > g_timeout) {
+            printf("failed to waitfor connection complete in %d seconds", g_timeout);
+            result = __FAILURE__;
+        } else if (g_iotHubClient->mqttClientStatus == MQTT_CLIENT_STATUS_CONNECTED) {
+            printf("connected!! notiry to app\n");
+            result = 0;
+        } else {
+            result = __FAILURE__;
+        }
+        
+        cb(result);
     }
+    
+}
 
-    if (iotHubClient->mqttClientStatus == MQTT_CLIENT_STATUS_CONNECTED)
-    {
-        result = 0;
-    }
-    else
-    {
-        result = __FAILURE__;
-    }
 
+
+// timeout is used to set timeout window for connection in seconds
+int  ICACHE_FLASH_ATTR iothub_mqtt_doconnect(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient, size_t timeout, void* cb)
+{
+    printf("==> iothub_mqtt_doconnect\n");
+    int result = 0;
+    tickcounter_ms_t currentTime;
+    tickcounter_get_current_ms(iotHubClient->msgTickCounter, &g_lastSendTime);
+    
+
+    os_timer_disarm(&dowork_timer);
+    os_timer_setfn(&dowork_timer, (os_timer_func_t *)dowork_func, cb);
+    os_timer_arm(&dowork_timer, 2000, 1); //check every 2s
+    g_timeout = timeout;
+
+
+    printf("try connect...\n");
+    iothub_mqtt_dowork(iotHubClient);
+    
     return result;
 }
 
-void iothub_mqtt_dowork(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
+void  ICACHE_FLASH_ATTR iothub_mqtt_dowork(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
 {
+    printf("==> iothub_mqtt_dowork\n");
     if (initialize_mqtt_connection(iotHubClient) != 0)
     {
-        LogError("fail to establish connection with server");
+        printf("fail to establish connection with server");
     }
     else
     {
@@ -1183,25 +1223,26 @@
                 int rc = iotHubClient->persistInterDesc->concrete_get_messages(iotHubClient->persistHandle, &pubMessages, &pubMsgCount);
                 if (rc != 0)
                 {
-                    LogError("Fail to read data from persist storage");
+                    printf("Fail to read data from persist storage");
                 }
                 else if (pubMsgCount != 0)
                 {
-                    for (int i = 0;i < pubMsgCount; ++i)
+                    int i;
+                    for (i = 0;i < pubMsgCount; ++i)
                     {
                         rc = publish_mqtt_message(iotHubClient, pubMessages[i].topicName,
                                              pubMessages[i].qos, (const uint8_t *)pubMessages[i].payload, pubMessages[i].payloadLen, NULL, NULL);
 
                         if (rc != 0)
                         {
-                            LogError("Fail to publish message get from persist storage");
+                            printf("Fail to publish message get from persist storage");
                         }
 
                         // delete message from persist storage
                         rc = iotHubClient->persistInterDesc->concrete_delete_message(iotHubClient->persistHandle, pubMessages[i].messageId);
                         if (rc != 0)
                         {
-                            LogError("Fail to delete message from persist storage");
+                            printf("Fail to delete message from persist storage");
                         }
                     }
                     // release memory allocated for publish message
@@ -1213,14 +1254,14 @@
     }
 }
 
-int iothub_mqtt_disconnect(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
+int  ICACHE_FLASH_ATTR iothub_mqtt_disconnect(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
 {
     int result = mqtt_client_disconnect(iotHubClient->mqttClient, NULL, NULL);
     iotHubClient->isDisconnectCalled = true;
     return result;
 }
 
-void iothub_mqtt_destroy(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
+void  ICACHE_FLASH_ATTR iothub_mqtt_destroy(IOTHUB_MQTT_CLIENT_HANDLE iotHubClient)
 {
     if (iotHubClient != NULL)
     {
@@ -1246,4 +1287,4 @@
 
         free(iotHubClient);
     }
-}
+}
\ No newline at end of file
diff -uNr src/iothub_mqtt_client_sample.c src_ok/iothub_mqtt_client_sample.c
--- src/iothub_mqtt_client_sample.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/iothub_mqtt_client_sample.c	2018-09-03 16:45:36.000000000 +0800
@@ -17,9 +17,10 @@
 * limitations under the License.
 */
 
-#include <azure_c_shared_utility/platform.h>
-#include <azure_c_shared_utility/utf8_checker.h>
-#include <azure_c_shared_utility/threadapi.h>
+#include "esp_types.h"
+#include <inc/platform.h>
+#include <utf8_checker.h>
+#include <threadapi.h>
 #include "iothub_mqtt_client.h"
 #include "iothub_mqtt_client_sample.h"
 
@@ -28,13 +29,13 @@
 #define         ENDPOINT                    "xxxxxx.mqtt.iot.xx.baidubce.com"
 
 // The mqtt client username, and the format is like "xxxxxx/xxxx".
-#define         USERNAME                    "xxxxxx/xxxx"
+#define         USERNAME                    "xxxxxx/xxxxn"
 
 // The key (password) of mqtt client.
-#define         PASSWORD                    "xxxx"
+#define         PASSWORD                    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
 
 // The connection type is TCP, TLS or MUTUAL_TLS.
-#define         CONNECTION_TYPE              "TCP"
+#define         CONNECTION_TYPE              "TLS"
 
 //The following certificate and key should be set if CONNECTION_TYPE set to 'MUTUAL_TLS'.
 static char * client_cert = "-----BEGIN CERTIFICATE-----\r\n"
@@ -48,7 +49,8 @@
 static const char* TOPIC_NAME_A = "msgA";
 static const char* TOPIC_NAME_B = "msgB";
 
-static const char* QosToString(QOS_VALUE qosValue)
+
+static const char*  ICACHE_FLASH_ATTR QosToString(QOS_VALUE qosValue)
 {
     switch (qosValue)
     {
@@ -60,12 +62,12 @@
     return "";
 }
 
-void on_recv_callback(MQTT_MESSAGE_HANDLE msgHandle, void* context)
+void  ICACHE_FLASH_ATTR on_recv_callback(MQTT_MESSAGE_HANDLE msgHandle, void* context)
 {
     const APP_PAYLOAD* appMsg = mqttmessage_getApplicationMsg(msgHandle);
     IOTHUB_MQTT_CLIENT_HANDLE clientHandle = (IOTHUB_MQTT_CLIENT_HANDLE)context;
 
-    (void)printf("Incoming Msg: Packet Id: %d\r\nQOS: %s\r\nTopic Name: %s\r\nIs Retained: %s\r\nIs Duplicate: %s\r\nApp Msg: ", mqttmessage_getPacketId(msgHandle),
+    printf("Incoming Msg: Packet Id: %d\r\nQOS: %s\r\nTopic Name: %s\r\nIs Retained: %s\r\nIs Duplicate: %s\r\nApp Msg: ", mqttmessage_getPacketId(msgHandle),
                  QosToString(mqttmessage_getQosType(msgHandle) ),
                  mqttmessage_getTopicName(msgHandle),
                  mqttmessage_getIsRetained(msgHandle) ? "true" : "fale",
@@ -73,20 +75,21 @@
     );
 
     bool isValidUtf8 = utf8_checker_is_valid_utf8((unsigned char *)appMsg->message, appMsg->length);
+    size_t index;
     printf("content is valid UTF8:%s message length:%d\r\n", isValidUtf8? "true": "false", (int)appMsg->length);
-    for (size_t index = 0; index < appMsg->length; index++)
+    for (index = 0; index < appMsg->length; index++)
     {
         if (isValidUtf8)
         {
-            (void)printf("%c", appMsg->message[index]);
+            printf("%c", appMsg->message[index]);
         }
         else
         {
-            (void)printf("0x%x", appMsg->message[index]);
+            printf("0x%x", appMsg->message[index]);
         }
     }
 
-    (void)printf("\r\n");
+    printf("\r\n");
 
     // when receive message is "stop", call destroy method to exit
     // trigger stop by send a message to topic "msgA" and payload with "stop"
@@ -96,7 +99,7 @@
     }
 }
 
-int pub_least_ack_process(MQTT_PUB_STATUS_TYPE status, void* context)
+int  ICACHE_FLASH_ATTR pub_least_ack_process(MQTT_PUB_STATUS_TYPE status, void* context)
 {
     IOTHUB_MQTT_CLIENT_HANDLE clientHandle = (IOTHUB_MQTT_CLIENT_HANDLE)context;
 
@@ -118,7 +121,7 @@
     return 0;
 }
 
-int pub_most_once_process(MQTT_PUB_STATUS_TYPE status, void* context)
+int ICACHE_FLASH_ATTR  pub_most_once_process(MQTT_PUB_STATUS_TYPE status, void* context)
 {
     printf("call publish at most once handle\r\n");
 
@@ -140,9 +143,11 @@
     return 0;
 }
 
-static int processSubAckFunction(QOS_VALUE* qosReturn, size_t qosCount, void *context) {
+static int ICACHE_FLASH_ATTR  processSubAckFunction(QOS_VALUE* qosReturn, size_t qosCount, void *context) {
+    int i;
+
     printf("receive suback from hub server\r\n");
-    for (int i =0; i< qosCount; ++i) {
+    for (i =0; i< qosCount; ++i) {
         printf("qos return: %d\r\n", qosReturn[i]);
     }
 
@@ -152,132 +157,189 @@
     return 0;
 }
 
-int iothub_mqtt_client_run(void)
+
+
+IOTHUB_MQTT_CLIENT_HANDLE g_clientHandle;
+TICK_COUNTER_HANDLE g_tickCounterHandle;
+os_timer_t heart_beat_tmr;
+const char* publishData = "publish message to topic /china/sh.";
+SUBSCRIBE_PAYLOAD *g_subscribe;
+int g_sub_n;
+
+void pub_tmrt_func(void *arg)
 {
-    if (platform_init() != 0)
-    {
-        (void)printf("platform_init failed\r\n");
-        return __FAILURE__;
-    }
-    else
-    {
-        MQTT_CLIENT_OPTIONS options = { 0 };
-        options.clientId = "iotclient2017";
-        options.willMessage = NULL;
-        options.willTopic = NULL;
-        options.username = USERNAME;
-        options.password = PASSWORD;
-        options.keepAliveInterval = 10;
-        options.useCleanSession = true;
-        options.qualityOfServiceValue = DELIVER_AT_MOST_ONCE;
+    int result;
 
-        const char *endpoint = ENDPOINT;
+    printf("5s sending pub!!\n");
+    publish_mqtt_message(g_clientHandle, "/china/sh", DELIVER_AT_LEAST_ONCE, (const uint8_t*)publishData,
+                                        strlen(publishData), pub_least_ack_process , g_clientHandle);
+}
 
-        MQTT_CONNECTION_TYPE type;
-        if (strcmp(CONNECTION_TYPE, "TCP") == 0)
-        {
-            type = MQTT_CONNECTION_TCP;
-        }
-        else if (strcmp(CONNECTION_TYPE, "TLS") == 0)
-        {
-             type = MQTT_CONNECTION_TLS;
-        }
-        else if (strcmp(CONNECTION_TYPE, "MUTUAL_TLS") == 0)
-        {
-             type = MQTT_CONNECTION_MUTUAL_TLS;
-        }
 
+void app_main()
+{
+    printf("hello world!\n");
+
+
+
+#if 1
+    tickcounter_ms_t currentTime;
+    int result;
+
+    printf("mqtt client connect ok! prepare to sub topic!\n");
+    SUBSCRIBE_PAYLOAD subscribe[2];
+    subscribe[0].subscribeTopic = TOPIC_NAME_A;
+    subscribe[0].qosReturn = DELIVER_AT_MOST_ONCE;
+    subscribe[1].subscribeTopic = TOPIC_NAME_B;
+    subscribe[1].qosReturn = DELIVER_AT_MOST_ONCE;
+
+    g_subscribe = subscribe;
+    g_sub_n = 2;
+    int flag = 0;
+    subscribe_mqtt_topics(g_clientHandle, subscribe, 2, processSubAckFunction, &flag);
 
+    printf("prepare to pub!\n");
+    result = publish_mqtt_message(g_clientHandle, "/china/sh", DELIVER_EXACTLY_ONCE, (const uint8_t*)publishData,
+                            strlen(publishData), pub_least_ack_process , g_clientHandle);
 
-        IOTHUB_CLIENT_RETRY_POLICY retryPolicy = IOTHUB_CLIENT_RETRY_EXPONENTIAL_BACKOFF;
+    if (result == __FAILURE__) {
+        printf("Does not support DELIVER_EXACTLY_ONCE\r\n");
+    }
+
+    result = publish_mqtt_message(g_clientHandle, "/china/bj", DELIVER_AT_MOST_ONCE, (const uint8_t*)publishData,
+                            strlen(publishData), pub_most_once_process , g_clientHandle);
+
+    result = publish_mqtt_message(g_clientHandle, "/china/bj", DELIVER_AT_MOST_ONCE, (const uint8_t*)publishData,
+                                    strlen(publishData), NULL , NULL);
+
+    result = publish_mqtt_message(g_clientHandle, "/china/sh", DELIVER_AT_LEAST_ONCE, (const uint8_t*)publishData,
+                                    strlen(publishData), pub_least_ack_process , g_clientHandle);
 
-        size_t retryTimeoutLimitInSeconds = 1000;
+    // send a publish message every 5 seconds
+    static os_timer_t pub_tmr;
+    os_timer_disarm(&pub_tmr);
+    os_timer_setfn(&pub_tmr, (os_timer_func_t *)pub_tmrt_func, NULL);
+    os_timer_arm(&pub_tmr, 5000, 1);
+#endif
+
+}
 
-        IOTHUB_MQTT_CLIENT_HANDLE clientHandle = initialize_mqtt_client_handle(&options, endpoint, type, on_recv_callback,
-                                                                               retryPolicy, retryTimeoutLimitInSeconds);
 
-        if (strcmp(CONNECTION_TYPE, "MUTUAL_TLS") == 0)
+void heart_beat_func(void *arg)
+{
+    tickcounter_ms_t cur_tick;
+    bool needSubscribeTopic = false;
+    SUBSCRIBE_PAYLOAD *subscribe = (SUBSCRIBE_PAYLOAD *)arg;
+    int result;
+
+    // print some status info
+    tickcounter_get_current_ms(g_tickCounterHandle, &cur_tick);
+    printf("***\n");
+    printf("ts(s)  : %d\n", cur_tick / 1000);
+    printf("mem    : %d\n", system_get_free_heap_size());
+    printf("***\n");
+
+    //called disconnect
+    if (g_clientHandle->isDestroyCalled || g_clientHandle->isDisconnectCalled) {
+        iothub_mqtt_destroy(g_clientHandle);
+        os_timer_disarm(&heart_beat_tmr);
+        return;
+    } 
+    
+    //if connection lost
+    if (g_subscribe) {
+        if (g_clientHandle->isConnectionLost && !needSubscribeTopic)
         {
-            set_client_cert(clientHandle, client_cert, client_key);
+            needSubscribeTopic = true;
         }
-
-        if (clientHandle == NULL)
+        if (g_clientHandle->mqttClientStatus == MQTT_CLIENT_STATUS_CONNECTED && needSubscribeTopic)
         {
-            printf("Error: fail to initialize IOTHUB_MQTT_CLIENT_HANDLE");
-            return 0;
+            needSubscribeTopic = false;
+            subscribe_mqtt_topics(g_clientHandle, g_subscribe, g_sub_n * sizeof(SUBSCRIBE_PAYLOAD), NULL, NULL);
         }
+    }
 
-        int result = iothub_mqtt_doconnect(clientHandle, 60);
+    // else, do heatbeat work
+    iothub_mqtt_dowork(g_clientHandle);
 
-        if (result == __FAILURE__)
-        {
-            printf("fail to establish connection with server");
-            return __FAILURE__;
-        }
+}
 
-        SUBSCRIBE_PAYLOAD subscribe[2];
-        subscribe[0].subscribeTopic = TOPIC_NAME_A;
-        subscribe[0].qosReturn = DELIVER_AT_MOST_ONCE;
-        subscribe[1].subscribeTopic = TOPIC_NAME_B;
-        subscribe[1].qosReturn = DELIVER_AT_MOST_ONCE;
-
-        int flag = 0;
-        subscribe_mqtt_topics(clientHandle, subscribe, sizeof(subscribe)/sizeof(SUBSCRIBE_PAYLOAD), processSubAckFunction, &flag);
 
-        const char* publishData = "publish message to topic /china/sh.";
+void doconnect_ok_func(int result)
+{
+    printf("==> doconnect_ok_func in app\n");
 
-        result = publish_mqtt_message(clientHandle, "/china/sh", DELIVER_EXACTLY_ONCE, (const uint8_t*)publishData,
-                             strlen(publishData), pub_least_ack_process , clientHandle);
+    printf("keep heart beating.....\n");
+    os_timer_disarm(&heart_beat_tmr);
+    os_timer_setfn(&heart_beat_tmr, (os_timer_func_t *)heart_beat_func, NULL);
+    os_timer_arm(&heart_beat_tmr, 1000, 1);
 
-        if (result == __FAILURE__) {
-            printf("Does not support DELIVER_EXACTLY_ONCE\r\n");
-        }
+    // your app main logic
+    app_main();
+}
 
-        result = publish_mqtt_message(clientHandle, "/china/bj", DELIVER_AT_MOST_ONCE, (const uint8_t*)publishData,
-                             strlen(publishData), pub_most_once_process , clientHandle);
+void main_logic()
+{
+    printf("==> main_logic\n");
+    MQTT_CLIENT_OPTIONS options = { 0 };
+    options.clientId = "iotclient2017";
+    options.willMessage = NULL;
+    options.willTopic = NULL;
+    options.username = USERNAME;
+    options.password = PASSWORD;
+    options.keepAliveInterval = 10;
+    options.useCleanSession = true;
+    options.qualityOfServiceValue = DELIVER_AT_MOST_ONCE;
 
-        result = publish_mqtt_message(clientHandle, "/china/bj", DELIVER_AT_MOST_ONCE, (const uint8_t*)publishData,
-                                      strlen(publishData), NULL , NULL);
+    const char *endpoint = ENDPOINT;
 
-        result = publish_mqtt_message(clientHandle, "/china/sh", DELIVER_AT_LEAST_ONCE, (const uint8_t*)publishData,
-                                      strlen(publishData), pub_least_ack_process , clientHandle);
+    MQTT_CONNECTION_TYPE type;
+    if (strcmp(CONNECTION_TYPE, "TCP") == 0)
+    {
+        type = MQTT_CONNECTION_TCP;
+    }
+    else if (strcmp(CONNECTION_TYPE, "TLS") == 0)
+    {
+            type = MQTT_CONNECTION_TLS;
+    }
+    else if (strcmp(CONNECTION_TYPE, "MUTUAL_TLS") == 0)
+    {
+            type = MQTT_CONNECTION_MUTUAL_TLS;
+    }
 
-        TICK_COUNTER_HANDLE tickCounterHandle = tickcounter_create();
-        tickcounter_ms_t currentTime, lastSendTime;
-        tickcounter_get_current_ms(tickCounterHandle, &lastSendTime);
-        bool needSubscribeTopic = false;
-        do
-        {
-            iothub_mqtt_dowork(clientHandle);
-            tickcounter_get_current_ms(tickCounterHandle, &currentTime);
-            if (clientHandle->isConnectionLost && !needSubscribeTopic)
-            {
-                needSubscribeTopic = true;
-            }
-
-            if (clientHandle->mqttClientStatus == MQTT_CLIENT_STATUS_CONNECTED && needSubscribeTopic)
-            {
-                needSubscribeTopic = false;
-                subscribe_mqtt_topics(clientHandle, subscribe, sizeof(subscribe)/sizeof(SUBSCRIBE_PAYLOAD), NULL, NULL);
-            }
-
-            // send a publish message every 5 seconds
-            if (!clientHandle->isConnectionLost && (currentTime - lastSendTime) / 1000 > 5)
-            {
-                result = publish_mqtt_message(clientHandle, "/china/sh", DELIVER_AT_LEAST_ONCE, (const uint8_t*)publishData,
-                                              strlen(publishData), pub_least_ack_process , clientHandle);
-                lastSendTime = currentTime;
-            }
-            ThreadAPI_Sleep(10);
-        } while (!clientHandle->isDestroyCalled && !clientHandle->isDisconnectCalled);
-
-        iothub_mqtt_destroy(clientHandle);
-        tickcounter_destroy(tickCounterHandle);
-        return 0;
+    IOTHUB_CLIENT_RETRY_POLICY retryPolicy = IOTHUB_CLIENT_RETRY_EXPONENTIAL_BACKOFF;
+
+    size_t retryTimeoutLimitInSeconds = 1000;
+
+    g_clientHandle =  initialize_mqtt_client_handle(&options, endpoint, type, on_recv_callback,
+                                                                            retryPolicy, retryTimeoutLimitInSeconds);
+    if (strcmp(CONNECTION_TYPE, "MUTUAL_TLS") == 0)
+    {
+        set_client_cert(g_clientHandle, client_cert, client_key);
+    }
+
+    if (g_clientHandle == NULL)
+    {
+        printf("Error: fail to initialize IOTHUB_MQTT_CLIENT_HANDLE");
+        return ;
     }
+    iothub_mqtt_doconnect(g_clientHandle, 60, doconnect_ok_func);
+
+}
+
+int iothub_mqtt_client_run(void)
+{
+    printf("==> iothub_mqtt_client_run\n");
+    if (platform_init(main_logic) != 0)
+    {
+        printf("platform_init failed\r\n");
+        return __FAILURE__;
+    }
+    g_tickCounterHandle = tickcounter_create();
 
 #ifdef _CRT_DBG_MAP_ALLOC
     _CrtDumpMemoryLeaks();
 #endif
+    return 0;
 }
 
diff -uNr src/lock_pthreads.c src_ok/lock_pthreads.c
--- src/lock_pthreads.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/lock_pthreads.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,111 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-#include <stdlib.h>
-#include <pthread.h>
-#include "azure_c_shared_utility/lock.h"
-#include "azure_c_shared_utility/xlogging.h"
-
-LOCK_HANDLE Lock_Init(void)
-{
-    /* Codes_SRS_LOCK_10_002: [Lock_Init on success shall return a valid lock handle which should be a non NULL value] */
-    pthread_mutex_t* result = (pthread_mutex_t*)malloc(sizeof(pthread_mutex_t));
-    if (result == NULL)
-    {
-        LogError("malloc failed.");
-    }
-    else
-	{
-		if (pthread_mutex_init(result, NULL) != 0)
-		{
-            /* Codes_SRS_LOCK_10_003: [Lock_Init on error shall return NULL ] */
-			LogError("pthread_mutex_init failed.");
-            free(result);
-            result = NULL;
-		}
-	}
-	
-	return (LOCK_HANDLE)result;
-}
-
-LOCK_RESULT Lock(LOCK_HANDLE handle)
-{
-	LOCK_RESULT result;
-	if (handle == NULL)
-	{
-        /* Codes_SRS_LOCK_10_007: [Lock on NULL handle passed returns LOCK_ERROR] */
-        LogError("Invalid argument; handle is NULL.");
-        result = LOCK_ERROR;
-    }
-	else
-	{
-		if (pthread_mutex_lock((pthread_mutex_t*)handle) == 0)
-		{
-            /* Codes_SRS_LOCK_10_005: [Lock on success shall return LOCK_OK] */
-            result = LOCK_OK;
-		}
-		else
-		{
-            /* Codes_SRS_LOCK_10_006: [Lock on error shall return LOCK_ERROR] */
-            LogError("pthread_mutex_lock failed.");
-            result = LOCK_ERROR;
-		}
-	}
-
-	return result;
-}
-
-LOCK_RESULT Unlock(LOCK_HANDLE handle)
-{
-	LOCK_RESULT result;
-	if (handle == NULL)
-	{
-        /* Codes_SRS_LOCK_10_007: [Unlock on NULL handle passed returns LOCK_ERROR] */
-        LogError("Invalid argument; handle is NULL.");
-        result = LOCK_ERROR;
-    }
-	else
-	{
-		if (pthread_mutex_unlock((pthread_mutex_t*)handle) == 0)
-		{
-            /* Codes_SRS_LOCK_10_009: [Unlock on success shall return LOCK_OK] */
-            result = LOCK_OK;
-		}
-		else
-		{
-            /* Codes_SRS_LOCK_10_010: [Unlock on error shall return LOCK_ERROR] */
-            LogError("pthread_mutex_unlock failed.");
-            result = LOCK_ERROR;
-		}
-	}
-
-	return result;
-}
-
-LOCK_RESULT Lock_Deinit(LOCK_HANDLE handle)
-{
-	LOCK_RESULT result;
-	if (NULL == handle)
-	{
-        /* Codes_SRS_LOCK_10_007: [Lock_Deinit on NULL handle passed returns LOCK_ERROR] */
-        LogError("Invalid argument; handle is NULL.");
-        result = LOCK_ERROR;
-    }
-	else
-	{
-        /* Codes_SRS_LOCK_10_012: [Lock_Deinit frees the memory pointed by handle] */
-        if(pthread_mutex_destroy((pthread_mutex_t*)handle) == 0)
-		{
-			free(handle);
-			handle = NULL;
-            result = LOCK_OK;
-        }
-		else
-		{
-            LogError("pthread_mutex_destroy failed;");
-			result = LOCK_ERROR;
-		}
-	}
-	
-	return result;
-}
diff -uNr src/map.c src_ok/map.c
--- src/map.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/map.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,12 +1,11 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdlib.h>
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/map.h"
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/xlogging.h"
-#include "azure_c_shared_utility/strings.h"
+//#include <stdlib.h>
+#include "esp_types.h"
+#include "map.h"
+#include "xlogging.h"
+#include "strings.h"
 
 DEFINE_ENUM_STRINGS(MAP_RESULT, MAP_RESULT_VALUES);
 
@@ -18,9 +17,9 @@
     MAP_FILTER_CALLBACK mapFilterCallback;
 }MAP_HANDLE_DATA;
 
-#define LOG_MAP_ERROR LogError("result = %s", ENUM_TO_STRING(MAP_RESULT, result));
+#define LOG_MAP_ERROR printf("result = %s", ENUM_TO_STRING(MAP_RESULT, result));
 
-MAP_HANDLE Map_Create(MAP_FILTER_CALLBACK mapFilterFunc)
+MAP_HANDLE  ICACHE_FLASH_ATTR Map_Create(MAP_FILTER_CALLBACK mapFilterFunc)
 {
     /*Codes_SRS_MAP_02_001: [Map_Create shall create a new, empty map.]*/
     MAP_HANDLE_DATA* result = (MAP_HANDLE_DATA*)malloc(sizeof(MAP_HANDLE_DATA));
@@ -36,7 +35,7 @@
     return (MAP_HANDLE)result;
 }
 
-void Map_Destroy(MAP_HANDLE handle)
+void  ICACHE_FLASH_ATTR Map_Destroy(MAP_HANDLE handle)
 {
     /*Codes_SRS_MAP_02_005: [If parameter handle is NULL then Map_Destroy shall take no action.] */
     if (handle != NULL)
@@ -58,7 +57,7 @@
 
 /*makes a copy of a vector of const char*, having size "size". source cannot be NULL*/
 /*returns NULL if it fails*/
-static char** Map_CloneVector(const char*const * source, size_t count)
+static char**  ICACHE_FLASH_ATTR Map_CloneVector(const char*const * source, size_t count)
 {
     char** result;
     result = (char**)malloc(count *sizeof(char*));
@@ -96,14 +95,14 @@
 }
 
 /*Codes_SRS_MAP_02_039: [Map_Clone shall make a copy of the map indicated by parameter handle and return a non-NULL handle to it.]*/
-MAP_HANDLE Map_Clone(MAP_HANDLE handle)
+MAP_HANDLE  ICACHE_FLASH_ATTR Map_Clone(MAP_HANDLE handle)
 {
     MAP_HANDLE_DATA* result;
     if (handle == NULL)
     {
         /*Codes_SRS_MAP_02_038: [Map_Clone returns NULL if parameter handle is NULL.]*/
         result = NULL;
-        LogError("invalid arg to Map_Clone (NULL)");
+        printf("invalid arg to Map_Clone (NULL)");
     }
     else
     {
@@ -113,7 +112,7 @@
         {
             /*Codes_SRS_MAP_02_047: [If during cloning, any operation fails, then Map_Clone shall return NULL.] */
             /*do nothing, proceed to return it, this is an error case*/
-            LogError("unable to malloc");
+            printf("unable to malloc");
         }
         else
         {
@@ -131,7 +130,7 @@
                 if( (result->keys = Map_CloneVector((const char* const*)handleData->keys, handleData->count))==NULL)
                 {
                     /*Codes_SRS_MAP_02_047: [If during cloning, any operation fails, then Map_Clone shall return NULL.] */
-                    LogError("unable to clone keys");
+                    printf("unable to clone keys");
                     free(result);
                     result = NULL;
                 }
@@ -139,7 +138,7 @@
                 {
                     size_t i;
                     /*Codes_SRS_MAP_02_047: [If during cloning, any operation fails, then Map_Clone shall return NULL.] */
-                    LogError("unable to clone values");
+                    printf("unable to clone values");
                     for (i = 0; i < result->count; i++)
                     {
                         free(result->keys[i]); 
@@ -158,13 +157,13 @@
     return (MAP_HANDLE)result;
 }
 
-static int Map_IncreaseStorageKeysValues(MAP_HANDLE_DATA* handleData)
+static int  ICACHE_FLASH_ATTR Map_IncreaseStorageKeysValues(MAP_HANDLE_DATA* handleData)
 {
     int result;
     char** newKeys = (char**)realloc(handleData->keys, (handleData->count + 1) * sizeof(char*));
     if (newKeys == NULL)
     {
-        LogError("realloc error");
+        printf("realloc error");
         result = __FAILURE__;
     }
     else
@@ -175,7 +174,7 @@
         newValues = (char**)realloc(handleData->values, (handleData->count + 1) * sizeof(char*));
         if (newValues == NULL)
         {
-            LogError("realloc error");
+            printf("realloc error");
             if (handleData->count == 0) /*avoiding an implementation defined behavior */
             {
                 free(handleData->keys);
@@ -186,7 +185,7 @@
                 char** undoneKeys = (char**)realloc(handleData->keys, (handleData->count) * sizeof(char*));
                 if (undoneKeys == NULL)
                 {
-                    LogError("CATASTROPHIC error, unable to undo through realloc to a smaller size");
+                    printf("CATASTROPHIC error, unable to undo through realloc to a smaller size");
                 }
                 else
                 {
@@ -206,7 +205,7 @@
     return result;
 }
 
-static void Map_DecreaseStorageKeysValues(MAP_HANDLE_DATA* handleData)
+static void ICACHE_FLASH_ATTR  Map_DecreaseStorageKeysValues(MAP_HANDLE_DATA* handleData)
 {
     if (handleData->count == 1)
     {
@@ -224,7 +223,7 @@
         char** undoneKeys = (char**)realloc(handleData->keys, sizeof(char*)* (handleData->count - 1)); 
         if (undoneKeys == NULL)
         {
-            LogError("CATASTROPHIC error, unable to undo through realloc to a smaller size");
+            printf("CATASTROPHIC error, unable to undo through realloc to a smaller size");
         }
         else
         {
@@ -234,7 +233,7 @@
         undoneValues = (char**)realloc(handleData->values, sizeof(char*)* (handleData->count - 1));
         if (undoneValues == NULL)
         {
-            LogError("CATASTROPHIC error, unable to undo through realloc to a smaller size");
+            printf("CATASTROPHIC error, unable to undo through realloc to a smaller size");
         }
         else
         {
@@ -245,7 +244,7 @@
     }
 }
 
-static char** findKey(MAP_HANDLE_DATA* handleData, const char* key)
+static char**  ICACHE_FLASH_ATTR findKey(MAP_HANDLE_DATA* handleData, const char* key)
 {
     char** result;
     if (handleData->keys == NULL)
@@ -268,7 +267,7 @@
     return result;
 }
 
-static char** findValue(MAP_HANDLE_DATA* handleData, const char* value)
+static char** ICACHE_FLASH_ATTR  findValue(MAP_HANDLE_DATA* handleData, const char* value)
 {
     char** result;
     if (handleData->values == NULL)
@@ -291,7 +290,7 @@
     return result;
 }
 
-static int insertNewKeyValue(MAP_HANDLE_DATA* handleData, const char* key, const char* value)
+static int  ICACHE_FLASH_ATTR insertNewKeyValue(MAP_HANDLE_DATA* handleData, const char* key, const char* value)
 {
     int result;
     if (Map_IncreaseStorageKeysValues(handleData) != 0) /*this increases handleData->count*/
@@ -303,7 +302,7 @@
         if (mallocAndStrcpy_s(&(handleData->keys[handleData->count - 1]), key) != 0)
         {
             Map_DecreaseStorageKeysValues(handleData);
-            LogError("unable to mallocAndStrcpy_s");
+            printf("unable to mallocAndStrcpy_s");
             result = __FAILURE__;
         }
         else
@@ -312,7 +311,7 @@
             {
                 free(handleData->keys[handleData->count - 1]);
                 Map_DecreaseStorageKeysValues(handleData);
-                LogError("unable to mallocAndStrcpy_s");
+                printf("unable to mallocAndStrcpy_s");
                 result = __FAILURE__;
             }
             else
@@ -324,7 +323,7 @@
     return result; 
 }
 
-MAP_RESULT Map_Add(MAP_HANDLE handle, const char* key, const char* value)
+MAP_RESULT ICACHE_FLASH_ATTR  Map_Add(MAP_HANDLE handle, const char* key, const char* value)
 {
     MAP_RESULT result;
     /*Codes_SRS_MAP_02_006: [If parameter handle is NULL then Map_Add shall return MAP_INVALID_ARG.] */
@@ -374,7 +373,7 @@
     return result;
 }
 
-MAP_RESULT Map_AddOrUpdate(MAP_HANDLE handle, const char* key, const char* value)
+MAP_RESULT  ICACHE_FLASH_ATTR Map_AddOrUpdate(MAP_HANDLE handle, const char* key, const char* value)
 {
     MAP_RESULT result;
     /*Codes_SRS_MAP_02_013: [If parameter handle is NULL then Map_AddOrUpdate shall return MAP_INVALID_ARG.]*/
@@ -439,7 +438,7 @@
     return result;
 }
 
-MAP_RESULT Map_Delete(MAP_HANDLE handle, const char* key)
+MAP_RESULT  ICACHE_FLASH_ATTR Map_Delete(MAP_HANDLE handle, const char* key)
 {
     MAP_RESULT result;
     /*Codes_SRS_MAP_02_020: [If parameter handle is NULL then Map_Delete shall return MAP_INVALIDARG.]*/
@@ -477,7 +476,7 @@
     return result;
 }
 
-MAP_RESULT Map_ContainsKey(MAP_HANDLE handle, const char* key, bool* keyExists)
+MAP_RESULT ICACHE_FLASH_ATTR  Map_ContainsKey(MAP_HANDLE handle, const char* key, bool* keyExists)
 {
     MAP_RESULT result;
     /*Codes_SRS_MAP_02_024: [If parameter handle, key or keyExists are NULL then Map_ContainsKey shall return MAP_INVALIDARG.]*/
@@ -501,7 +500,7 @@
     return result;
 }
 
-MAP_RESULT Map_ContainsValue(MAP_HANDLE handle, const char* value, bool* valueExists)
+MAP_RESULT ICACHE_FLASH_ATTR  Map_ContainsValue(MAP_HANDLE handle, const char* value, bool* valueExists)
 {
     MAP_RESULT result;
     /*Codes_SRS_MAP_02_027: [If parameter handle, value or valueExists is NULL then Map_ContainsValue shall return MAP_INVALIDARG.] */
@@ -525,7 +524,7 @@
     return result;
 }
 
-const char* Map_GetValueFromKey(MAP_HANDLE handle, const char* key)
+const char*  ICACHE_FLASH_ATTR  Map_GetValueFromKey(MAP_HANDLE handle, const char* key)
 {
     const char* result;
     /*Codes_SRS_MAP_02_040: [If parameter handle or key is NULL then Map_GetValueFromKey returns NULL.]*/
@@ -535,7 +534,7 @@
         )
     {
         result = NULL;
-        LogError("invalid parameter to Map_GetValueFromKey");
+        printf("invalid parameter to Map_GetValueFromKey");
     }
     else
     {
@@ -556,7 +555,7 @@
     return result;
 }
 
-MAP_RESULT Map_GetInternals(MAP_HANDLE handle, const char*const** keys, const char*const** values, size_t* count)
+MAP_RESULT  ICACHE_FLASH_ATTR Map_GetInternals(MAP_HANDLE handle, const char*const** keys, const char*const** values, size_t* count)
 {
     MAP_RESULT result;
     /*Codes_SRS_MAP_02_046: [If parameter handle, keys, values or count is NULL then Map_GetInternals shall return MAP_INVALIDARG.] */
@@ -584,14 +583,14 @@
     return result;
 }
 
-STRING_HANDLE Map_ToJSON(MAP_HANDLE handle)
+STRING_HANDLE ICACHE_FLASH_ATTR  Map_ToJSON(MAP_HANDLE handle)
 {
     STRING_HANDLE result;
     /*Codes_SRS_MAP_02_052: [If parameter handle is NULL then Map_ToJSON shall return NULL.] */
     if (handle == NULL)
     {
         result = NULL;
-        LogError("invalid arg (NULL)");
+        printf("invalid arg (NULL)");
     }
     else
     {
@@ -599,7 +598,7 @@
         result = STRING_construct("{");
         if (result == NULL)
         {
-            LogError("STRING_construct failed");
+            printf("STRING_construct failed");
         }
         else
         {
@@ -614,7 +613,7 @@
                 STRING_HANDLE key = STRING_new_JSON(handleData->keys[i]);
                 if (key == NULL)
                 {
-                    LogError("STRING_new_JSON failed");
+                    printf("STRING_new_JSON failed");
                     STRING_delete(result);
                     result = NULL;
                     breakFor = true;
@@ -624,7 +623,7 @@
                     STRING_HANDLE value = STRING_new_JSON(handleData->values[i]);
                     if (value == NULL)
                     {
-                        LogError("STRING_new_JSON failed");
+                        printf("STRING_new_JSON failed");
                         STRING_delete(result);
                         result = NULL;
                         breakFor = true;
@@ -638,7 +637,7 @@
                             (STRING_concat_with_STRING(result, value) == 0)
                             ))
                         {
-                            LogError("failed to build the JSON");
+                            printf("failed to build the JSON");
                             STRING_delete(result);
                             result = NULL;
                             breakFor = true;
@@ -655,13 +654,13 @@
                 
             if (breakFor)
             {
-                LogError("error happened during JSON string builder");
+                printf("error happened during JSON string builder");
             }
             else
             {
                 if (STRING_concat(result, "}") != 0)
                 {
-                    LogError("failed to build the JSON");
+                    printf("failed to build the JSON");
                     STRING_delete(result);
                     result = NULL;
                 }
diff -uNr src/mqtt_client.c src_ok/mqtt_client.c
--- src/mqtt_client.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/mqtt_client.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,20 +1,17 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdlib.h>
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/platform.h"
-#include "azure_c_shared_utility/tickcounter.h"
-#include "azure_c_shared_utility/crt_abstractions.h"
-#include "azure_c_shared_utility/xlogging.h"
-#include "azure_c_shared_utility/strings.h"
-#include "azure_c_shared_utility/agenttime.h"
-#include "azure_c_shared_utility/threadapi.h"
-
-#include "azure_umqtt_c/mqtt_client.h"
-#include "azure_umqtt_c/mqtt_codec.h"
-#include <inttypes.h>
+#include "esp_types.h"
+#include "inc/platform.h"
+#include "tickcounter.h"
+#include "crt_abstractions.h"
+#include "xlogging.h"
+#include "strings.h"
+#include "agenttime.h"
+#include "threadapi.h"
+
+#include "mqtt_client.h"
+#include "mqtt_codec.h"
 
 #define VARIABLE_HEADER_OFFSET          2
 #define RETAIN_FLAG_MASK                0x1
@@ -56,7 +53,7 @@
     uint16_t maxPingRespTime;
 } MQTT_CLIENT;
 
-static void on_connection_closed(void* context)
+static void  ICACHE_FLASH_ATTR on_connection_closed(void* context)
 {
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)context;
     if (mqtt_client != NULL)
@@ -70,7 +67,7 @@
     }
 }
 
-static void close_connection(MQTT_CLIENT* mqtt_client)
+static void ICACHE_FLASH_ATTR  close_connection(MQTT_CLIENT* mqtt_client)
 {
     if (mqtt_client->socketConnected)
     {
@@ -95,7 +92,7 @@
     }
 }
 
-static void set_error_callback(MQTT_CLIENT* mqtt_client, MQTT_CLIENT_EVENT_ERROR error_type)
+static void  ICACHE_FLASH_ATTR set_error_callback(MQTT_CLIENT* mqtt_client, MQTT_CLIENT_EVENT_ERROR error_type)
 {
     if (mqtt_client->fnOnErrorCallBack)
     {
@@ -104,7 +101,7 @@
     close_connection(mqtt_client);
 }
 
-static STRING_HANDLE construct_trace_log_handle(MQTT_CLIENT* mqtt_client)
+static STRING_HANDLE  ICACHE_FLASH_ATTR construct_trace_log_handle(MQTT_CLIENT* mqtt_client)
 {
     STRING_HANDLE trace_log;
     if (mqtt_client->logTrace)
@@ -118,7 +115,7 @@
     return trace_log;
 }
 
-static uint16_t byteutil_read_uint16(uint8_t** buffer, size_t len)
+static uint16_t  ICACHE_FLASH_ATTR byteutil_read_uint16(uint8_t** buffer, size_t len)
 {
     uint16_t result = 0;
     if (buffer != NULL && *buffer != NULL && len >= 2)
@@ -128,12 +125,12 @@
     }
     else
     {
-        LOG(AZ_LOG_ERROR, LOG_LINE, "byteutil_read_uint16 == NULL or less than 2");
+        printf("byteutil_read_uint16 == NULL or less than 2");
     }
     return result;
 }
 
-static char* byteutil_readUTF(uint8_t** buffer, size_t* byteLen)
+static char*  ICACHE_FLASH_ATTR byteutil_readUTF(uint8_t** buffer, size_t* byteLen)
 {
     char* result = NULL;
     if (buffer != NULL)
@@ -157,12 +154,12 @@
     }
     else
     {
-        LOG(AZ_LOG_ERROR, LOG_LINE, "readByte buffer == NULL.");
+        printf("readByte buffer == NULL.");
     }
     return result;
 }
 
-static uint8_t byteutil_readByte(uint8_t** buffer)
+static uint8_t  ICACHE_FLASH_ATTR byteutil_readByte(uint8_t** buffer)
 {
     uint8_t result = 0;
     if (buffer != NULL)
@@ -172,12 +169,12 @@
     }
     else
     {
-        LOG(AZ_LOG_ERROR, LOG_LINE, "readByte buffer == NULL.");
+        printf("readByte buffer == NULL.");
     }
     return result;
 }
 
-static void sendComplete(void* context, IO_SEND_RESULT send_result)
+static void  ICACHE_FLASH_ATTR sendComplete(void* context, IO_SEND_RESULT send_result)
 {
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)context;
     if (mqtt_client != NULL)
@@ -197,17 +194,17 @@
         }
         else if (send_result == IO_SEND_ERROR)
         {
-            LOG(AZ_LOG_ERROR, LOG_LINE, "MQTT Send Complete Failure send_result: %d", (int)send_result);
+            printf("MQTT Send Complete Failure send_result: %d", (int)send_result);
             set_error_callback(mqtt_client, MQTT_CLIENT_COMMUNICATION_ERROR);
         }
     }
     else
     {
-        LOG(AZ_LOG_ERROR, LOG_LINE, "MQTT Send Complete Failure with NULL mqtt_client");
+        printf("MQTT Send Complete Failure with NULL mqtt_client");
     }
 }
 
-static const char* retrievePacketType(CONTROL_PACKET_TYPE packet)
+static const char*  ICACHE_FLASH_ATTR retrievePacketType(CONTROL_PACKET_TYPE packet)
 {
     switch (packet&CONNECT_PACKET_MASK)
     {
@@ -230,7 +227,7 @@
             return "UNKNOWN";
     }
 }
-
+#if 0
 static void getLogTime(char* timeResult, size_t len)
 {
     if (timeResult != NULL)
@@ -324,31 +321,34 @@
     }
 }
 
-static int sendPacketItem(MQTT_CLIENT* mqtt_client, const unsigned char* data, size_t length)
+#endif
+static int  ICACHE_FLASH_ATTR sendPacketItem(MQTT_CLIENT* mqtt_client, const unsigned char* data, size_t length)
 {
     int result;
 
     result = xio_send(mqtt_client->xioHandle, (const void*)data, length, sendComplete, mqtt_client);
     if (result != 0)
     {
-        LOG(AZ_LOG_ERROR, LOG_LINE, "%d: Failure sending control packet data", result);
+        printf("%d: Failure sending control packet data", result);
         result = __FAILURE__;
     }
     else
     {
-        logOutgoingRawTrace(mqtt_client, (const uint8_t*)data, length);
+        //logOutgoingRawTrace(mqtt_client, (const uint8_t*)data, length);
     }
 
     return result;
 }
 
-static void onOpenComplete(void* context, IO_OPEN_RESULT open_result)
+static void  ICACHE_FLASH_ATTR onOpenComplete(void* context, IO_OPEN_RESULT open_result)
 {
+    printf("==> onOpenComplete\n");
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)context;
     if (mqtt_client != NULL)
     {
         if (open_result == IO_OPEN_OK && !mqtt_client->socketConnected)
         {
+            printf("prepare conn pkt\n");
             mqtt_client->packetState = CONNECT_TYPE;
             mqtt_client->socketConnected = true;
 
@@ -358,19 +358,20 @@
             BUFFER_HANDLE connPacket = mqtt_codec_connect(&mqtt_client->mqttOptions, trace_log);
             if (connPacket == NULL)
             {
-                LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_codec_connect failed");
+                printf("Error: mqtt_codec_connect failed");
             }
             else
             {
                 size_t size = BUFFER_length(connPacket);
                 /*Codes_SRS_MQTT_CLIENT_07_009: [On success mqtt_client_connect shall send the MQTT CONNECT to the endpoint.]*/
+                printf("send conn pkg...\n");
                 if (sendPacketItem(mqtt_client, BUFFER_u_char(connPacket), size) != 0)
                 {
-                    LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_codec_connect failed");
+                    printf("Error: mqtt_codec_connect failed");
                 }
                 else
                 {
-                    log_outgoing_trace(mqtt_client, trace_log);
+                    //log_outgoing_trace(mqtt_client, trace_log);
                 }
                 BUFFER_delete(connPacket);
             }
@@ -390,12 +391,13 @@
     }
     else
     {
-        LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_client is NULL");
+        printf("Error: mqtt_client is NULL");
     }
 }
 
-static void onBytesReceived(void* context, const unsigned char* buffer, size_t size)
+static void ICACHE_FLASH_ATTR  onBytesReceived(void* context, const unsigned char* buffer, size_t size)
 {
+    printf("==> onBytesReceived   <---- plain data!\n");
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)context;
     if (mqtt_client != NULL)
     {
@@ -406,11 +408,11 @@
     }
     else
     {
-        LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_client is NULL");
+        printf("Error: mqtt_client is NULL");
     }
 }
 
-static void onIoError(void* context)
+static void ICACHE_FLASH_ATTR  onIoError(void* context)
 {
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)context;
     if (mqtt_client != NULL && mqtt_client->fnOperationCallback)
@@ -421,11 +423,11 @@
     }
     else
     {
-        LOG(AZ_LOG_ERROR, LOG_LINE, "Error invalid parameter: mqtt_client: %p", mqtt_client);
+        printf("Error invalid parameter: mqtt_client: %p", mqtt_client);
     }
 }
 
-static void clear_mqtt_options(MQTT_CLIENT* mqtt_client)
+static void  ICACHE_FLASH_ATTR clear_mqtt_options(MQTT_CLIENT* mqtt_client)
 {
     if (mqtt_client->mqttOptions.clientId != NULL)
     {
@@ -458,7 +460,7 @@
     }
 }
 
-static int cloneMqttOptions(MQTT_CLIENT* mqtt_client, const MQTT_CLIENT_OPTIONS* mqttOptions)
+static int ICACHE_FLASH_ATTR  cloneMqttOptions(MQTT_CLIENT* mqtt_client, const MQTT_CLIENT_OPTIONS* mqttOptions)
 {
     int result = 0;
 
@@ -469,7 +471,7 @@
         if (mallocAndStrcpy_s(&clientId, mqttOptions->clientId) != 0)
         {
             result = __FAILURE__;
-            LOG(AZ_LOG_ERROR, LOG_LINE, "mallocAndStrcpy_s clientId");
+            printf("mallocAndStrcpy_s clientId");
         }
         else
         {
@@ -488,7 +490,7 @@
         if (mallocAndStrcpy_s(&willTopic, mqttOptions->willTopic) != 0)
         {
             result = __FAILURE__;
-            LOG(AZ_LOG_ERROR, LOG_LINE, "mallocAndStrcpy_s willTopic");
+            printf("mallocAndStrcpy_s willTopic");
         }
         else
         {
@@ -506,7 +508,7 @@
 
         if (mallocAndStrcpy_s(&willMessage, mqttOptions->willMessage) != 0)
         {
-            LOG(AZ_LOG_ERROR, LOG_LINE, "mallocAndStrcpy_s willMessage");
+            printf("mallocAndStrcpy_s willMessage");
             result = __FAILURE__;
         }
         else
@@ -525,7 +527,7 @@
 
         if (mallocAndStrcpy_s(&username, mqttOptions->username) != 0)
         {
-            LOG(AZ_LOG_ERROR, LOG_LINE, "mallocAndStrcpy_s username");
+            printf("mallocAndStrcpy_s username");
             result = __FAILURE__;
         }
         else
@@ -544,7 +546,7 @@
 
         if (mallocAndStrcpy_s(&password, mqttOptions->password) != 0)
         {
-            LOG(AZ_LOG_ERROR, LOG_LINE, "mallocAndStrcpy_s password");
+            printf("mallocAndStrcpy_s password");
             result = __FAILURE__;
         }
         else
@@ -571,7 +573,7 @@
     return result;
 }
 
-static void recvCompleteCallback(void* context, CONTROL_PACKET_TYPE packet, int flags, BUFFER_HANDLE headerData)
+static void ICACHE_FLASH_ATTR  recvCompleteCallback(void* context, CONTROL_PACKET_TYPE packet, int flags, BUFFER_HANDLE headerData)
 {
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)context;
     if ((mqtt_client != NULL && headerData != NULL) || packet == PINGRESP_TYPE)
@@ -579,11 +581,11 @@
         size_t len = BUFFER_length(headerData);
         uint8_t* iterator = BUFFER_u_char(headerData);
 
-        logIncomingRawTrace(mqtt_client, packet, (uint8_t)flags, iterator, len);
+        //logIncomingRawTrace(mqtt_client, packet, (uint8_t)flags, iterator, len);
 
         if (tickcounter_get_current_ms(mqtt_client->packetTickCntr, &mqtt_client->packetRecvTimeMs) != 0)
         {
-            LOG(AZ_LOG_ERROR, LOG_LINE, "Failure getting current ms tickcounter");
+            printf("Failure getting current ms tickcounter");
         }
         else if ((iterator != NULL && len > 0) || packet == PINGRESP_TYPE)
         {
@@ -603,7 +605,7 @@
                         if (mqtt_client->logTrace)
                         {
                             trace_log = STRING_construct_sprintf("CONNACK | SESSION_PRESENT: %s | RETURN_CODE: 0x%x", connack.isSessionPresent ? TRUE_CONST : FALSE_CONST, connack.returnCode);
-                            log_incoming_trace(mqtt_client, trace_log);
+                            //log_incoming_trace(mqtt_client, trace_log);
                             STRING_delete(trace_log);
                         }
                         mqtt_client->fnOperationCallback(mqtt_client, MQTT_CLIENT_ON_CONNACK, (void*)&connack, mqtt_client->ctx);
@@ -615,7 +617,7 @@
                     }
                     else
                     {
-                        LOG(AZ_LOG_ERROR, LOG_LINE, "fnOperationCallback NULL");
+                        printf("fnOperationCallback NULL");
                     }
                     break;
                 }
@@ -640,7 +642,7 @@
                         char* topicName = byteutil_readUTF(&iterator, &length);
                         if (topicName == NULL)
                         {
-                            LOG(AZ_LOG_ERROR, LOG_LINE, "Publish MSG: failure reading topic name");
+                            printf("Publish MSG: failure reading topic name");
                             set_error_callback(mqtt_client, MQTT_CLIENT_PARSE_ERROR);
                             if (trace_log != NULL)
                             {
@@ -660,7 +662,7 @@
                                 packetId = byteutil_read_uint16(&iterator, length);
                                 if (mqtt_client->logTrace)
                                 {
-                                    STRING_sprintf(trace_log, " | PACKET_ID: %"PRIu16, packetId);
+                                    STRING_sprintf(trace_log, " | PACKET_ID: %");
                                 }
                             }
                             length = len - (iterator - initialPos);
@@ -668,7 +670,7 @@
                             MQTT_MESSAGE_HANDLE msgHandle = mqttmessage_create(packetId, topicName, qosValue, iterator, length);
                             if (msgHandle == NULL)
                             {
-                                LOG(AZ_LOG_ERROR, LOG_LINE, "failure in mqttmessage_create");
+                                printf("failure in mqttmessage_create");
                                 set_error_callback(mqtt_client, MQTT_CLIENT_MEMORY_ERROR);
                                 if (trace_log != NULL) {
                                     STRING_delete(trace_log);
@@ -679,7 +681,7 @@
                                 if (mqttmessage_setIsDuplicateMsg(msgHandle, isDuplicateMsg) != 0 ||
                                     mqttmessage_setIsRetained(msgHandle, isRetainMsg) != 0)
                                 {
-                                    LOG(AZ_LOG_ERROR, LOG_LINE, "failure setting mqtt message property");
+                                    printf("failure setting mqtt message property");
                                     set_error_callback(mqtt_client, MQTT_CLIENT_MEMORY_ERROR);
                                     if (trace_log != NULL) {
                                         STRING_delete(trace_log);
@@ -690,7 +692,7 @@
                                     if (mqtt_client->logTrace)
                                     {
                                         STRING_sprintf(trace_log, " | PAYLOAD_LEN: %zu", length);
-                                        log_incoming_trace(mqtt_client, trace_log);
+                                        //log_incoming_trace(mqtt_client, trace_log);
                                         STRING_delete(trace_log);
                                     }
 
@@ -702,7 +704,7 @@
                                         pubRel = mqtt_codec_publishReceived(packetId);
                                         if (pubRel == NULL)
                                         {
-                                            LOG(AZ_LOG_ERROR, LOG_LINE, "Failed to allocate publish receive message.");
+                                            printf("Failed to allocate publish receive message.");
                                             set_error_callback(mqtt_client, MQTT_CLIENT_MEMORY_ERROR);
                                         }
                                     }
@@ -711,7 +713,7 @@
                                         pubRel = mqtt_codec_publishAck(packetId);
                                         if (pubRel == NULL)
                                         {
-                                            LOG(AZ_LOG_ERROR, LOG_LINE, "Failed to allocate publish ack message.");
+                                            printf("Failed to allocate publish ack message.");
                                             set_error_callback(mqtt_client, MQTT_CLIENT_MEMORY_ERROR);
                                         }
                                     }
@@ -748,11 +750,11 @@
 
                         if (mqtt_client->logTrace)
                         {
-                            trace_log = STRING_construct_sprintf("%s | PACKET_ID: %"PRIu16, packet == PUBACK_TYPE ? "PUBACK" : (packet == PUBREC_TYPE) ? "PUBREC" : (packet == PUBREL_TYPE) ? "PUBREL" : "PUBCOMP",
+                            /*trace_log = STRING_construct_sprintf("%s | PACKET_ID: %"PRIu16, packet == PUBACK_TYPE ? "PUBACK" : (packet == PUBREC_TYPE) ? "PUBREC" : (packet == PUBREL_TYPE) ? "PUBREL" : "PUBCOMP",
                                 publish_ack.packetId);
 
                             log_incoming_trace(mqtt_client, trace_log);
-                            STRING_delete(trace_log);
+                            STRING_delete(trace_log);*/
                         }
 
                         BUFFER_HANDLE pubRel = NULL;
@@ -762,7 +764,7 @@
                             pubRel = mqtt_codec_publishRelease(publish_ack.packetId);
                             if (pubRel == NULL)
                             {
-                                LOG(AZ_LOG_ERROR, LOG_LINE, "Failed to allocate publish release message.");
+                                printf("Failed to allocate publish release message.");
                                 set_error_callback(mqtt_client, MQTT_CLIENT_MEMORY_ERROR);
                             }
                         }
@@ -771,7 +773,7 @@
                             pubRel = mqtt_codec_publishComplete(publish_ack.packetId);
                             if (pubRel == NULL)
                             {
-                                LOG(AZ_LOG_ERROR, LOG_LINE, "Failed to allocate publish complete message.");
+                                printf("Failed to allocate publish complete message.");
                                 set_error_callback(mqtt_client, MQTT_CLIENT_MEMORY_ERROR);
                             }
                         }
@@ -799,7 +801,7 @@
 
                         if (mqtt_client->logTrace)
                         {
-                            trace_log = STRING_construct_sprintf("SUBACK | PACKET_ID: %"PRIu16, suback.packetId);
+                            //trace_log = STRING_construct_sprintf("SUBACK | PACKET_ID: %"PRIu16, suback.packetId);
                         }
 
                         // Allocate the remaining len
@@ -812,13 +814,13 @@
                                 remainLen--;
                                 if (mqtt_client->logTrace)
                                 {
-                                    STRING_sprintf(trace_log, " | RETURN_CODE: %"PRIu16, suback.qosReturn[suback.qosCount-1]);
+                                    //STRING_sprintf(trace_log, " | RETURN_CODE: %"PRIu16, suback.qosReturn[suback.qosCount-1]);
                                 }
                             }
 
                             if (mqtt_client->logTrace)
                             {
-                                log_incoming_trace(mqtt_client, trace_log);
+                                //log_incoming_trace(mqtt_client, trace_log);
                                 STRING_delete(trace_log);
                             }
                             mqtt_client->fnOperationCallback(mqtt_client, MQTT_CLIENT_ON_SUBSCRIBE_ACK, (void*)&suback, mqtt_client->ctx);
@@ -826,7 +828,7 @@
                         }
                         else
                         {
-                            LOG(AZ_LOG_ERROR, LOG_LINE, "allocation of quality of service value failed.");
+                            printf("allocation of quality of service value failed.");
                             set_error_callback(mqtt_client, MQTT_CLIENT_MEMORY_ERROR);
                         }
                     }
@@ -844,9 +846,9 @@
 
                         if (mqtt_client->logTrace)
                         {
-                            trace_log = STRING_construct_sprintf("UNSUBACK | PACKET_ID: %"PRIu16, unsuback.packetId);
-                            log_incoming_trace(mqtt_client, trace_log);
-                            STRING_delete(trace_log);
+                            //trace_log = STRING_construct_sprintf("UNSUBACK | PACKET_ID: %"PRIu16, unsuback.packetId);
+                            //log_incoming_trace(mqtt_client, trace_log);
+                            //STRING_delete(trace_log);
                         }
                         mqtt_client->fnOperationCallback(mqtt_client, MQTT_CLIENT_ON_UNSUBSCRIBE_ACK, (void*)&unsuback, mqtt_client->ctx);
                     }
@@ -857,7 +859,7 @@
                     if (mqtt_client->logTrace)
                     {
                         STRING_HANDLE trace_log = STRING_construct_sprintf("PINGRESP");
-                        log_incoming_trace(mqtt_client, trace_log);
+                        //log_incoming_trace(mqtt_client, trace_log);
                         STRING_delete(trace_log);
                     }
                     // Forward ping response to operation callback 
@@ -873,7 +875,8 @@
     }
 }
 
-MQTT_CLIENT_HANDLE mqtt_client_init(ON_MQTT_MESSAGE_RECV_CALLBACK msgRecv, ON_MQTT_OPERATION_CALLBACK opCallback, void* opCallbackCtx, ON_MQTT_ERROR_CALLBACK onErrorCallBack, void* errorCBCtx)
+
+MQTT_CLIENT_HANDLE  ICACHE_FLASH_ATTR mqtt_client_init(ON_MQTT_MESSAGE_RECV_CALLBACK msgRecv, ON_MQTT_OPERATION_CALLBACK opCallback, void* opCallbackCtx, ON_MQTT_ERROR_CALLBACK onErrorCallBack, void* errorCBCtx)
 {
     MQTT_CLIENT* result;
     /*Codes_SRS_MQTT_CLIENT_07_001: [If the parameters ON_MQTT_MESSAGE_RECV_CALLBACK is NULL then mqttclient_init shall return NULL.]*/
@@ -883,11 +886,11 @@
     }
     else
     {
-        result = malloc(sizeof(MQTT_CLIENT));
+        result = (void*)malloc(sizeof(MQTT_CLIENT));
         if (result == NULL)
         {
             /*Codes_SRS_MQTT_CLIENT_07_002: [If any failure is encountered then mqttclient_init shall return NULL.]*/
-            LOG(AZ_LOG_ERROR, LOG_LINE, "mqtt_client_init failure: Allocation Failure");
+            printf("mqtt_client_init failure: Allocation Failure");
         }
         else
         {
@@ -905,7 +908,7 @@
             if (result->packetTickCntr == NULL)
             {
                 /*Codes_SRS_MQTT_CLIENT_07_002: [If any failure is encountered then mqttclient_init shall return NULL.]*/
-                LOG(AZ_LOG_ERROR, LOG_LINE, "mqtt_client_init failure: tickcounter_create failure");
+                printf("mqtt_client_init failure: tickcounter_create failure");
                 free(result);
                 result = NULL;
             }
@@ -915,7 +918,7 @@
                 if (result->codec_handle == NULL)
                 {
                     /*Codes_SRS_MQTT_CLIENT_07_002: [If any failure is encountered then mqttclient_init shall return NULL.]*/
-                    LOG(AZ_LOG_ERROR, LOG_LINE, "mqtt_client_init failure: mqtt_codec_create failure");
+                    printf("mqtt_client_init failure: mqtt_codec_create failure");
                     tickcounter_destroy(result->packetTickCntr);
                     free(result);
                     result = NULL;
@@ -926,7 +929,8 @@
     return result;
 }
 
-void mqtt_client_deinit(MQTT_CLIENT_HANDLE handle)
+
+void  ICACHE_FLASH_ATTR mqtt_client_deinit(MQTT_CLIENT_HANDLE handle)
 {
     /*Codes_SRS_MQTT_CLIENT_07_004: [If the parameter handle is NULL then function mqtt_client_deinit shall do nothing.]*/
     if (handle != NULL)
@@ -940,13 +944,14 @@
     }
 }
 
-int mqtt_client_connect(MQTT_CLIENT_HANDLE handle, XIO_HANDLE xioHandle, MQTT_CLIENT_OPTIONS* mqttOptions)
+int  ICACHE_FLASH_ATTR mqtt_client_connect(MQTT_CLIENT_HANDLE handle, XIO_HANDLE xioHandle, MQTT_CLIENT_OPTIONS* mqttOptions)
 {
+    printf("==> mqtt_client_connect\n");
     int result;
     /*SRS_MQTT_CLIENT_07_006: [If any of the parameters handle, ioHandle, or mqttOptions are NULL then mqtt_client_connect shall return a non-zero value.]*/
     if (handle == NULL || mqttOptions == NULL)
     {
-        LOG(AZ_LOG_ERROR, LOG_LINE, "mqtt_client_connect: NULL argument (handle = %p, mqttOptions = %p)", handle, mqttOptions);
+        printf("mqtt_client_connect: NULL argument (handle = %p, mqttOptions = %p)", handle, mqttOptions);
         result = __FAILURE__;
     }
     else
@@ -955,7 +960,7 @@
         if (xioHandle == NULL)
         {
             /*Codes_SRS_MQTT_CLIENT_07_007: [If any failure is encountered then mqtt_client_connect shall return a non-zero value.]*/
-            LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqttcodec_connect failed");
+            printf("Error: mqttcodec_connect failed");
             result = __FAILURE__;
         }
         else
@@ -967,14 +972,14 @@
             mqtt_client->maxPingRespTime = (DEFAULT_MAX_PING_RESPONSE_TIME < mqttOptions->keepAliveInterval/2) ? DEFAULT_MAX_PING_RESPONSE_TIME : mqttOptions->keepAliveInterval/2;
             if (cloneMqttOptions(mqtt_client, mqttOptions) != 0)
             {
-                LOG(AZ_LOG_ERROR, LOG_LINE, "Error: Clone Mqtt Options failed");
+                printf("Error: Clone Mqtt Options failed");
                 result = __FAILURE__;
             }
             /*Codes_SRS_MQTT_CLIENT_07_008: [mqtt_client_connect shall open the XIO_HANDLE by calling into the xio_open interface.]*/
             else if (xio_open(xioHandle, onOpenComplete, mqtt_client, onBytesReceived, mqtt_client, onIoError, mqtt_client) != 0)
             {
                 /*Codes_SRS_MQTT_CLIENT_07_007: [If any failure is encountered then mqtt_client_connect shall return a non-zero value.]*/
-                LOG(AZ_LOG_ERROR, LOG_LINE, "Error: io_open failed");
+                printf("Error: io_open failed");
                 result = __FAILURE__;
                 // Remove cloned options
                 clear_mqtt_options(mqtt_client);
@@ -988,14 +993,14 @@
     return result;
 }
 
-int mqtt_client_publish(MQTT_CLIENT_HANDLE handle, MQTT_MESSAGE_HANDLE msgHandle)
+int  ICACHE_FLASH_ATTR mqtt_client_publish(MQTT_CLIENT_HANDLE handle, MQTT_MESSAGE_HANDLE msgHandle)
 {
     int result;
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)handle;
     if (mqtt_client == NULL || msgHandle == NULL)
     {
         /*Codes_SRS_MQTT_CLIENT_07_019: [If one of the parameters handle or msgHandle is NULL then mqtt_client_publish shall return a non-zero value.]*/
-        LogError("Invalid parameter specified mqtt_client: %p, msgHandle: %p", mqtt_client, msgHandle);
+        printf("Invalid parameter specified mqtt_client: %p, msgHandle: %p", mqtt_client, msgHandle);
         result = __FAILURE__;
     }
     else
@@ -1005,7 +1010,7 @@
         if (payload == NULL)
         {
             /*Codes_SRS_MQTT_CLIENT_07_020: [If any failure is encountered then mqtt_client_unsubscribe shall return a non-zero value.]*/
-            LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqttmessage_getApplicationMsg failed");
+            printf("Error: mqttmessage_getApplicationMsg failed");
             result = __FAILURE__;
         }
         else
@@ -1021,7 +1026,7 @@
             if (publishPacket == NULL)
             {
                 /*Codes_SRS_MQTT_CLIENT_07_020: [If any failure is encountered then mqtt_client_unsubscribe shall return a non-zero value.]*/
-                LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_codec_publish failed");
+                printf("Error: mqtt_codec_publish failed");
                 result = __FAILURE__;
             }
             else
@@ -1033,12 +1038,12 @@
                 if (sendPacketItem(mqtt_client, BUFFER_u_char(publishPacket), size) != 0)
                 {
                     /*Codes_SRS_MQTT_CLIENT_07_020: [If any failure is encountered then mqtt_client_unsubscribe shall return a non-zero value.]*/
-                    LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_client_publish send failed");
+                    printf("Error: mqtt_client_publish send failed");
                     result = __FAILURE__;
                 }
                 else
                 {
-                    log_outgoing_trace(mqtt_client, trace_log);
+                    //log_outgoing_trace(mqtt_client, trace_log);
                     result = 0;
                 }
                 BUFFER_delete(publishPacket);
@@ -1052,14 +1057,15 @@
     return result;
 }
 
-int mqtt_client_subscribe(MQTT_CLIENT_HANDLE handle, uint16_t packetId, SUBSCRIBE_PAYLOAD* subscribeList, size_t count)
+
+int  ICACHE_FLASH_ATTR mqtt_client_subscribe(MQTT_CLIENT_HANDLE handle, uint16_t packetId, SUBSCRIBE_PAYLOAD* subscribeList, size_t count)
 {
     int result;
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)handle;
     if (mqtt_client == NULL || subscribeList == NULL || count == 0 || packetId == 0)
     {
         /*Codes_SRS_MQTT_CLIENT_07_013: [If any of the parameters handle, subscribeList is NULL or count is 0 then mqtt_client_subscribe shall return a non-zero value.]*/
-        LogError("Invalid parameter specified mqtt_client: %p, subscribeList: %p, count: %d, packetId: %d", mqtt_client, subscribeList, count, packetId);
+        printf("Invalid parameter specified mqtt_client: %p, subscribeList: %p, count: %d, packetId: %d", mqtt_client, subscribeList, count, packetId);
         result = __FAILURE__;
     }
     else
@@ -1070,7 +1076,7 @@
         if (subPacket == NULL)
         {
             /*Codes_SRS_MQTT_CLIENT_07_014: [If any failure is encountered then mqtt_client_subscribe shall return a non-zero value.]*/
-            LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_codec_subscribe failed");
+            printf("Error: mqtt_codec_subscribe failed");
             result = __FAILURE__;
         }
         else
@@ -1082,12 +1088,12 @@
             if (sendPacketItem(mqtt_client, BUFFER_u_char(subPacket), size) != 0)
             {
                 /*Codes_SRS_MQTT_CLIENT_07_014: [If any failure is encountered then mqtt_client_subscribe shall return a non-zero value.]*/
-                LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_client_subscribe send failed");
+                printf("Error: mqtt_client_subscribe send failed");
                 result = __FAILURE__;
             }
             else
             {
-                log_outgoing_trace(mqtt_client, trace_log);
+                //log_outgoing_trace(mqtt_client, trace_log);
                 result = 0;
             }
             BUFFER_delete(subPacket);
@@ -1100,14 +1106,14 @@
     return result;
 }
 
-int mqtt_client_unsubscribe(MQTT_CLIENT_HANDLE handle, uint16_t packetId, const char** unsubscribeList, size_t count)
+int  ICACHE_FLASH_ATTR mqtt_client_unsubscribe(MQTT_CLIENT_HANDLE handle, uint16_t packetId, const char** unsubscribeList, size_t count)
 {
     int result;
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)handle;
     if (mqtt_client == NULL || unsubscribeList == NULL || count == 0 || packetId == 0)
     {
         /*Codes_SRS_MQTT_CLIENT_07_016: [If any of the parameters handle, unsubscribeList is NULL or count is 0 then mqtt_client_unsubscribe shall return a non-zero value.]*/
-        LogError("Invalid parameter specified mqtt_client: %p, unsubscribeList: %p, count: %d, packetId: %d", mqtt_client, unsubscribeList, count, packetId);
+        printf("Invalid parameter specified mqtt_client: %p, unsubscribeList: %p, count: %d, packetId: %d", mqtt_client, unsubscribeList, count, packetId);
         result = __FAILURE__;
     }
     else
@@ -1118,7 +1124,7 @@
         if (unsubPacket == NULL)
         {
             /*Codes_SRS_MQTT_CLIENT_07_017: [If any failure is encountered then mqtt_client_unsubscribe shall return a non-zero value.]*/
-            LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_codec_unsubscribe failed");
+            printf("Error: mqtt_codec_unsubscribe failed");
             result = __FAILURE__;
         }
         else
@@ -1130,12 +1136,12 @@
             if (sendPacketItem(mqtt_client, BUFFER_u_char(unsubPacket), size) != 0)
             {
                 /*Codes_SRS_MQTT_CLIENT_07_017: [If any failure is encountered then mqtt_client_unsubscribe shall return a non-zero value.].]*/
-                LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_client_unsubscribe send failed");
+                printf("Error: mqtt_client_unsubscribe send failed");
                 result = __FAILURE__;
             }
             else
             {
-                log_outgoing_trace(mqtt_client, trace_log);
+                //log_outgoing_trace(mqtt_client, trace_log);
                 result = 0;
             }
             BUFFER_delete(unsubPacket);
@@ -1148,7 +1154,7 @@
     return result;
 }
 
-int mqtt_client_disconnect(MQTT_CLIENT_HANDLE handle, ON_MQTT_DISCONNECTED_CALLBACK callback, void* ctx)
+int  ICACHE_FLASH_ATTR mqtt_client_disconnect(MQTT_CLIENT_HANDLE handle, ON_MQTT_DISCONNECTED_CALLBACK callback, void* ctx)
 {
     int result;
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)handle;
@@ -1165,7 +1171,7 @@
             if (disconnectPacket == NULL)
             {
                 /*Codes_SRS_MQTT_CLIENT_07_011: [If any failure is encountered then mqtt_client_disconnect shall return a non-zero value.]*/
-                LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_client_disconnect failed");
+                printf("Error: mqtt_client_disconnect failed");
                 mqtt_client->packetState = PACKET_TYPE_ERROR;
                 result = __FAILURE__;
             }
@@ -1181,7 +1187,7 @@
                 if (sendPacketItem(mqtt_client, BUFFER_u_char(disconnectPacket), size) != 0)
                 {
                     /*Codes_SRS_MQTT_CLIENT_07_011: [If any failure is encountered then mqtt_client_disconnect shall return a non-zero value.]*/
-                    LOG(AZ_LOG_ERROR, LOG_LINE, "Error: mqtt_client_disconnect send failed");
+                    printf("Error: mqtt_client_disconnect send failed");
                     result = __FAILURE__;
                 }
                 else
@@ -1189,7 +1195,7 @@
                     if (mqtt_client->logTrace)
                     {
                         STRING_HANDLE trace_log = STRING_construct("DISCONNECT");
-                        log_outgoing_trace(mqtt_client, trace_log);
+                        //log_outgoing_trace(mqtt_client, trace_log);
                         STRING_delete(trace_log);
                     }
                     result = 0;
@@ -1213,8 +1219,9 @@
     return result;
 }
 
-void mqtt_client_dowork(MQTT_CLIENT_HANDLE handle)
+void ICACHE_FLASH_ATTR  mqtt_client_dowork(MQTT_CLIENT_HANDLE handle)
 {
+    printf("==> mqtt_client_dowork\n");
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)handle;
     /*Codes_SRS_MQTT_CLIENT_18_001: [If the client is disconnected, mqtt_client_dowork shall do nothing.]*/
     /*Codes_SRS_MQTT_CLIENT_07_023: [If the parameter handle is NULL then mqtt_client_dowork shall do nothing.]*/
@@ -1229,7 +1236,7 @@
             tickcounter_ms_t current_ms;
             if (tickcounter_get_current_ms(mqtt_client->packetTickCntr, &current_ms) != 0)
             {
-                LOG(AZ_LOG_ERROR, LOG_LINE, "Error: tickcounter_get_current_ms failed");
+                printf("Error: tickcounter_get_current_ms failed");
             }
             else
             {
@@ -1242,10 +1249,21 @@
                     mqtt_client->packetRecvTimeMs = 0;
                     mqtt_client->packetState = UNKNOWN_TYPE;
                 }
-                else if (((current_ms - mqtt_client->packetRecvTimeMs) / 1000) >= mqtt_client->keepAliveInterval)
+                else if (((current_ms - mqtt_client->packetRecvTimeMs) / 1000) >= 1)// mqtt_client->keepAliveInterval
                 {
                     if (mqtt_client->timeSincePing > 0) {
                         // already sent ping but no response yet, keep waiting, don't send another ping
+                        BUFFER_HANDLE pingPacket = mqtt_codec_ping();
+                        size_t size = BUFFER_length(pingPacket);
+                        printf("send pinggggggggg\n");
+                        int i;
+                        for (i = 0; i < size; i++) {
+                            printf("%x ", (BUFFER_u_char(pingPacket))[i]);
+                        }
+                        printf("\n");
+                        printf("mqtt_client send ping!!!!!!!!\n");
+                        (void)sendPacketItem(mqtt_client, BUFFER_u_char(pingPacket), size);
+                        BUFFER_delete(pingPacket);
                         return;
                     }
                     /*Codes_SRS_MQTT_CLIENT_07_026: [if keepAliveInternal is > 0 and the send time is greater than the MQTT KeepAliveInterval then it shall construct an MQTT PINGREQ packet.]*/
@@ -1253,6 +1271,13 @@
                     if (pingPacket != NULL)
                     {
                         size_t size = BUFFER_length(pingPacket);
+                        printf("send pinggggggggg\n");
+                        int i;
+                        for (i = 0; i < size; i++) {
+                            printf("%x ", (BUFFER_u_char(pingPacket))[i]);
+                        }
+                        printf("\n");
+                        printf("mqtt_client send ping!!!!!!!!\n");
                         (void)sendPacketItem(mqtt_client, BUFFER_u_char(pingPacket), size);
                         BUFFER_delete(pingPacket);
                         if (mqtt_client->timeSincePing == 0) {
@@ -1262,7 +1287,7 @@
                         if (mqtt_client->logTrace)
                         {
                             STRING_HANDLE trace_log = STRING_construct("PINGREQ");
-                            log_outgoing_trace(mqtt_client, trace_log);
+                            //log_outgoing_trace(mqtt_client, trace_log);
                             STRING_delete(trace_log);
                         }
                     }
@@ -1272,7 +1297,7 @@
     }
 }
 
-void mqtt_client_set_trace(MQTT_CLIENT_HANDLE handle, bool traceOn, bool rawBytesOn)
+void  ICACHE_FLASH_ATTR mqtt_client_set_trace(MQTT_CLIENT_HANDLE handle, bool traceOn, bool rawBytesOn)
 {
     MQTT_CLIENT* mqtt_client = (MQTT_CLIENT*)handle;
     if (mqtt_client != NULL)
@@ -1280,4 +1305,4 @@
         mqtt_client->logTrace = traceOn;
         mqtt_client->rawBytesTrace = rawBytesOn;
     }
-}
+}
\ No newline at end of file
diff -uNr src/mqtt_codec.c src_ok/mqtt_codec.c
--- src/mqtt_codec.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/mqtt_codec.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,16 +1,17 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdlib.h>
-#include <limits.h>
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/buffer_.h"
-#include "azure_c_shared_utility/strings.h"
-#include "azure_c_shared_utility/macro_utils.h"
-#include "azure_c_shared_utility/xlogging.h"
-#include "azure_umqtt_c/mqtt_codec.h"
-#include <inttypes.h>
+//#include <stdlib.h>
+//#include <limits.h>
+
+#include "esp_types.h"
+#include "buffer_.h"
+#include "strings.h"
+#include "macro_utils.h"
+#include "xlogging.h"
+#include "mqtt_codec.h"
+
+#define USHRT_MAX 65535
 
 #define PAYLOAD_OFFSET                      5
 #define PACKET_TYPE_BYTE(p)                 ((uint8_t)(((uint8_t)(p)) & 0xf0))
@@ -70,7 +71,7 @@
     QOS_VALUE qualityOfServiceValue;
 } PUBLISH_HEADER_INFO;
 
-static const char* retrieve_qos_value(QOS_VALUE value)
+static const char*  ICACHE_FLASH_ATTR retrieve_qos_value(QOS_VALUE value)
 {
     switch (value)
     {
@@ -84,7 +85,7 @@
     }
 }
 
-static void byteutil_writeByte(uint8_t** buffer, uint8_t value)
+static void  ICACHE_FLASH_ATTR byteutil_writeByte(uint8_t** buffer, uint8_t value)
 {
     if (buffer != NULL)
     {
@@ -93,7 +94,7 @@
     }
 }
 
-static void byteutil_writeInt(uint8_t** buffer, uint16_t value)
+static void  ICACHE_FLASH_ATTR byteutil_writeInt(uint8_t** buffer, uint16_t value)
 {
     if (buffer != NULL)
     {
@@ -104,7 +105,7 @@
     }
 }
 
-static void byteutil_writeUTF(uint8_t** buffer, const char* stringData, uint16_t len)
+static void  ICACHE_FLASH_ATTR byteutil_writeUTF(uint8_t** buffer, const char* stringData, uint16_t len)
 {
     if (buffer != NULL)
     {
@@ -114,7 +115,7 @@
     }
 }
 
-static CONTROL_PACKET_TYPE processControlPacketType(uint8_t pktByte, int* flags)
+static CONTROL_PACKET_TYPE ICACHE_FLASH_ATTR  processControlPacketType(uint8_t pktByte, int* flags)
 {
     CONTROL_PACKET_TYPE result;
     result = PACKET_TYPE_BYTE(pktByte);
@@ -125,7 +126,7 @@
     return result;
 }
 
-static int addListItemsToUnsubscribePacket(BUFFER_HANDLE ctrlPacket, const char** payloadList, size_t payloadCount, STRING_HANDLE trace_log)
+static int ICACHE_FLASH_ATTR  addListItemsToUnsubscribePacket(BUFFER_HANDLE ctrlPacket, const char** payloadList, size_t payloadCount, STRING_HANDLE trace_log)
 {
     int result = 0;
     if (payloadList == NULL || ctrlPacket == NULL)
@@ -163,7 +164,7 @@
     return result;
 }
 
-static int addListItemsToSubscribePacket(BUFFER_HANDLE ctrlPacket, SUBSCRIBE_PAYLOAD* payloadList, size_t payloadCount, STRING_HANDLE trace_log)
+static int ICACHE_FLASH_ATTR  addListItemsToSubscribePacket(BUFFER_HANDLE ctrlPacket, SUBSCRIBE_PAYLOAD* payloadList, size_t payloadCount, STRING_HANDLE trace_log)
 {
     int result = 0;
     if (payloadList == NULL || ctrlPacket == NULL)
@@ -203,7 +204,7 @@
     return result;
 }
 
-static int constructConnectVariableHeader(BUFFER_HANDLE ctrlPacket, const MQTT_CLIENT_OPTIONS* mqttOptions, STRING_HANDLE trace_log)
+static int  ICACHE_FLASH_ATTR constructConnectVariableHeader(BUFFER_HANDLE ctrlPacket, const MQTT_CLIENT_OPTIONS* mqttOptions, STRING_HANDLE trace_log)
 {
     int result = 0;
     if (BUFFER_enlarge(ctrlPacket, CONNECT_VARIABLE_HEADER_SIZE) != 0)
@@ -233,7 +234,7 @@
     return result;
 }
 
-static int constructPublishVariableHeader(BUFFER_HANDLE ctrlPacket, const PUBLISH_HEADER_INFO* publishHeader, STRING_HANDLE trace_log)
+static int  ICACHE_FLASH_ATTR constructPublishVariableHeader(BUFFER_HANDLE ctrlPacket, const PUBLISH_HEADER_INFO* publishHeader, STRING_HANDLE trace_log)
 {
     int result = 0;
     size_t topicLen = 0;
@@ -279,7 +280,7 @@
             {
                 if (trace_log != NULL)
                 {
-                    STRING_sprintf(trace_log, " | PACKET_ID: %"PRIu16, publishHeader->packetId);
+                    //STRING_sprintf(trace_log, " | PACKET_ID: %"PRIu16, publishHeader->packetId);
                 }
                 byteutil_writeInt(&iterator, publishHeader->packetId);
             }
@@ -289,7 +290,7 @@
     return result;
 }
 
-static int constructSubscibeTypeVariableHeader(BUFFER_HANDLE ctrlPacket, uint16_t packetId)
+static int  ICACHE_FLASH_ATTR constructSubscibeTypeVariableHeader(BUFFER_HANDLE ctrlPacket, uint16_t packetId)
 {
     int result = 0;
     if (BUFFER_enlarge(ctrlPacket, 2) != 0)
@@ -312,7 +313,7 @@
     return result;
 }
 
-static BUFFER_HANDLE constructPublishReply(CONTROL_PACKET_TYPE type, uint8_t flags, uint16_t packetId)
+static BUFFER_HANDLE  ICACHE_FLASH_ATTR constructPublishReply(CONTROL_PACKET_TYPE type, uint8_t flags, uint16_t packetId)
 {
     BUFFER_HANDLE result = BUFFER_new();
     if (result != NULL)
@@ -343,7 +344,7 @@
     return result;
 }
 
-static int constructFixedHeader(BUFFER_HANDLE ctrlPacket, CONTROL_PACKET_TYPE packetType, uint8_t flags)
+static int ICACHE_FLASH_ATTR  constructFixedHeader(BUFFER_HANDLE ctrlPacket, CONTROL_PACKET_TYPE packetType, uint8_t flags)
 {
     int result;
     if (ctrlPacket == NULL)
@@ -393,7 +394,7 @@
     return result;
 }
 
-static int constructConnPayload(BUFFER_HANDLE ctrlPacket, const MQTT_CLIENT_OPTIONS* mqttOptions, STRING_HANDLE trace_log)
+static int ICACHE_FLASH_ATTR  constructConnPayload(BUFFER_HANDLE ctrlPacket, const MQTT_CLIENT_OPTIONS* mqttOptions, STRING_HANDLE trace_log)
 {
     int result = 0;
     if (mqttOptions == NULL || ctrlPacket == NULL)
@@ -530,7 +531,7 @@
     return result;
 }
 
-static int prepareheaderDataInfo(MQTTCODEC_INSTANCE* codecData, uint8_t remainLen)
+static int  ICACHE_FLASH_ATTR prepareheaderDataInfo(MQTTCODEC_INSTANCE* codecData, uint8_t remainLen)
 {
     int result;
     if (codecData == NULL)
@@ -573,7 +574,7 @@
                 if (codecData->headerData == NULL)
                 {
                     /* Codes_SRS_MQTT_CODEC_07_035: [ If any error is encountered then the packet state will be marked as error and mqtt_codec_bytesReceived shall return a non-zero value. ] */
-                    LogError("Failed BUFFER_new");
+                    printf("Failed BUFFER_new");
                     result = __FAILURE__;
                 }
                 else
@@ -581,7 +582,7 @@
                     if (BUFFER_pre_build(codecData->headerData, totalLen) != 0)
                     {
                         /* Codes_SRS_MQTT_CODEC_07_035: [ If any error is encountered then the packet state will be marked as error and mqtt_codec_bytesReceived shall return a non-zero value. ] */
-                        LogError("Failed BUFFER_pre_build");
+                        printf("Failed BUFFER_pre_build");
                         result = __FAILURE__;
                     }
 
@@ -592,7 +593,7 @@
     return result;
 }
 
-static void completePacketData(MQTTCODEC_INSTANCE* codecData)
+static void ICACHE_FLASH_ATTR  completePacketData(MQTTCODEC_INSTANCE* codecData)
 {
     if (codecData)
     {
@@ -610,7 +611,7 @@
     }
 }
 
-MQTTCODEC_HANDLE mqtt_codec_create(ON_PACKET_COMPLETE_CALLBACK packetComplete, void* callbackCtx)
+MQTTCODEC_HANDLE  ICACHE_FLASH_ATTR mqtt_codec_create(ON_PACKET_COMPLETE_CALLBACK packetComplete, void* callbackCtx)
 {
     MQTTCODEC_HANDLE result;
     result = malloc(sizeof(MQTTCODEC_INSTANCE));
@@ -631,7 +632,7 @@
     return result;
 }
 
-void mqtt_codec_destroy(MQTTCODEC_HANDLE handle)
+void  ICACHE_FLASH_ATTR mqtt_codec_destroy(MQTTCODEC_HANDLE handle)
 {
     /* Codes_SRS_MQTT_CODEC_07_003: [If the handle parameter is NULL then mqtt_codec_destroy shall do nothing.] */
     if (handle != NULL)
@@ -643,7 +644,7 @@
     }
 }
 
-BUFFER_HANDLE mqtt_codec_connect(const MQTT_CLIENT_OPTIONS* mqttOptions, STRING_HANDLE trace_log)
+BUFFER_HANDLE  ICACHE_FLASH_ATTR mqtt_codec_connect(const MQTT_CLIENT_OPTIONS* mqttOptions, STRING_HANDLE trace_log)
 {
     BUFFER_HANDLE result;
     /* Codes_SRS_MQTT_CODEC_07_008: [If the parameters mqttOptions is NULL then mqtt_codec_connect shall return a null value.] */
@@ -707,7 +708,7 @@
     return result;
 }
 
-BUFFER_HANDLE mqtt_codec_disconnect()
+BUFFER_HANDLE  ICACHE_FLASH_ATTR mqtt_codec_disconnect()
 {
     /* Codes_SRS_MQTT_CODEC_07_011: [On success mqtt_codec_disconnect shall construct a BUFFER_HANDLE that represents a MQTT DISCONNECT packet.] */
     BUFFER_HANDLE result = BUFFER_new();
@@ -738,7 +739,7 @@
     return result;
 }
 
-BUFFER_HANDLE mqtt_codec_publish(QOS_VALUE qosValue, bool duplicateMsg, bool serverRetain, uint16_t packetId, const char* topicName, const uint8_t* msgBuffer, size_t buffLen, STRING_HANDLE trace_log)
+BUFFER_HANDLE  ICACHE_FLASH_ATTR mqtt_codec_publish(QOS_VALUE qosValue, bool duplicateMsg, bool serverRetain, uint16_t packetId, const char* topicName, const uint8_t* msgBuffer, size_t buffLen, STRING_HANDLE trace_log)
 {
     BUFFER_HANDLE result;
     /* Codes_SRS_MQTT_CODEC_07_005: [If the parameters topicName is NULL then mqtt_codec_publish shall return NULL.] */
@@ -855,7 +856,7 @@
     return result;
 }
 
-BUFFER_HANDLE mqtt_codec_publishAck(uint16_t packetId)
+BUFFER_HANDLE ICACHE_FLASH_ATTR  mqtt_codec_publishAck(uint16_t packetId)
 {
     /* Codes_SRS_MQTT_CODEC_07_013: [On success mqtt_codec_publishAck shall return a BUFFER_HANDLE representation of a MQTT PUBACK packet.] */
     /* Codes_SRS_MQTT_CODEC_07_014 : [If any error is encountered then mqtt_codec_publishAck shall return NULL.] */
@@ -863,7 +864,7 @@
     return result;
 }
 
-BUFFER_HANDLE mqtt_codec_publishReceived(uint16_t packetId)
+BUFFER_HANDLE ICACHE_FLASH_ATTR  mqtt_codec_publishReceived(uint16_t packetId)
 {
     /* Codes_SRS_MQTT_CODEC_07_015: [On success mqtt_codec_publishRecieved shall return a BUFFER_HANDLE representation of a MQTT PUBREC packet.] */
     /* Codes_SRS_MQTT_CODEC_07_016 : [If any error is encountered then mqtt_codec_publishRecieved shall return NULL.] */
@@ -871,7 +872,7 @@
     return result;
 }
 
-BUFFER_HANDLE mqtt_codec_publishRelease(uint16_t packetId)
+BUFFER_HANDLE ICACHE_FLASH_ATTR  mqtt_codec_publishRelease(uint16_t packetId)
 {
     /* Codes_SRS_MQTT_CODEC_07_017: [On success mqtt_codec_publishRelease shall return a BUFFER_HANDLE representation of a MQTT PUBREL packet.] */
     /* Codes_SRS_MQTT_CODEC_07_018 : [If any error is encountered then mqtt_codec_publishRelease shall return NULL.] */
@@ -879,7 +880,7 @@
     return result;
 }
 
-BUFFER_HANDLE mqtt_codec_publishComplete(uint16_t packetId)
+BUFFER_HANDLE  ICACHE_FLASH_ATTR mqtt_codec_publishComplete(uint16_t packetId)
 {
     /* Codes_SRS_MQTT_CODEC_07_019: [On success mqtt_codec_publishComplete shall return a BUFFER_HANDLE representation of a MQTT PUBCOMP packet.] */
     /* Codes_SRS_MQTT_CODEC_07_020 : [If any error is encountered then mqtt_codec_publishComplete shall return NULL.] */
@@ -887,7 +888,7 @@
     return result;
 }
 
-BUFFER_HANDLE mqtt_codec_ping()
+BUFFER_HANDLE  ICACHE_FLASH_ATTR mqtt_codec_ping()
 {
     /* Codes_SRS_MQTT_CODEC_07_021: [On success mqtt_codec_ping shall construct a BUFFER_HANDLE that represents a MQTT PINGREQ packet.] */
     BUFFER_HANDLE result = BUFFER_new();
@@ -918,7 +919,7 @@
     return result;
 }
 
-BUFFER_HANDLE mqtt_codec_subscribe(uint16_t packetId, SUBSCRIBE_PAYLOAD* subscribeList, size_t count, STRING_HANDLE trace_log)
+BUFFER_HANDLE ICACHE_FLASH_ATTR  mqtt_codec_subscribe(uint16_t packetId, SUBSCRIBE_PAYLOAD* subscribeList, size_t count, STRING_HANDLE trace_log)
 {
     BUFFER_HANDLE result;
     /* Codes_SRS_MQTT_CODEC_07_023: [If the parameters subscribeList is NULL or if count is 0 then mqtt_codec_subscribe shall return NULL.] */
@@ -943,7 +944,7 @@
                 STRING_HANDLE sub_trace = NULL;
                 if (trace_log != NULL)
                 {
-                    sub_trace = STRING_construct_sprintf(" | PACKET_ID: %"PRIu16, packetId);
+                    //sub_trace = STRING_construct_sprintf(" | PACKET_ID: %"PRIu16, packetId);
                 }
                 /* Codes_SRS_MQTT_CODEC_07_024: [mqtt_codec_subscribe shall iterate through count items in the subscribeList.] */
                 if (addListItemsToSubscribePacket(result, subscribeList, count, sub_trace) != 0)
@@ -983,7 +984,7 @@
     return result;
 }
 
-BUFFER_HANDLE mqtt_codec_unsubscribe(uint16_t packetId, const char** unsubscribeList, size_t count, STRING_HANDLE trace_log)
+BUFFER_HANDLE  ICACHE_FLASH_ATTR mqtt_codec_unsubscribe(uint16_t packetId, const char** unsubscribeList, size_t count, STRING_HANDLE trace_log)
 {
     BUFFER_HANDLE result;
     /* Codes_SRS_MQTT_CODEC_07_027: [If the parameters unsubscribeList is NULL or if count is 0 then mqtt_codec_unsubscribe shall return NULL.] */
@@ -1008,7 +1009,7 @@
                 STRING_HANDLE unsub_trace = NULL;
                 if (trace_log != NULL)
                 {
-                    unsub_trace = STRING_construct_sprintf(" | PACKET_ID: %"PRIu16, packetId);
+                    //unsub_trace = STRING_construct_sprintf(" | PACKET_ID: %"PRIu16, packetId);
                 }
                 /* Codes_SRS_MQTT_CODEC_07_028: [mqtt_codec_unsubscribe shall iterate through count items in the unsubscribeList.] */
                 if (addListItemsToUnsubscribePacket(result, unsubscribeList, count, unsub_trace) != 0)
@@ -1047,7 +1048,7 @@
     return result;
 }
 
-int mqtt_codec_bytesReceived(MQTTCODEC_HANDLE handle, const unsigned char* buffer, size_t size)
+int  ICACHE_FLASH_ATTR mqtt_codec_bytesReceived(MQTTCODEC_HANDLE handle, const unsigned char* buffer, size_t size)
 {
     int result;
     MQTTCODEC_INSTANCE* codec_Data = (MQTTCODEC_INSTANCE*)handle;
diff -uNr src/mqtt_message.c src_ok/mqtt_message.c
--- src/mqtt_message.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/mqtt_message.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,11 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdlib.h>
-#include "azure_umqtt_c/mqtt_message.h"
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/xlogging.h"
+#include "esp_types.h"
+#include "mqtt_message.h"
+#include "xlogging.h"
 
 typedef struct MQTT_MESSAGE_TAG
 {
@@ -22,13 +20,13 @@
     bool isMessageRetained;
 } MQTT_MESSAGE;
 
-MQTT_MESSAGE_HANDLE mqttmessage_create_in_place(uint16_t packetId, const char* topicName, QOS_VALUE qosValue, const uint8_t* appMsg, size_t appMsgLength)
+MQTT_MESSAGE_HANDLE  ICACHE_FLASH_ATTR mqttmessage_create_in_place(uint16_t packetId, const char* topicName, QOS_VALUE qosValue, const uint8_t* appMsg, size_t appMsgLength)
 {
     /* Codes_SRS_MQTTMESSAGE_07_026: [If the parameters topicName is NULL then mqttmessage_create_in_place shall return NULL.].] */
     MQTT_MESSAGE* result;
     if (topicName == NULL)
     {
-        LogError("Invalid Parameter topicName: %p, packetId: %d.", topicName, packetId);
+        printf("Invalid Parameter topicName: %p, packetId: %d.", topicName, packetId);
         result = NULL;
     }
     else
@@ -54,20 +52,20 @@
         else
         {
             /* Codes_SRS_MQTTMESSAGE_07_028: [If any memory allocation fails mqttmessage_create_in_place shall free any allocated memory and return NULL.] */
-            LogError("Failure unable to allocate MQTT Message.");
+            printf("Failure unable to allocate MQTT Message.");
         }
     }
     /* Codes_SRS_MQTTMESSAGE_07_029: [ Upon success, mqttmessage_create_in_place shall return a NON-NULL MQTT_MESSAGE_HANDLE value.] */
     return (MQTT_MESSAGE_HANDLE)result;
 }
 
-MQTT_MESSAGE_HANDLE mqttmessage_create(uint16_t packetId, const char* topicName, QOS_VALUE qosValue, const uint8_t* appMsg, size_t appMsgLength)
+MQTT_MESSAGE_HANDLE ICACHE_FLASH_ATTR  mqttmessage_create(uint16_t packetId, const char* topicName, QOS_VALUE qosValue, const uint8_t* appMsg, size_t appMsgLength)
 {
     /* Codes_SRS_MQTTMESSAGE_07_001:[If the parameters topicName is NULL is zero then mqttmessage_create shall return NULL.] */
     MQTT_MESSAGE* result;
     if (topicName == NULL)
     {
-        LogError("Invalid Parameter topicName: %p, packetId: %d.", topicName, packetId);
+        printf("Invalid Parameter topicName: %p, packetId: %d.", topicName, packetId);
         result = NULL;
     }
     else
@@ -80,7 +78,7 @@
             if (mallocAndStrcpy_s(&result->topicName, topicName) != 0)
             {
                 /* Codes_SRS_MQTTMESSAGE_07_003: [If any memory allocation fails mqttmessage_create shall free any allocated memory and return NULL.] */
-                LogError("Failure allocating topic name");
+                printf("Failure allocating topic name");
                 free(result);
                 result = NULL;
             }
@@ -99,7 +97,7 @@
                     if (result->appPayload.message == NULL)
                     {
                         /* Codes_SRS_MQTTMESSAGE_07_003: [If any memory allocation fails mqttmessage_create shall free any allocated memory and return NULL.] */
-                        LogError("Failure allocating message value of %uz", appMsgLength);
+                        printf("Failure allocating message value of %uz", appMsgLength);
                         free(result->topicName);
                         free(result);
                         result = NULL;
@@ -120,7 +118,7 @@
     return (MQTT_MESSAGE_HANDLE)result;
 }
 
-void mqttmessage_destroy(MQTT_MESSAGE_HANDLE handle)
+void  ICACHE_FLASH_ATTR mqttmessage_destroy(MQTT_MESSAGE_HANDLE handle)
 {
     MQTT_MESSAGE* msgInfo = (MQTT_MESSAGE*)handle;
     /* Codes_SRS_MQTTMESSAGE_07_005: [If the handle parameter is NULL then mqttmessage_destroyMessage shall do nothing] */
@@ -139,13 +137,13 @@
     }
 }
 
-MQTT_MESSAGE_HANDLE mqttmessage_clone(MQTT_MESSAGE_HANDLE handle)
+MQTT_MESSAGE_HANDLE ICACHE_FLASH_ATTR  mqttmessage_clone(MQTT_MESSAGE_HANDLE handle)
 {
     MQTT_MESSAGE_HANDLE result;
     if (handle == NULL)
     {
         /* Codes_SRS_MQTTMESSAGE_07_007: [If handle parameter is NULL then mqttmessage_clone shall return NULL.] */
-        LogError("Invalid Parameter handle: %p.", handle);
+        printf("Invalid Parameter handle: %p.", handle);
         result = NULL;
     }
     else
@@ -162,13 +160,13 @@
     return result;
 }
 
-uint16_t mqttmessage_getPacketId(MQTT_MESSAGE_HANDLE handle)
+uint16_t  ICACHE_FLASH_ATTR mqttmessage_getPacketId(MQTT_MESSAGE_HANDLE handle)
 {
     uint16_t result;
     if (handle == NULL)
     {
         /* Codes_SRS_MQTTMESSAGE_07_010: [If handle is NULL then mqttmessage_getPacketId shall return 0.] */
-        LogError("Invalid Parameter handle: %p.", handle);
+        printf("Invalid Parameter handle: %p.", handle);
         result = 0;
     }
     else
@@ -180,13 +178,13 @@
     return result;
 }
 
-const char* mqttmessage_getTopicName(MQTT_MESSAGE_HANDLE handle)
+const char* ICACHE_FLASH_ATTR  mqttmessage_getTopicName(MQTT_MESSAGE_HANDLE handle)
 {
     const char* result;
     if (handle == NULL)
     {
         /* Codes_SRS_MQTTMESSAGE_07_012: [If handle is NULL then mqttmessage_getTopicName shall return a NULL string.] */
-        LogError("Invalid Parameter handle: %p.", handle);
+        printf("Invalid Parameter handle: %p.", handle);
         result = NULL;
     }
     else
@@ -205,13 +203,13 @@
     return result;
 }
 
-QOS_VALUE mqttmessage_getQosType(MQTT_MESSAGE_HANDLE handle)
+QOS_VALUE  ICACHE_FLASH_ATTR mqttmessage_getQosType(MQTT_MESSAGE_HANDLE handle)
 {
     QOS_VALUE result;
     if (handle == NULL)
     {
         /* Codes_SRS_MQTTMESSAGE_07_014: [If handle is NULL then mqttmessage_getQosType shall return the default DELIVER_AT_MOST_ONCE value.] */
-        LogError("Invalid Parameter handle: %p.", handle);
+        printf("Invalid Parameter handle: %p.", handle);
         result = DELIVER_AT_MOST_ONCE;
     }
     else
@@ -223,13 +221,13 @@
     return result;
 }
 
-bool mqttmessage_getIsDuplicateMsg(MQTT_MESSAGE_HANDLE handle)
+bool ICACHE_FLASH_ATTR  mqttmessage_getIsDuplicateMsg(MQTT_MESSAGE_HANDLE handle)
 {
     bool result;
     if (handle == NULL)
     {
         /* Codes_SRS_MQTTMESSAGE_07_016: [If handle is NULL then mqttmessage_getIsDuplicateMsg shall return false.] */
-        LogError("Invalid Parameter handle: %p.", handle);
+        printf("Invalid Parameter handle: %p.", handle);
         result = false;
     }
     else
@@ -241,13 +239,13 @@
     return result;
 }
 
-bool mqttmessage_getIsRetained(MQTT_MESSAGE_HANDLE handle)
+bool  ICACHE_FLASH_ATTR mqttmessage_getIsRetained(MQTT_MESSAGE_HANDLE handle)
 {
     bool result;
     if (handle == NULL)
     {
         /* Codes_SRS_MQTTMESSAGE_07_018: [If handle is NULL then mqttmessage_getIsRetained shall return false.] */
-        LogError("Invalid Parameter handle: %p.", handle);
+        printf("Invalid Parameter handle: %p.", handle);
         result = false;
     }
     else
@@ -259,13 +257,13 @@
     return result;
 }
 
-int mqttmessage_setIsDuplicateMsg(MQTT_MESSAGE_HANDLE handle, bool duplicateMsg)
+int  ICACHE_FLASH_ATTR mqttmessage_setIsDuplicateMsg(MQTT_MESSAGE_HANDLE handle, bool duplicateMsg)
 {
     int result;
     /* Codes_SRS_MQTTMESSAGE_07_022: [If handle is NULL then mqttmessage_setIsDuplicateMsg shall return a non-zero value.] */
     if (handle == NULL)
     {
-        LogError("Invalid Parameter handle: %p.", handle);
+        printf("Invalid Parameter handle: %p.", handle);
         result = __FAILURE__;
     }
     else
@@ -278,13 +276,13 @@
     return result;
 }
 
-int mqttmessage_setIsRetained(MQTT_MESSAGE_HANDLE handle, bool retainMsg)
+int ICACHE_FLASH_ATTR  mqttmessage_setIsRetained(MQTT_MESSAGE_HANDLE handle, bool retainMsg)
 {
     int result;
     /* Codes_SRS_MQTTMESSAGE_07_024: [If handle is NULL then mqttmessage_setIsRetained shall return a non-zero value.] */
     if (handle == NULL)
     {
-        LogError("Invalid Parameter handle: %p.", handle);
+        printf("Invalid Parameter handle: %p.", handle);
         result = __FAILURE__;
     }
     else
@@ -297,13 +295,13 @@
     return result;
 }
 
-const APP_PAYLOAD* mqttmessage_getApplicationMsg(MQTT_MESSAGE_HANDLE handle)
+const APP_PAYLOAD*  ICACHE_FLASH_ATTR mqttmessage_getApplicationMsg(MQTT_MESSAGE_HANDLE handle)
 {
     const APP_PAYLOAD* result;
     if (handle == NULL)
     {
         /* Codes_SRS_MQTTMESSAGE_07_020: [If handle is NULL or if msgLen is 0 then mqttmessage_getApplicationMsg shall return NULL.] */
-        LogError("Invalid Parameter handle: %p.", handle);
+        printf("Invalid Parameter handle: %p.", handle);
         result = NULL;
     }
     else
diff -uNr src/optionhandler.c src_ok/optionhandler.c
--- src/optionhandler.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/optionhandler.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,11 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdlib.h>
-#include "azure_c_shared_utility/optionhandler.h"
-#include "azure_c_shared_utility/xlogging.h"
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/vector.h"
+#include "esp_types.h"
+#include "optionhandler.h"
+#include "xlogging.h"
+#include "vector.h"
 
 typedef struct OPTION_TAG
 {
@@ -21,7 +20,7 @@
     VECTOR_HANDLE storage;
 }OPTIONHANDLER_HANDLE_DATA;
 
-static OPTIONHANDLER_HANDLE CreateInternal(pfCloneOption cloneOption, pfDestroyOption destroyOption, pfSetOption setOption)
+static OPTIONHANDLER_HANDLE ICACHE_FLASH_ATTR  CreateInternal(pfCloneOption cloneOption, pfDestroyOption destroyOption, pfSetOption setOption)
 {
     OPTIONHANDLER_HANDLE result;
 
@@ -29,7 +28,7 @@
     if (result == NULL)
     {
         /*Codes_SRS_OPTIONHANDLER_02_004: [ Otherwise, OptionHandler_Create shall fail and return NULL. ]*/
-        LogError("unable to malloc");
+        printf("unable to malloc");
         /*return as is*/
     }
     else
@@ -39,7 +38,7 @@
         if (result->storage == NULL)
         {
             /*Codes_SRS_OPTIONHANDLER_02_004: [ Otherwise, OptionHandler_Create shall fail and return NULL. ]*/
-            LogError("unable to VECTOR_create");
+            printf("unable to VECTOR_create");
             free(result);
             result = NULL;
         }
@@ -56,14 +55,14 @@
     return result;
 }
 
-static OPTIONHANDLER_RESULT AddOptionInternal(OPTIONHANDLER_HANDLE handle, const char* name, const void* value)
+static OPTIONHANDLER_RESULT  ICACHE_FLASH_ATTR AddOptionInternal(OPTIONHANDLER_HANDLE handle, const char* name, const void* value)
 {
     OPTIONHANDLER_RESULT result;
     const char* cloneOfName;
     if (mallocAndStrcpy_s((char**)&cloneOfName, name) != 0)
     {
         /*Codes_SRS_OPTIONHANDLER_02_009: [ Otherwise, OptionHandler_AddProperty shall succeed and return OPTIONHANDLER_ERROR. ]*/
-        LogError("unable to clone name");
+        printf("unable to clone name");
         result = OPTIONHANDLER_ERROR;
     }
     else
@@ -73,7 +72,7 @@
         if (cloneOfValue == NULL)
         {
             /*Codes_SRS_OPTIONHANDLER_02_009: [ Otherwise, OptionHandler_AddProperty shall succeed and return OPTIONHANDLER_ERROR. ]*/
-            LogError("unable to clone value");
+            printf("unable to clone value");
             free((void*)cloneOfName);
             result = OPTIONHANDLER_ERROR;
         }
@@ -86,7 +85,7 @@
             if (VECTOR_push_back(handle->storage, &temp, 1) != 0)
             {
                 /*Codes_SRS_OPTIONHANDLER_02_009: [ Otherwise, OptionHandler_AddProperty shall succeed and return OPTIONHANDLER_ERROR. ]*/
-                LogError("unable to VECTOR_push_back");
+                printf("unable to VECTOR_push_back");
                 handle->destroyOption(name, cloneOfValue);
                 free((void*)cloneOfName);
                 result = OPTIONHANDLER_ERROR;
@@ -102,7 +101,7 @@
     return result;
 }
 
-static void DestroyInternal(OPTIONHANDLER_HANDLE handle)
+static void ICACHE_FLASH_ATTR  DestroyInternal(OPTIONHANDLER_HANDLE handle)
 {
     /*Codes_SRS_OPTIONHANDLER_02_016: [ Otherwise, OptionHandler_Destroy shall free all used resources. ]*/
     size_t nOptions = VECTOR_size(handle->storage), i;
@@ -117,7 +116,7 @@
     free(handle);
 }
 
-OPTIONHANDLER_HANDLE OptionHandler_Create(pfCloneOption cloneOption, pfDestroyOption destroyOption, pfSetOption setOption)
+OPTIONHANDLER_HANDLE ICACHE_FLASH_ATTR  OptionHandler_Create(pfCloneOption cloneOption, pfDestroyOption destroyOption, pfSetOption setOption)
 {
     /*Codes_SRS_OPTIONHANDLER_02_001: [ OptionHandler_Create shall fail and retun NULL if any parameters are NULL. ]*/
     OPTIONHANDLER_HANDLE_DATA* result;
@@ -127,7 +126,7 @@
         (setOption == NULL)
         )
     {
-        LogError("invalid parameter = pfCloneOption cloneOption=%p, pfDestroyOption destroyOption=%p, pfSetOption setOption=%p", cloneOption, destroyOption, setOption);
+        printf("invalid parameter = pfCloneOption cloneOption=%p, pfDestroyOption destroyOption=%p, pfSetOption setOption=%p", cloneOption, destroyOption, setOption);
         result = NULL;
     }
     else
@@ -139,14 +138,14 @@
 
 }
 
-OPTIONHANDLER_HANDLE OptionHandler_Clone(OPTIONHANDLER_HANDLE handler)
+OPTIONHANDLER_HANDLE  ICACHE_FLASH_ATTR OptionHandler_Clone(OPTIONHANDLER_HANDLE handler)
 {
     OPTIONHANDLER_HANDLE_DATA* result;
 
     if (handler == NULL)
     {
         /* Codes_SRS_OPTIONHANDLER_01_010: [ If `handler` is NULL, OptionHandler_Clone shall fail and return NULL. ]*/
-        LogError("NULL argument: handler");
+        printf("NULL argument: handler");
         result = NULL;
     }
     else
@@ -158,7 +157,7 @@
         if (result == NULL)
         {
             /* Codes_SRS_OPTIONHANDLER_01_004: [ If allocating memory fails, `OptionHandler_Clone` shall return NULL. ]*/
-            LogError("unable to create option handler");
+            printf("unable to create option handler");
         }
         else
         {
@@ -176,7 +175,7 @@
                 {
                     /* Codes_SRS_OPTIONHANDLER_01_008: [ If cloning one of the option names fails, `OptionHandler_Clone` shall return NULL. ]*/
                     /* Codes_SRS_OPTIONHANDLER_01_009: [ If cloning one of the option values fails, `OptionHandler_Clone` shall return NULL. ]*/
-                    LogError("Error cloning option %s", option->name);
+                    printf("Error cloning option %s", option->name);
                     break;
                 }
             }
@@ -192,7 +191,7 @@
     return result;
 }
 
-OPTIONHANDLER_RESULT OptionHandler_AddOption(OPTIONHANDLER_HANDLE handle, const char* name, const void* value)
+OPTIONHANDLER_RESULT ICACHE_FLASH_ATTR  OptionHandler_AddOption(OPTIONHANDLER_HANDLE handle, const char* name, const void* value)
 {
     OPTIONHANDLER_RESULT result;
     /*Codes_SRS_OPTIONHANDLER_02_001: [ OptionHandler_Create shall fail and retun NULL if any parameters are NULL. ]*/
@@ -202,7 +201,7 @@
         (value == NULL)
         )
     {
-        LogError("invalid arguments: OPTIONHANDLER_HANDLE handle=%p, const char* name=%p, void* value=%p", handle, name, value);
+        printf("invalid arguments: OPTIONHANDLER_HANDLE handle=%p, const char* name=%p, void* value=%p", handle, name, value);
         result= OPTIONHANDLER_INVALIDARG;
     }
     else
@@ -213,7 +212,7 @@
     return result;
 }
 
-OPTIONHANDLER_RESULT OptionHandler_FeedOptions(OPTIONHANDLER_HANDLE handle, void* destinationHandle)
+OPTIONHANDLER_RESULT  ICACHE_FLASH_ATTR OptionHandler_FeedOptions(OPTIONHANDLER_HANDLE handle, void* destinationHandle)
 {
     OPTIONHANDLER_RESULT result;
     /*Codes_SRS_OPTIONHANDLER_02_010: [ OptionHandler_FeedOptions shall fail and return OPTIONHANDLER_INVALIDARG if any argument is NULL. ]*/
@@ -222,7 +221,7 @@
         (destinationHandle == NULL)
         )
     {
-        LogError("invalid arguments OPTIONHANDLER_HANDLE handle=%p, void* destinationHandle=%p", handle, destinationHandle);
+        printf("invalid arguments OPTIONHANDLER_HANDLE handle=%p, void* destinationHandle=%p", handle, destinationHandle);
         result = OPTIONHANDLER_INVALIDARG;
     }
     else
@@ -235,7 +234,7 @@
             /*Codes_SRS_OPTIONHANDLER_02_012: [ OptionHandler_FeedOptions shall call for every pair of name,value setOption passing destinationHandle, name and value. ]*/
             if (handle->setOption(destinationHandle, option->name, option->storage) != 0)
             {
-                LogError("failure while trying to _SetOption");
+                printf("failure while trying to _SetOption");
                 break;
             }
         }
@@ -254,12 +253,12 @@
     return result;
 }
 
-void OptionHandler_Destroy(OPTIONHANDLER_HANDLE handle)
+void  ICACHE_FLASH_ATTR OptionHandler_Destroy(OPTIONHANDLER_HANDLE handle)
 {   
     /*Codes_SRS_OPTIONHANDLER_02_015: [ OptionHandler_Destroy shall do nothing if parameter handle is NULL. ]*/
     if (handle == NULL)
     {
-        LogError("invalid argument OPTIONHANDLER_HANDLE handle=%p", handle);
+        printf("invalid argument OPTIONHANDLER_HANDLE handle=%p", handle);
     }
     else
     {
diff -uNr src/platform_mbedtls_compact.c src_ok/platform_mbedtls_compact.c
--- src/platform_mbedtls_compact.c	1970-01-01 08:00:00.000000000 +0800
+++ src_ok/platform_mbedtls_compact.c	2018-09-03 16:45:36.000000000 +0800
@@ -0,0 +1,75 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#include "esp_types.h"
+#include "inc/platform.h"
+#include "sntp.h"
+#include "tlsio_mbedtls.h"
+#include "xlogging.h"
+
+static char * ntpServer = "pool.ntp.org";
+os_timer_t sntp_timer;
+
+int SNTP_SetServerName(const char* serverName);
+int SNTP_Init();
+void SNTP_Deinit();
+
+
+void user_start_ntp(void *arg)
+{
+    SNTP_OK_CB cb = (SNTP_OK_CB)arg;
+    uint32 current_stamp;
+
+    current_stamp = sntp_get_current_timestamp();
+
+    if (current_stamp == 0) {
+        printf("try get ntp again..\n");
+    } else {
+        printf("init ntp successfully! ts: %d\n", current_stamp);
+        os_timer_disarm(&sntp_timer);
+        cb();
+    }
+}
+
+/* Codes_SRS_PLATFORM_OPENSSL_COMPACT_30_004: [ The platform_init shall initialize the tlsio adapter. ] */
+/* Codes_SRS_PLATFORM_OPENSSL_COMPACT_30_005: [ The platform_init shall initialize the sntp client. ] */
+int ICACHE_FLASH_ATTR  platform_init(SNTP_OK_CB cb)
+{
+    printf("==> platform_init\n");
+	// SNTP_SetServerName logs any necessary errors
+	int result;
+    sntp_setservername(0, ntpServer);
+    
+	sntp_init();
+
+    os_timer_disarm(&sntp_timer);
+    os_timer_setfn(&sntp_timer, (os_timer_func_t *)user_start_ntp, cb);
+    os_timer_arm(&sntp_timer, 1000, 1);
+
+    
+    system_update_cpu_freq(160);
+    
+    return 0;
+}
+
+const IO_INTERFACE_DESCRIPTION* tlsio_pal_get_interface_description(void);
+
+/* Codes_SRS_PLATFORM_OPENSSL_COMPACT_30_008: [ The platform_get_default_tlsio shall return a set of tlsio functions provided by the OpenSSL micro tlsio implementation. ] */
+const IO_INTERFACE_DESCRIPTION* platform_get_default_tlsio(void)
+{
+    return tlsio_pal_get_interface_description();
+}
+
+STRING_HANDLE platform_get_platform_info(void)
+{
+    return STRING_construct("(openssl_compact)");
+}
+
+/* Codes_SRS_PLATFORM_OPENSSL_COMPACT_30_006: [ The platform_deinit shall deinitialize the sntp client. ] */
+/* Codes_SRS_PLATFORM_OPENSSL_COMPACT_30_007: [ The platform_deinit shall deinitialize the tlsio adapter. ] */
+void platform_deinit(void)
+{
+	sntp_stop();
+
+	// The tlsio adapter for this platform does not need (or support) deinitialization
+}
diff -uNr src/singlylinkedlist.c src_ok/singlylinkedlist.c
--- src/singlylinkedlist.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/singlylinkedlist.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,11 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdlib.h>
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/singlylinkedlist.h"
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/xlogging.h"
+#include "esp_types.h"
+#include "singlylinkedlist.h"
+#include "xlogging.h"
 
 typedef struct LIST_ITEM_INSTANCE_TAG
 {
@@ -19,7 +17,7 @@
     LIST_ITEM_INSTANCE* tail;
 } LIST_INSTANCE;
 
-SINGLYLINKEDLIST_HANDLE singlylinkedlist_create(void)
+SINGLYLINKEDLIST_HANDLE  ICACHE_FLASH_ATTR singlylinkedlist_create(void)
 {
     LIST_INSTANCE* result;
 
@@ -35,7 +33,7 @@
     return result;
 }
 
-void singlylinkedlist_destroy(SINGLYLINKEDLIST_HANDLE list)
+void  ICACHE_FLASH_ATTR singlylinkedlist_destroy(SINGLYLINKEDLIST_HANDLE list)
 {
     /* Codes_SRS_LIST_01_004: [If the list argument is NULL, no freeing of resources shall occur.] */
     if (list != NULL)
@@ -54,7 +52,7 @@
     }
 }
 
-LIST_ITEM_HANDLE singlylinkedlist_add(SINGLYLINKEDLIST_HANDLE list, const void* item)
+LIST_ITEM_HANDLE ICACHE_FLASH_ATTR  singlylinkedlist_add(SINGLYLINKEDLIST_HANDLE list, const void* item)
 {
     LIST_ITEM_INSTANCE* result;
 
@@ -62,7 +60,7 @@
     if ((list == NULL) ||
         (item == NULL))
     {
-        LogError("Invalid argument (list=%p, item=%p)", list, item);
+        printf("Invalid argument (list=%p, item=%p)", list, item);
         result = NULL;
     }
     else
@@ -97,7 +95,7 @@
     return result;
 }
 
-int singlylinkedlist_remove(SINGLYLINKEDLIST_HANDLE list, LIST_ITEM_HANDLE item)
+int ICACHE_FLASH_ATTR  singlylinkedlist_remove(SINGLYLINKEDLIST_HANDLE list, LIST_ITEM_HANDLE item)
 {
     int result;
 
@@ -105,7 +103,7 @@
     if ((list == NULL) ||
         (item == NULL))
     {
-        LogError("Invalid argument (list=%p, item=%p)", list, item);
+        printf("Invalid argument (list=%p, item=%p)", list, item);
         result = __FAILURE__;
     }
     else
@@ -156,14 +154,14 @@
     return result;
 }
 
-LIST_ITEM_HANDLE singlylinkedlist_get_head_item(SINGLYLINKEDLIST_HANDLE list)
+LIST_ITEM_HANDLE ICACHE_FLASH_ATTR  singlylinkedlist_get_head_item(SINGLYLINKEDLIST_HANDLE list)
 {
     LIST_ITEM_HANDLE result;
     
     if (list == NULL)
     {
         /* Codes_SRS_LIST_01_009: [If the list argument is NULL, singlylinkedlist_get_head_item shall return NULL.] */
-        LogError("Invalid argument (list=NULL)");
+        printf("Invalid argument (list=NULL)");
         result = NULL;
     }
     else
@@ -178,13 +176,13 @@
     return result;
 }
 
-LIST_ITEM_HANDLE singlylinkedlist_get_next_item(LIST_ITEM_HANDLE item_handle)
+LIST_ITEM_HANDLE  ICACHE_FLASH_ATTR singlylinkedlist_get_next_item(LIST_ITEM_HANDLE item_handle)
 {
     LIST_ITEM_HANDLE result;
 
     if (item_handle == NULL)
     {
-        LogError("Invalid argument (list is NULL)");
+        printf("Invalid argument (list is NULL)");
         /* Codes_SRS_LIST_01_019: [If item_handle is NULL then singlylinkedlist_get_next_item shall return NULL.] */
         result = NULL;
     }
@@ -197,13 +195,13 @@
     return result;
 }
 
-const void* singlylinkedlist_item_get_value(LIST_ITEM_HANDLE item_handle)
+const void* ICACHE_FLASH_ATTR  singlylinkedlist_item_get_value(LIST_ITEM_HANDLE item_handle)
 {
     const void* result;
 
     if (item_handle == NULL)
     {
-        LogError("Invalid argument (item_handle is NULL)");
+        printf("Invalid argument (item_handle is NULL)");
         /* Codes_SRS_LIST_01_021: [If item_handle is NULL, singlylinkedlist_item_get_value shall return NULL.] */
         result = NULL;
     }
@@ -216,14 +214,14 @@
     return result;
 }
 
-LIST_ITEM_HANDLE singlylinkedlist_find(SINGLYLINKEDLIST_HANDLE list, LIST_MATCH_FUNCTION match_function, const void* match_context)
+LIST_ITEM_HANDLE ICACHE_FLASH_ATTR  singlylinkedlist_find(SINGLYLINKEDLIST_HANDLE list, LIST_MATCH_FUNCTION match_function, const void* match_context)
 {
     LIST_ITEM_HANDLE result;
 
     if ((list == NULL) ||
         (match_function == NULL))
     {
-        LogError("Invalid argument (list=%p, match_function=%p)", list, match_function);
+        printf("Invalid argument (list=%p, match_function=%p)", list, match_function);
         /* Codes_SRS_LIST_01_012: [If the list or the match_function argument is NULL, singlylinkedlist_find shall return NULL.] */
         result = NULL;
     }
@@ -261,14 +259,14 @@
     return result;
 }
 
-int singlylinkedlist_remove_if(SINGLYLINKEDLIST_HANDLE list, LIST_CONDITION_FUNCTION condition_function, const void* match_context)
+int  ICACHE_FLASH_ATTR singlylinkedlist_remove_if(SINGLYLINKEDLIST_HANDLE list, LIST_CONDITION_FUNCTION condition_function, const void* match_context)
 {
     int result;
     /* Codes_SRS_LIST_09_001: [ If the list or the condition_function argument is NULL, singlylinkedlist_remove_if shall return non-zero value. ] */
     if ((list == NULL) ||
         (condition_function == NULL))
     {
-        LogError("Invalid argument (list=%p, condition_function=%p)", list, condition_function);
+        printf("Invalid argument (list=%p, condition_function=%p)", list, condition_function);
         result = __FAILURE__;
     }
     else
@@ -327,7 +325,7 @@
     return result;
 }
 
-int singlylinkedlist_foreach(SINGLYLINKEDLIST_HANDLE list, LIST_ACTION_FUNCTION action_function, const void* action_context)
+int  ICACHE_FLASH_ATTR singlylinkedlist_foreach(SINGLYLINKEDLIST_HANDLE list, LIST_ACTION_FUNCTION action_function, const void* action_context)
 {
     int result;
 
@@ -335,7 +333,7 @@
     if ((list == NULL) ||
         (action_function == NULL))
     {
-        LogError("Invalid argument (list=%p, action_function=%p)", list, action_function);
+        printf("Invalid argument (list=%p, action_function=%p)", list, action_function);
         result = __FAILURE__;
     }
     else
diff -uNr src/sntp_lwip.c src_ok/sntp_lwip.c
--- src/sntp_lwip.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/sntp_lwip.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,31 +1,17 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include "azure_c_shared_utility/xlogging.h"
+#include "xlogging.h"
 
 /*Codes_SRS_SNTP_LWIP_30_001: [ The ntp_lwip shall implement the methods defined in sntp.h. ]*/
 #include "sntp.h"
-#include "azure_c_shared_utility/threadapi.h"
-#include "azure_c_shared_utility/agenttime.h"
-#include "sntp_os.h"
-
-
-/*Codes_SRS_SNTP_LWIP_30_002: [ The serverName parameter shall be an NTP server URL which shall not be validated. ]*/
-/*Codes_SRS_SNTP_LWIP_30_003: [ The SNTP_SetServerName shall set the NTP server to be used by ntp_lwip and return 0 to indicate success.]*/
-//
-// SNTP_SetServerName must be called before `SNTP_Init`. 
-// The character array pointed to by `serverName` parameter must persist 
-// between calls to `SNTP_SetServerName` and `SNTP_Deinit` because the 
-// char* is stored and no copy of the string is made.
-//
-// SNTP_SetServerName is a wrapper for the lwIP call `sntp_setservername` 
-// and defers parameter validation to the lwIP library.
-//
-// Future implementations of this adapter may allow multiple calls to 
-// SNTP_SetServerName in order to support multiple servers.
-//
-int SNTP_SetServerName(const char* serverName)
+#include "threadapi.h"
+#include "agenttime.h"
+
+
+int  ICACHE_FLASH_ATTR SNTP_SetServerName(const char* serverName)
 {
+	printf("==> SNTP_SetServerName\n");
 	// Future implementations could easily allow multiple calls to SNTP_SetServerName
 	// by incrementing the index supplied to sntp_setservername
 	sntp_setservername(0, (char*)serverName);
@@ -33,25 +19,25 @@
 }
 
 /*Codes_SRS_SNTP_LWIP_30_004: [ SNTP_Init shall initialize the SNTP client, contact the NTP server to set system time, then return 0 to indicate success (lwIP has no failure path). ]*/
-int SNTP_Init()
+int  ICACHE_FLASH_ATTR SNTP_Init()
 {
-	LogInfo("Initializing SNTP");
-	sntp_setoperatingmode(SNTP_OPMODE_POLL);
+	printf("Initializing SNTP\n");
 	sntp_init();
-	time_t ts = 0;
-	// Before 1980 is uninitialized
-	while (ts < 10 * 365 * 24 * 3600)
-	{
+	uint32 current_stamp;
+	
+	do {
+		printf("wait 1s ...\n");
 		ThreadAPI_Sleep(1000);
-		ts = get_time(NULL);
-
-	}
-	LogInfo("SNTP initialization complete");
+		current_stamp = sntp_get_current_timestamp();
+	} while (current_stamp == 0);
+	
+	printf("SNTP initialization complete");
+	printf("sntp: %d, %s \n",current_stamp, sntp_get_real_time(current_stamp));
 	return 0;
 }
 
 /*Codes_SRS_SNTP_LWIP_30_005: [ SNTP_Denit shall deinitialize the SNTP client. ]*/
-void SNTP_Deinit()
+void  ICACHE_FLASH_ATTR SNTP_Deinit()
 {
 	sntp_stop();
 }
diff -uNr src/socketio_lwip.c src_ok/socketio_lwip.c
--- src/socketio_lwip.c	1970-01-01 08:00:00.000000000 +0800
+++ src_ok/socketio_lwip.c	2018-09-03 16:45:36.000000000 +0800
@@ -0,0 +1,671 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+#include "esp_types.h"
+#include "time.h"
+#include "socketio.h"
+#include "lwip/app/espconn.h"
+
+#include "singlylinkedlist.h"
+#include "optionhandler.h"
+#include "shared_util_options.h"
+#include "xlogging.h"
+#include "const_defines.h"
+#include "vector_types.h"
+
+// connect timeout in seconds
+#define CONNECT_TIMEOUT         10
+#define RECEIVE_BYTES_VALUE     64
+
+
+typedef enum IO_STATE_TAG
+{
+    IO_STATE_CLOSED,
+    IO_STATE_OPENING,
+    IO_STATE_OPEN,
+    IO_STATE_CLOSING,
+    IO_STATE_ERROR
+} IO_STATE;
+
+typedef struct SINGLYLINKEDLIST_INSTANCE_TAG* SINGLYLINKEDLIST_HANDLE;
+
+typedef struct PENDING_SOCKET_IO_TAG
+{
+    unsigned char* bytes;
+    size_t size;
+    ON_SEND_COMPLETE on_send_complete;
+    void* callback_context;
+    SINGLYLINKEDLIST_HANDLE pending_io_list;
+} PENDING_SOCKET_IO;
+
+typedef struct SOCKET_IO_INSTANCE_TAG
+{
+    int socket;
+    ON_BYTES_RECEIVED on_bytes_received;
+    ON_IO_ERROR on_io_error;
+    void* on_bytes_received_context;
+    void* on_io_error_context;
+    char* hostname;
+    int port;
+    char* target_mac_address;
+    IO_STATE io_state;
+    SINGLYLINKEDLIST_HANDLE pending_io_list;
+    unsigned char recv_bytes[RECEIVE_BYTES_VALUE];
+} SOCKET_IO_INSTANCE;
+
+typedef struct NETWORK_INTERFACE_DESCRIPTION_TAG
+{
+    char* name;
+    char* mac_address;
+    char* ip_address;
+    struct NETWORK_INTERFACE_DESCRIPTION_TAG* next;
+} NETWORK_INTERFACE_DESCRIPTION;
+
+
+/*this function will clone an option given by name and value*/
+static void*  ICACHE_FLASH_ATTR socketio_CloneOption(const char* name, const void* value)
+{
+    void* result;
+
+    if (name != NULL)
+    {
+        result = NULL;
+
+        if (strcmp(name, OPTION_NET_INT_MAC_ADDRESS) == 0)
+        {
+            if (value == NULL)
+            {
+                printf("Failed cloning option %s (value is NULL)", name);
+            }
+            else
+            {
+                if ((result = (void*)malloc(sizeof(char) * (strlen((char*)value) + 1))) == NULL)
+                {
+                    printf("Failed cloning option %s (malloc failed)", name);
+                }
+                else if (strcpy((char*)result, (char*)value) == NULL)
+                {
+                    printf("Failed cloning option %s (strcpy failed)", name);
+                    free(result);
+                    result = NULL;
+                }
+            }
+        }
+        else
+        {
+            printf("Cannot clone option %s (not suppported)", name);
+        }
+    }
+    else
+    {
+        result = NULL;
+    }
+    return result;
+}
+
+/*this function destroys an option previously created*/
+static void  ICACHE_FLASH_ATTR socketio_DestroyOption(const char* name, const void* value)
+{
+    if (name != NULL)
+    {
+        if (strcmp(name, OPTION_NET_INT_MAC_ADDRESS) == 0 && value != NULL)
+        {
+            free((void*)value);
+        }
+    }
+}
+
+
+
+static OPTIONHANDLER_HANDLE  ICACHE_FLASH_ATTR socketio_retrieveoptions(CONCRETE_IO_HANDLE handle)
+{
+    OPTIONHANDLER_HANDLE result;
+
+    if (handle == NULL)
+    {
+        printf("failed retrieving options (handle is NULL)");
+        result = NULL;
+    }
+    else
+    {
+        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)handle;
+
+        result = OptionHandler_Create(socketio_CloneOption, socketio_DestroyOption, socketio_setoption);
+        if (result == NULL)
+        {
+            printf("unable to OptionHandler_Create");
+        }
+        else if (socket_io_instance->target_mac_address != NULL &&
+            OptionHandler_AddOption(result, OPTION_NET_INT_MAC_ADDRESS, socket_io_instance->target_mac_address) != OPTIONHANDLER_OK)
+        {
+            printf("failed retrieving options (failed adding net_interface_mac_address)");
+            OptionHandler_Destroy(result);
+            result = NULL;
+        }
+    }
+
+    return result;
+}
+
+
+static void  ICACHE_FLASH_ATTR indicate_error(SOCKET_IO_INSTANCE* socket_io_instance)
+{
+    if (socket_io_instance->on_io_error != NULL)
+    {
+        socket_io_instance->on_io_error(socket_io_instance->on_io_error_context);
+    }
+}
+
+
+
+
+static int ICACHE_FLASH_ATTR  add_pending_io(SOCKET_IO_INSTANCE* socket_io_instance, const unsigned char* buffer, size_t size, ON_SEND_COMPLETE on_send_complete, void* callback_context)
+{
+    int result;
+    PENDING_SOCKET_IO* pending_socket_io = (PENDING_SOCKET_IO*)malloc(sizeof(PENDING_SOCKET_IO));
+    if (pending_socket_io == NULL)
+    {
+        result = __FAILURE__;
+    }
+    else
+    {
+        pending_socket_io->bytes = (unsigned char*)malloc(size);
+        if (pending_socket_io->bytes == NULL)
+        {
+            printf("Allocation Failure: Unable to allocate pending list.");
+            free(pending_socket_io);
+            result = __FAILURE__;
+        }
+        else
+        {
+            pending_socket_io->size = size;
+            pending_socket_io->on_send_complete = on_send_complete;
+            pending_socket_io->callback_context = callback_context;
+            pending_socket_io->pending_io_list = socket_io_instance->pending_io_list;
+            (void)memcpy(pending_socket_io->bytes, buffer, size);
+
+            if (singlylinkedlist_add(socket_io_instance->pending_io_list, pending_socket_io) == NULL)
+            {
+                printf("Failure: Unable to add socket to pending list.");
+                free(pending_socket_io->bytes);
+                free(pending_socket_io);
+                result = __FAILURE__;
+            }
+            else
+            {
+                result = 0;
+            }
+        }
+    }
+    return result;
+}
+
+static STATIC_VAR_UNUSED void ICACHE_FLASH_ATTR  signal_callback(int signum)
+{
+    AZURE_UNREFERENCED_PARAMETER(signum);
+    printf("Socket received signal %d.", signum);
+}
+
+extern SOCKET_IO_INSTANCE* g_socket_io_instance;
+
+CONCRETE_IO_HANDLE ICACHE_FLASH_ATTR  socketio_create(void* io_create_parameters)
+{
+    printf("==> socketio_create\n");
+    SOCKETIO_CONFIG* socket_io_config = io_create_parameters;
+    SOCKET_IO_INSTANCE* result;
+
+    if (socket_io_config == NULL)
+    {
+        printf("Invalid argument: socket_io_config is NULL");
+        result = NULL;
+    }
+    else
+    {
+        result = (void*)malloc(sizeof(SOCKET_IO_INSTANCE));
+        if (result != NULL)
+        {
+            result->pending_io_list = singlylinkedlist_create();
+            if (result->pending_io_list == NULL)
+            {
+                printf("Failure: singlylinkedlist_create unable to create pending list.");
+                free(result);
+                result = NULL;
+            }
+            else
+            {
+                if (socket_io_config->hostname != NULL)
+                {
+                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);
+                    if (result->hostname != NULL)
+                    {
+                        (void)strcpy(result->hostname, socket_io_config->hostname);
+                    }
+
+                }
+                else
+                {
+                    result->hostname = NULL;
+                    result->socket = *((int*)socket_io_config->accepted_socket);
+                }
+
+                if (result->hostname == NULL)
+                {
+                    printf("Failure: hostname == NULL and socket is invalid.");
+                    singlylinkedlist_destroy(result->pending_io_list);
+                    free(result);
+                    result = NULL;
+                }
+                else
+                {
+                    result->port = socket_io_config->port;
+                    result->target_mac_address = NULL;
+                    result->on_bytes_received = NULL;
+                    result->on_io_error = NULL;
+                    result->on_bytes_received_context = NULL;
+                    result->on_io_error_context = NULL;
+                    result->io_state = IO_STATE_CLOSED;
+                    printf("hostname: %s, port: %d\n", result->hostname, result->port);
+                    g_socket_io_instance = result;
+                }
+            }
+        }
+        else
+        {
+            printf("Allocation Failure: SOCKET_IO_INSTANCE");
+        }
+    }
+
+    return result;
+}
+
+void  ICACHE_FLASH_ATTR socketio_destroy(CONCRETE_IO_HANDLE socket_io)
+{
+    if (socket_io != NULL)
+    {
+        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;
+        
+
+        /* clear allpending IOs */
+        LIST_ITEM_HANDLE first_pending_io = singlylinkedlist_get_head_item(socket_io_instance->pending_io_list);
+        while (first_pending_io != NULL)
+        {
+            PENDING_SOCKET_IO* pending_socket_io = (PENDING_SOCKET_IO*)singlylinkedlist_item_get_value(first_pending_io);
+            if (pending_socket_io != NULL)
+            {
+                free(pending_socket_io->bytes);
+                free(pending_socket_io);
+            }
+
+            (void)singlylinkedlist_remove(socket_io_instance->pending_io_list, first_pending_io);
+            first_pending_io = singlylinkedlist_get_head_item(socket_io_instance->pending_io_list);
+        }
+
+        singlylinkedlist_destroy(socket_io_instance->pending_io_list);
+        free(socket_io_instance->hostname);
+        free(socket_io_instance->target_mac_address);
+        free(socket_io);
+    }
+}
+
+static os_timer_t user_dns_timer;
+static struct espconn user_tcp_conn;
+static struct _esp_tcp user_tcp;
+static ip_addr_t tcp_server_ip;
+
+ON_IO_OPEN_COMPLETE g_on_io_open_complete;
+void* g_on_io_open_complete_context;
+
+SOCKET_IO_INSTANCE* g_socket_io_instance;
+
+static void  ICACHE_FLASH_ATTR data_received( void *arg, char *pdata, unsigned short len )
+{
+    struct espconn *conn = arg;
+    
+    printf("mem: %d\n", system_get_free_heap_size());
+    os_printf( "%s: %s\n", __FUNCTION__, pdata );
+    g_socket_io_instance->on_bytes_received(g_socket_io_instance->on_bytes_received_context, pdata, len);
+}
+
+
+
+static void  ICACHE_FLASH_ATTR tcp_connected( void *arg )
+{
+    struct espconn *conn = arg;
+    
+    os_printf( "%s\n", __FUNCTION__ );
+    os_printf("mem: %d\n", system_get_free_heap_size());
+    espconn_regist_recvcb( conn, data_received );
+
+	g_socket_io_instance->io_state = IO_STATE_OPEN;
+
+    if (g_on_io_open_complete != NULL)
+    {
+        g_on_io_open_complete(g_on_io_open_complete_context, IO_OPEN_OK);
+    }
+}
+
+static void  ICACHE_FLASH_ATTR tcp_disconnected( void *arg )
+{
+    struct espconn *conn = arg;
+    
+    os_printf( "%s\n", __FUNCTION__ );
+    //espconn_regist_recvcb( conn, data_received );
+
+    //todo ...
+}
+
+
+static void ICACHE_FLASH_ATTR  dns_done( const char *name, ip_addr_t *ipaddr, void *arg )
+{
+    struct espconn *conn = arg;
+    
+    os_printf( "%s\n", __FUNCTION__ );
+    
+    if ( ipaddr == NULL) 
+    {
+        os_printf("DNS lookup failed\n");
+        wifi_station_disconnect();
+    }
+    else
+    {
+        os_printf("got DNS IP!!!\n");
+        
+        os_memcpy( conn->proto.tcp->remote_ip, &ipaddr->addr, 4 );
+		tcp_server_ip.addr = ipaddr->addr;
+
+        printf("connecting svr...\n");
+        espconn_regist_connectcb( conn, tcp_connected );
+        espconn_regist_disconcb( conn, tcp_disconnected );
+        espconn_connect( conn );
+
+    }
+}
+
+static void ICACHE_FLASH_ATTR user_tcp_sent_cb(void *arg)
+{
+    struct espconn *pespconn = arg;
+    signed char ret;
+    printf("==> user_tcp_sent_cb!!!!\n");
+
+    LIST_ITEM_HANDLE first_pending_io = singlylinkedlist_get_head_item(g_socket_io_instance->pending_io_list);
+    if (first_pending_io) {
+        PENDING_SOCKET_IO* pending_socket_io = (PENDING_SOCKET_IO*)singlylinkedlist_item_get_value(first_pending_io);
+        if (!pending_socket_io) {
+            printf("singlylinkedlist_item_get_value error\n");
+        }
+        ret = espconn_send(&user_tcp_conn, pending_socket_io->bytes, pending_socket_io->size);
+        if (ret != 0) {
+            printf("espconn_send error\n");
+            return;
+        }
+        if (pending_socket_io->on_send_complete != NULL) {
+            pending_socket_io->on_send_complete(pending_socket_io->callback_context, IO_SEND_OK);
+        }
+
+        free(pending_socket_io->bytes);
+        free(pending_socket_io);
+        if (singlylinkedlist_remove(g_socket_io_instance->pending_io_list, first_pending_io) != 0) {
+            g_socket_io_instance->io_state = IO_STATE_ERROR;
+            indicate_error(g_socket_io_instance);
+            printf("Failure: unable to remove socket from list\n");
+        }
+    } else {
+        printf("sendint pipe is empty!\n");
+    }
+}
+
+int  ICACHE_FLASH_ATTR socketio_open(CONCRETE_IO_HANDLE socket_io, ON_IO_OPEN_COMPLETE on_io_open_complete, void* on_io_open_complete_context, ON_BYTES_RECEIVED on_bytes_received, void* on_bytes_received_context, ON_IO_ERROR on_io_error, void* on_io_error_context)
+{
+    int result = 0;
+    int retval = -1;
+    int select_errno = 0;
+    int err;
+
+    printf("==> socketio_open\n");
+    SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;
+    if (socket_io == NULL)
+    {
+        printf("Invalid argument: SOCKET_IO_INSTANCE is NULL");
+        result = __FAILURE__;
+    }
+    else
+    {
+        if (socket_io_instance->io_state != IO_STATE_CLOSED)
+        {
+            printf("Failure: socket state is not closed.");
+            result = __FAILURE__;
+        }
+        else
+        {
+            printf("creating espconn...\n");
+            tcp_server_ip.addr = 0;
+            memcpy(user_tcp.remote_ip, &tcp_server_ip.addr, 4);
+            user_tcp.remote_port = socket_io_instance->port;
+            user_tcp.local_port = espconn_port();
+
+			user_tcp_conn.type = ESPCONN_TCP;
+			user_tcp_conn.state = ESPCONN_NONE;
+			user_tcp_conn.proto.tcp = &user_tcp;
+
+            printf("espconn_gethostbyname\n");
+			espconn_gethostbyname( &user_tcp_conn, socket_io_instance->hostname, &tcp_server_ip, dns_done );
+			
+			socket_io_instance->on_bytes_received = on_bytes_received;
+			socket_io_instance->on_bytes_received_context = on_bytes_received_context;
+			socket_io_instance->on_io_error = on_io_error;
+			socket_io_instance->on_io_error_context = on_io_error_context;
+
+            g_on_io_open_complete = on_io_open_complete;
+            g_on_io_open_complete_context = on_io_open_complete_context;
+
+            // sent cb
+            espconn_regist_sentcb(&user_tcp_conn, user_tcp_sent_cb);
+
+			result = 0;
+                            
+        }
+    }
+
+
+    return result;
+}
+
+int  ICACHE_FLASH_ATTR socketio_close(CONCRETE_IO_HANDLE socket_io, ON_IO_CLOSE_COMPLETE on_io_close_complete, void* callback_context)
+{
+    int result = 0;
+
+    if (socket_io == NULL)
+    {
+        result = __FAILURE__;
+    }
+    else
+    {
+        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;
+        if ((socket_io_instance->io_state != IO_STATE_CLOSED) && (socket_io_instance->io_state != IO_STATE_CLOSING))
+        {
+            espconn_disconnect( &user_tcp_conn);
+            socket_io_instance->io_state = IO_STATE_CLOSED;
+        }
+
+        if (on_io_close_complete != NULL)
+        {
+            on_io_close_complete(callback_context);
+        }
+
+        result = 0;
+    }
+
+    return result;
+}
+
+int  ICACHE_FLASH_ATTR socketio_send(CONCRETE_IO_HANDLE socket_io, const void* buffer, size_t size, ON_SEND_COMPLETE on_send_complete, void* callback_context)
+{
+    int result;
+
+    printf("==> socketio_send\n");
+    if ((socket_io == NULL) ||
+        (buffer == NULL) ||
+        (size == 0))
+    {
+        /* Invalid arguments */
+        printf("Invalid argument: send given invalid parameter");
+        result = __FAILURE__;
+    }
+    else
+    {
+        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;
+        if (socket_io_instance->io_state != IO_STATE_OPEN)
+        {
+            printf("Failure: socket state is not opened.");
+            int i;
+            for (i = 0; i < size;i ++) {
+                printf("%2x ", ((char*)buffer)[i]);
+            }
+            printf("\n");
+            result = __FAILURE__;
+        }
+        else
+        {
+            printf("add data to pending list or not?\n");
+            LIST_ITEM_HANDLE first_pending_io = singlylinkedlist_get_head_item(socket_io_instance->pending_io_list);
+            if (first_pending_io != NULL)
+            {
+                if (add_pending_io(socket_io_instance, buffer, size, on_send_complete, callback_context) != 0)
+                {
+                    printf("Failure: add_pending_io failed.");
+                    result = __FAILURE__;
+                }
+                else
+                {
+                    result = 0;
+                }
+            }
+            else
+            {
+                //signal(SIGPIPE, SIG_IGN);
+
+                printf("espconn_send!!! sz:%d\n", size);
+                signed char send_result = espconn_send( &user_tcp_conn, buffer, size);
+                if (send_result != 0)
+                {
+                    printf("1Failure: sending socket failed. %d\n", send_result);
+                    switch (send_result) {
+                    case ESPCONN_MEM:
+                        printf("ESPCONN_MEM\n");
+                        result = __FAILURE__;
+                        break;
+                    case ESPCONN_ARG:
+                        printf("ESPCONN_ARG\n");
+                        result = __FAILURE__;
+                        break;
+                    case ESPCONN_MAXNUM:
+                        //底层最多缓存 8 包等待发送完成，因此，如果发包太快，缓存已满，就会返回 -7 错误码。
+                        printf("ESPCONN_MAXNUM\n");
+                        /* queue data */
+                        if (add_pending_io(socket_io_instance, buffer, size, on_send_complete, callback_context) != 0)
+                        {
+                            printf("Failure: add_pending_io failed.");
+                        }
+                        result = 0;  // not an error
+                        break;
+                    case ESPCONN_IF:
+                        printf("ESPCONN_IF\n");
+                        result = __FAILURE__;
+                        break;
+                    default:
+                        printf("xxxxxx\n");
+                        break;
+                    }
+                    
+                }
+                else
+                {
+                    if (on_send_complete != NULL)
+                    {
+                        on_send_complete(callback_context, IO_SEND_OK);
+                    }
+
+                    result = 0;
+                }
+            }
+        }
+    }
+
+    return result;
+}
+
+void  ICACHE_FLASH_ATTR socketio_dowork(CONCRETE_IO_HANDLE socket_io)
+{
+    int result;
+
+    printf("==> socketio_dowork\n");
+    //do nothing
+}
+
+// Edison is missing this from netinet/tcp.h, but this code still works if we manually define it.
+#ifndef SOL_TCP
+#define SOL_TCP 6
+#endif
+
+
+int  ICACHE_FLASH_ATTR socketio_setoption(CONCRETE_IO_HANDLE socket_io, const char* optionName, const void* value)
+{
+    int result;
+
+    if (socket_io == NULL ||
+        optionName == NULL ||
+        value == NULL)
+    {
+        result = __FAILURE__;
+    }
+    else
+    {
+        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;
+#if 0
+        if (strcmp(optionName, "tcp_keepalive") == 0)
+        {
+            result = setsockopt(socket_io_instance->socket, SOL_SOCKET, SO_KEEPALIVE, value, sizeof(int));
+            if (result == -1) result = errno;
+        }
+        else if (strcmp(optionName, "tcp_keepalive_time") == 0)
+        {
+            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPIDLE, value, sizeof(int));
+            if (result == -1) result = errno;
+        }
+        else if (strcmp(optionName, "tcp_keepalive_interval") == 0)
+        {
+            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPINTVL, value, sizeof(int));
+            if (result == -1) result = errno;
+        }
+        else if (strcmp(optionName, OPTION_NET_INT_MAC_ADDRESS) == 0)
+        {
+            printf("option not supported.");
+            result = __FAILURE__;
+        }
+        else
+        {
+            result = __FAILURE__;
+        }
+#endif
+    }
+
+    return result;
+}
+
+
+static const IO_INTERFACE_DESCRIPTION socket_io_interface_description = 
+{
+    socketio_retrieveoptions,
+    socketio_create,
+    socketio_destroy,
+    socketio_open,
+    socketio_close,
+    socketio_send,
+    socketio_dowork,
+    socketio_setoption
+};
+
+const IO_INTERFACE_DESCRIPTION* ICACHE_FLASH_ATTR  socketio_get_interface_description(void)
+{
+    return &socket_io_interface_description;
+}
+
diff -uNr src/strings.c src_ok/strings.c
--- src/strings.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/strings.c	2018-09-03 16:45:36.000000000 +0800
@@ -4,20 +4,15 @@
 //
 // PUT NO INCLUDES BEFORE HERE
 //
-#include <stdlib.h>
-#include "azure_c_shared_utility/gballoc.h"
-#include <stddef.h>
-#include <string.h>
-#include <stdarg.h>
-#include <stdio.h>
+
 
 //
 // PUT NO CLIENT LIBRARY INCLUDES BEFORE HERE
 //
 
-#include "azure_c_shared_utility/strings.h"
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/xlogging.h"
+#include "esp_types.h"
+#include "strings.h"
+#include "xlogging.h"
 
 static const char hexToASCII[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
 
@@ -29,7 +24,7 @@
 /*this function will allocate a new string with just '\0' in it*/
 /*return NULL if it fails*/
 /* Codes_SRS_STRING_07_001: [STRING_new shall allocate a new STRING_HANDLE pointing to an empty string.] */
-STRING_HANDLE STRING_new(void)
+STRING_HANDLE  ICACHE_FLASH_ATTR STRING_new(void)
 {
     STRING* result;
     if ((result = (STRING*)malloc(sizeof(STRING))) != NULL)
@@ -41,7 +36,7 @@
         else
         {
             /* Codes_SRS_STRING_07_002: [STRING_new shall return an NULL STRING_HANDLE on any error that is encountered.] */
-            LogError("Failure allocating in STRING_new.");
+            printf("Failure allocating in STRING_new.");
             free(result);
             result = NULL;
         }
@@ -50,7 +45,7 @@
 }
 
 /*Codes_SRS_STRING_02_001: [STRING_clone shall produce a new string having the same content as the handle string.*/
-STRING_HANDLE STRING_clone(STRING_HANDLE handle)
+STRING_HANDLE  ICACHE_FLASH_ATTR STRING_clone(STRING_HANDLE handle)
 {
     STRING* result;
     /*Codes_SRS_STRING_02_002: [If parameter handle is NULL then STRING_clone shall return NULL.]*/
@@ -68,7 +63,7 @@
             size_t sourceLen = strlen(source->s);
             if ((result->s = (char*)malloc(sourceLen + 1)) == NULL)
             {
-                LogError("Failure allocating clone value.");
+                printf("Failure allocating clone value.");
                 free(result);
                 result = NULL;
             }
@@ -86,7 +81,7 @@
 }
 
 /* Codes_SRS_STRING_07_003: [STRING_construct shall allocate a new string with the value of the specified const char*.] */
-STRING_HANDLE STRING_construct(const char* psz)
+STRING_HANDLE ICACHE_FLASH_ATTR  STRING_construct(const char* psz)
 {
     STRING_HANDLE result;
     if (psz == NULL)
@@ -108,7 +103,7 @@
             /* Codes_SRS_STRING_07_032: [STRING_construct encounters any error it shall return a NULL value.] */
             else
             {
-                LogError("Failure allocating constructed value.");
+                printf("Failure allocating constructed value.");
                 free(str);
                 result = NULL;
             }
@@ -116,7 +111,7 @@
         else
         {
             /* Codes_SRS_STRING_07_032: [STRING_construct encounters any error it shall return a NULL value.] */
-            LogError("Failure allocating value.");
+            printf("Failure allocating value.");
             result = NULL;
         }
     }
@@ -126,10 +121,10 @@
 #if defined(__GNUC__)
 __attribute__ ((format (printf, 1, 2)))
 #endif
-STRING_HANDLE STRING_construct_sprintf(const char* format, ...)
+STRING_HANDLE  ICACHE_FLASH_ATTR STRING_construct_sprintf(const char* format, ...)
 {
-    STRING* result;
-    
+
+    STRING* result;  
 #ifdef STRINGS_C_SPRINTF_BUFFER_SIZE
     size_t maxBufSize = STRINGS_C_SPRINTF_BUFFER_SIZE;
     char buf[STRINGS_C_SPRINTF_BUFFER_SIZE];
@@ -162,7 +157,7 @@
                         free(result->s);
                         free(result);
                         result = NULL;
-                        LogError("Failure: vsnprintf formatting failed.");
+                        printf("Failure: vsnprintf formatting failed.");
                     }
                     va_end(arg_list);
                 }
@@ -171,12 +166,12 @@
                     /* Codes_SRS_STRING_07_040: [If any error is encountered STRING_construct_sprintf shall return NULL.] */
                     free(result);
                     result = NULL;
-                    LogError("Failure: allocation sprintf value failed.");
+                    printf("Failure: allocation sprintf value failed.");
                 }
             }
             else
             {
-                LogError("Failure: allocation failed.");
+                printf("Failure: allocation failed.");
             }
         }
         else if (length == 0)
@@ -187,15 +182,16 @@
         {
             /* Codes_SRS_STRING_07_039: [If the parameter format is NULL then STRING_construct_sprintf shall return NULL.] */
             result = NULL;
-            LogError("Failure: vsnprintf return 0 length");
+            printf("Failure: vsnprintf return 0 length");
         }
     }
     else
     {
-        LogError("Failure: invalid argument.");
+        printf("Failure: invalid argument.");
         result = NULL;
     }
     /* Codes_SRS_STRING_07_045: [STRING_construct_sprintf shall allocate a new string with the value of the specified printf formated const char. ] */
+
     return (STRING_HANDLE)result;
 }
 
@@ -203,7 +199,7 @@
 /*return NULL if it fails.*/
 /* The supplied memory must have been allocated with malloc! */
 /* Codes_SRS_STRING_07_006: [STRING_new_with_memory shall return a STRING_HANDLE by using the supplied char* memory.] */
-STRING_HANDLE STRING_new_with_memory(const char* memory)
+STRING_HANDLE  ICACHE_FLASH_ATTR STRING_new_with_memory(const char* memory)
 {
     STRING* result;
     if (memory == NULL)
@@ -219,14 +215,14 @@
         }
         else
         {
-            LogError("Failure: allocating memory string");
+            printf("Failure: allocating memory string");
         }
     }
     return (STRING_HANDLE)result;
 }
 
 /* Codes_SRS_STRING_07_008: [STRING_new_quoted shall return a valid STRING_HANDLE Copying the supplied const char* value surrounded by quotes.] */
-STRING_HANDLE STRING_new_quoted(const char* source)
+STRING_HANDLE  ICACHE_FLASH_ATTR STRING_new_quoted(const char* source)
 {
     STRING* result;
     if (source == NULL)
@@ -247,7 +243,7 @@
         else
         {
             /* Codes_SRS_STRING_07_031: [STRING_new_quoted shall return a NULL STRING_HANDLE if any error is encountered.] */
-            LogError("Failure allocating quoted string value.");
+            printf("Failure allocating quoted string value.");
             free(result);
             result = NULL;
         }
@@ -258,14 +254,14 @@
 /*this function takes a regular const char* and turns in into "this is a\"JSON\" strings\u0008" (starting and ending quote included)*/
 /*the newly created handle needs to be disposed of with STRING_delete*/
 /*returns NULL if there are errors*/
-STRING_HANDLE STRING_new_JSON(const char* source)
+STRING_HANDLE  ICACHE_FLASH_ATTR STRING_new_JSON(const char* source)
 {
     STRING* result;
     if (source == NULL)
     {
         /*Codes_SRS_STRING_02_011: [If source is NULL then STRING_new_JSON shall return NULL.] */
         result = NULL;
-        LogError("invalid arg (NULL)");
+        printf("invalid arg (NULL)");
     }
     else
     {
@@ -301,21 +297,21 @@
         if (i < vlen)
         {
             result = NULL;
-            LogError("invalid character in input string");
+            printf("invalid character in input string");
         }
         else
         {
             if ((result = (STRING*)malloc(sizeof(STRING))) == NULL)
             {
                 /*Codes_SRS_STRING_02_021: [If the complete JSON representation cannot be produced, then STRING_new_JSON shall fail and return NULL.] */
-                LogError("malloc json failure");
+                printf("malloc json failure");
             }
             else if ((result->s = (char*)malloc(vlen + 5 * nControlCharacters + nEscapeCharacters + 3)) == NULL)
             {
                 /*Codes_SRS_STRING_02_021: [If the complete JSON representation cannot be produced, then STRING_new_JSON shall fail and return NULL.] */
                 free(result);
                 result = NULL;
-                LogError("malloc failed");
+                printf("malloc failed");
             }
             else
             {
@@ -373,7 +369,7 @@
 /*returns 0 if success*/
 /*any other error code is failure*/
 /* Codes_SRS_STRING_07_012: [STRING_concat shall concatenate the given STRING_HANDLE and the const char* value and place the value in the handle.] */
-int STRING_concat(STRING_HANDLE handle, const char* s2)
+int  ICACHE_FLASH_ATTR STRING_concat(STRING_HANDLE handle, const char* s2)
 {
     int result;
     if ((handle == NULL) || (s2 == NULL))
@@ -390,7 +386,7 @@
         if (temp == NULL)
         {
             /* Codes_SRS_STRING_07_013: [STRING_concat shall return a nonzero number if an error is encountered.] */
-            LogError("Failure reallocating value.");
+            printf("Failure reallocating value.");
             result = __FAILURE__;
         }
         else
@@ -407,13 +403,13 @@
 /*returns 0 if success*/
 /*any other error code is failure*/
 /* Codes_SRS_STRING_07_034: [String_Concat_with_STRING shall concatenate a given STRING_HANDLE variable with a source STRING_HANDLE.] */
-int STRING_concat_with_STRING(STRING_HANDLE s1, STRING_HANDLE s2)
+int ICACHE_FLASH_ATTR  STRING_concat_with_STRING(STRING_HANDLE s1, STRING_HANDLE s2)
 {
     int result;
     if ((s1 == NULL) || (s2 == NULL))
     {
         /* Codes_SRS_STRING_07_035: [String_Concat_with_STRING shall return a nonzero number if an error is encountered.] */
-        LogError("Invalid argument specified");
+        printf("Invalid argument specified");
         result = __FAILURE__;
     }
     else
@@ -427,7 +423,7 @@
         if (temp == NULL)
         {
             /* Codes_SRS_STRING_07_035: [String_Concat_with_STRING shall return a nonzero number if an error is encountered.] */
-            LogError("Failure reallocating value");
+            printf("Failure reallocating value");
             result = __FAILURE__;
         }
         else
@@ -445,7 +441,7 @@
 /*returns 0 if success*/
 /*any other error code is failure*/
 /* Codes_SRS_STRING_07_016: [STRING_copy shall copy the const char* into the supplied STRING_HANDLE.] */
-int STRING_copy(STRING_HANDLE handle, const char* s2)
+int  ICACHE_FLASH_ATTR STRING_copy(STRING_HANDLE handle, const char* s2)
 {
     int result;
     if ((handle == NULL) || (s2 == NULL))
@@ -463,7 +459,7 @@
             char* temp = (char*)realloc(s1->s, s2Length + 1);
             if (temp == NULL)
             {
-                LogError("Failure reallocating value.");
+                printf("Failure reallocating value.");
                 /* Codes_SRS_STRING_07_027: [STRING_copy shall return a nonzero value if any error is encountered.] */
                 result = __FAILURE__;
             }
@@ -487,7 +483,7 @@
 /*returns 0 if success*/
 /*any other error code is failure*/
 /* Codes_SRS_STRING_07_018: [STRING_copy_n shall copy the number of characters in const char* or the size_t whichever is lesser.] */
-int STRING_copy_n(STRING_HANDLE handle, const char* s2, size_t n)
+int ICACHE_FLASH_ATTR  STRING_copy_n(STRING_HANDLE handle, const char* s2, size_t n)
 {
     int result;
     if ((handle == NULL) || (s2 == NULL))
@@ -508,7 +504,7 @@
         temp = (char*)realloc(s1->s, s2Length + 1);
         if (temp == NULL)
         {
-            LogError("Failure reallocating value.");
+            printf("Failure reallocating value.");
             /* Codes_SRS_STRING_07_028: [STRING_copy_n shall return a nonzero value if any error is encountered.] */
             result = __FAILURE__;
         }
@@ -527,10 +523,9 @@
 #if defined(__GNUC__)
 __attribute__ ((format (printf, 2, 3)))
 #endif
-int STRING_sprintf(STRING_HANDLE handle, const char* format, ...)
+int  ICACHE_FLASH_ATTR STRING_sprintf(STRING_HANDLE handle, const char* format, ...)
 {
-    int result;
-    
+    int result;  
 #ifdef STRINGS_C_SPRINTF_BUFFER_SIZE
     size_t maxBufSize = STRINGS_C_SPRINTF_BUFFER_SIZE;
     char buf[STRINGS_C_SPRINTF_BUFFER_SIZE];
@@ -542,7 +537,7 @@
     if (handle == NULL || format == NULL)
     {
         /* Codes_SRS_STRING_07_042: [if the parameters s1 or format are NULL then STRING_sprintf shall return non zero value.] */
-        LogError("Invalid arg (NULL)");
+        printf("Invalid arg (NULL)");
         result = __FAILURE__;
     }
     else
@@ -556,7 +551,7 @@
         if (s2Length < 0)
         {
             /* Codes_SRS_STRING_07_043: [If any error is encountered STRING_sprintf shall return a non zero value.] */
-            LogError("Failure vsnprintf return < 0");
+            printf("Failure vsnprintf return < 0");
             result = __FAILURE__;
         }
         else if (s2Length == 0)
@@ -577,7 +572,7 @@
                 if (vsnprintf(s1->s + s1Length, s1Length + s2Length + 1, format, arg_list) < 0)
                 {
                     /* Codes_SRS_STRING_07_043: [If any error is encountered STRING_sprintf shall return a non zero value.] */
-                    LogError("Failure vsnprintf formatting error");
+                    printf("Failure vsnprintf formatting error");
                     s1->s[s1Length] = '\0';
                     result = __FAILURE__;
                 }
@@ -591,11 +586,12 @@
             else
             {
                 /* Codes_SRS_STRING_07_043: [If any error is encountered STRING_sprintf shall return a non zero value.] */
-                LogError("Failure unable to reallocate memory");
+                printf("Failure unable to reallocate memory");
                 result = __FAILURE__;
             }
         }
     }
+
     return result;
 }
 
@@ -603,7 +599,7 @@
 /*returns 0 if success*/ /*doesn't change the string otherwise*/
 /*any other error code is failure*/
 /* Codes_SRS_STRING_07_014: [STRING_quote shall "quote" the supplied STRING_HANDLE and return 0 on success.] */
-int STRING_quote(STRING_HANDLE handle)
+int ICACHE_FLASH_ATTR  STRING_quote(STRING_HANDLE handle)
 {
     int result;
     if (handle == NULL)
@@ -618,7 +614,7 @@
         char* temp = (char*)realloc(s1->s, s1Length + 2 + 1);/*2 because 2 quotes, 1 because '\0'*/
         if (temp == NULL)
         {
-            LogError("Failure reallocating value.");
+            printf("Failure reallocating value.");
             /* Codes_SRS_STRING_07_029: [STRING_quote shall return a nonzero value if any error is encountered.] */
             result = __FAILURE__;
         }
@@ -637,7 +633,7 @@
 /*this function will revert a string to an empty state*/
 /*Returns 0 if the revert was succesful*/
 /* Codes_SRS_STRING_07_022: [STRING_empty shall revert the STRING_HANDLE to an empty state.] */
-int STRING_empty(STRING_HANDLE handle)
+int  ICACHE_FLASH_ATTR STRING_empty(STRING_HANDLE handle)
 {
     int result;
     if (handle == NULL)
@@ -651,7 +647,7 @@
         char* temp = (char*)realloc(s1->s, 1);
         if (temp == NULL)
         {
-            LogError("Failure reallocating value.");
+            printf("Failure reallocating value.");
             /* Codes_SRS_STRING_07_030: [STRING_empty shall return a nonzero value if the STRING_HANDLE is NULL.] */
             result = __FAILURE__;
         }
@@ -667,7 +663,7 @@
 
 /*this function will deallocate a string constructed by str_new*/
 /* Codes_SRS_STRING_07_010: [STRING_delete will free the memory allocated by the STRING_HANDLE.] */
-void STRING_delete(STRING_HANDLE handle)
+void ICACHE_FLASH_ATTR  STRING_delete(STRING_HANDLE handle)
 {
     /* Codes_SRS_STRING_07_011: [STRING_delete will not attempt to free anything with a NULL STRING_HANDLE.] */
     if (handle != NULL)
@@ -680,7 +676,7 @@
 }
 
 /* Codes_SRS_STRING_07_020: [STRING_c_str shall return the const char* associated with the given STRING_HANDLE.] */
-const char* STRING_c_str(STRING_HANDLE handle)
+const char*  ICACHE_FLASH_ATTR STRING_c_str(STRING_HANDLE handle)
 {
     const char* result;
     if (handle != NULL)
@@ -696,7 +692,7 @@
 }
 
 /* Codes_SRS_STRING_07_024: [STRING_length shall return the length of the underlying char* for the given handle] */
-size_t STRING_length(STRING_HANDLE handle)
+size_t ICACHE_FLASH_ATTR  STRING_length(STRING_HANDLE handle)
 {
     size_t result = 0;
     /* Codes_SRS_STRING_07_025: [STRING_length shall return zero if the given handle is NULL.] */
@@ -709,14 +705,14 @@
 }
 
 /*Codes_SRS_STRING_02_007: [STRING_construct_n shall construct a STRING_HANDLE from first "n" characters of the string pointed to by psz parameter.]*/
-STRING_HANDLE STRING_construct_n(const char* psz, size_t n)
+STRING_HANDLE  ICACHE_FLASH_ATTR STRING_construct_n(const char* psz, size_t n)
 {
     STRING_HANDLE result;
     /*Codes_SRS_STRING_02_008: [If psz is NULL then STRING_construct_n shall return NULL.] */
     if (psz == NULL)
     {
         result = NULL;
-        LogError("invalid arg (NULL)");
+        printf("invalid arg (NULL)");
     }
     else
     {
@@ -725,7 +721,7 @@
         if (n > len)
         {
             result = NULL;
-            LogError("invalig arg (n is bigger than the size of the string)");
+            printf("invalig arg (n is bigger than the size of the string)");
         }
         else
         {
@@ -741,7 +737,7 @@
                 /* Codes_SRS_STRING_02_010: [In all other error cases, STRING_construct_n shall return NULL.]  */
                 else
                 {
-                    LogError("Failure allocating value.");
+                    printf("Failure allocating value.");
                     free(str);
                     result = NULL;
                 }
@@ -757,7 +753,7 @@
 }
 
 /* Codes_SRS_STRING_07_034: [STRING_compare returns an integer greater than, equal to, or less than zero, accordingly as the string pointed to by s1 is greater than, equal to, or less than the string s2.] */
-int STRING_compare(STRING_HANDLE s1, STRING_HANDLE s2)
+int ICACHE_FLASH_ATTR  STRING_compare(STRING_HANDLE s1, STRING_HANDLE s2)
 {
     int result;
     if (s1 == NULL && s2 == NULL)
@@ -785,13 +781,13 @@
     return result;
 }
 
-STRING_HANDLE STRING_from_byte_array(const unsigned char* source, size_t size)
+STRING_HANDLE ICACHE_FLASH_ATTR  STRING_from_byte_array(const unsigned char* source, size_t size)
 {
     STRING* result;
     /*Codes_SRS_STRING_02_022: [ If source is NULL and size > 0 then STRING_from_BUFFER shall fail and return NULL. ]*/
     if ((source == NULL) && (size > 0))
     {
-        LogError("invalid parameter (NULL)");
+        printf("invalid parameter (NULL)");
         result = NULL;
     }
     else
@@ -801,7 +797,7 @@
         if (result == NULL)
         {
             /*Codes_SRS_STRING_02_024: [ If building the string fails, then STRING_from_BUFFER shall fail and return NULL. ]*/
-            LogError("oom - unable to malloc");
+            printf("oom - unable to malloc");
             /*return as is*/
         }
         else
@@ -811,7 +807,7 @@
             if (result->s == NULL)
             {
                 /*Codes_SRS_STRING_02_024: [ If building the string fails, then STRING_from_BUFFER shall fail and return NULL. ]*/
-                LogError("oom - unable to malloc");
+                printf("oom - unable to malloc");
                 free(result);
                 result = NULL;
             }
@@ -825,7 +821,7 @@
     return (STRING_HANDLE)result;
 }
 
-int STRING_replace(STRING_HANDLE handle, char target, char replace)
+int  ICACHE_FLASH_ATTR STRING_replace(STRING_HANDLE handle, char target, char replace)
 {
     int result;
     if (handle == NULL)
diff -uNr src/threadapi_esp8266.c src_ok/threadapi_esp8266.c
--- src/threadapi_esp8266.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/threadapi_esp8266.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,31 +1,31 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdint.h>
-#include <stdlib.h>
-#include "azure_c_shared_utility/threadapi.h"
-#include "azure_c_shared_utility/xlogging.h"
+#include "esp_types.h"
+#include "threadapi.h"
+#include "xlogging.h"
 
 DEFINE_ENUM_STRINGS(THREADAPI_RESULT, THREADAPI_RESULT_VALUES);
 
-THREADAPI_RESULT ThreadAPI_Create(THREAD_HANDLE* threadHandle, THREAD_START_FUNC func, void* arg)
+THREADAPI_RESULT  ICACHE_FLASH_ATTR ThreadAPI_Create(THREAD_HANDLE* threadHandle, THREAD_START_FUNC func, void* arg)
 {
-	LogError("ESP8266 RTOS does not support multi-thread function.");
+	printf("ESP8266  does not support multi-thread function.");
     return THREADAPI_ERROR;
 }
 
-THREADAPI_RESULT ThreadAPI_Join(THREAD_HANDLE threadHandle, int* res)
+THREADAPI_RESULT  ICACHE_FLASH_ATTR ThreadAPI_Join(THREAD_HANDLE threadHandle, int* res)
 {
-    LogError("ESP8266 RTOS does not support multi-thread function.");
+    printf("ESP8266 does not support multi-thread function.");
     return THREADAPI_ERROR;
 }
 
-void ThreadAPI_Exit(int res)
+void  ICACHE_FLASH_ATTR ThreadAPI_Exit(int res)
 {
-	vTaskDelete(NULL);
+	//vTaskDelete(NULL);
 }
 
-void ThreadAPI_Sleep(unsigned int milliseconds)
+void  ICACHE_FLASH_ATTR ThreadAPI_Sleep(unsigned int milliseconds)
 {
-	vTaskDelay(milliseconds);
+	//vTaskDelay(milliseconds);
+    os_delay_us(milliseconds * 1000);
 }
diff -uNr src/tickcounter_esp8266.c src_ok/tickcounter_esp8266.c
--- src/tickcounter_esp8266.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/tickcounter_esp8266.c	2018-09-03 16:45:36.000000000 +0800
@@ -6,29 +6,26 @@
 #include <crtdbg.h>
 #endif
 
-#include "azure_c_shared_utility/gballoc.h"
-
-#include <stdint.h>
-#include <time.h>
-#include "azure_c_shared_utility/tickcounter.h"
-#include "azure_c_shared_utility/xlogging.h"
+#include "esp_types.h"
+#include "tickcounter.h"
+#include "xlogging.h"
 
 typedef struct TICK_COUNTER_INSTANCE_TAG
 {
     unsigned char dummy;
 } TICK_COUNTER_INSTANCE;
 
-TICK_COUNTER_HANDLE tickcounter_create(void)
+TICK_COUNTER_HANDLE ICACHE_FLASH_ATTR  tickcounter_create(void)
 {
     TICK_COUNTER_INSTANCE* result = (TICK_COUNTER_INSTANCE*)malloc(sizeof(TICK_COUNTER_INSTANCE));
     if (result == NULL)
     {
-        LogError("Failed creating tick counter");
+        printf("Failed creating tick counter");
     }
     return result;
 }
 
-void tickcounter_destroy(TICK_COUNTER_HANDLE tick_counter)
+void ICACHE_FLASH_ATTR  tickcounter_destroy(TICK_COUNTER_HANDLE tick_counter)
 {
     if (tick_counter != NULL)
     {
@@ -36,19 +33,19 @@
     }
 }
 
-int tickcounter_get_current_ms(TICK_COUNTER_HANDLE tick_counter, tickcounter_ms_t * current_ms)
+int  ICACHE_FLASH_ATTR tickcounter_get_current_ms(TICK_COUNTER_HANDLE tick_counter, tickcounter_ms_t * current_ms)
 {
     int result;
 
     if (tick_counter == NULL || current_ms == NULL)
     {
-        LogError("tickcounter failed: Invalid Arguments.\r\n");
+        printf("tickcounter failed: Invalid Arguments.\r\n");
         result = __LINE__;
     }
     else
     {
         //Currently configTICK_RATE_HZ is set to 100 (100Hz); a tick is 10ms
-        *current_ms = (tickcounter_ms_t)xTaskGetTickCount()*10;
+        *current_ms = system_get_time() / 1000;
         result = 0;
     }
 
diff -uNr src/tlsio_mbedtls_compact.c src_ok/tlsio_mbedtls_compact.c
--- src/tlsio_mbedtls_compact.c	1970-01-01 08:00:00.000000000 +0800
+++ src_ok/tlsio_mbedtls_compact.c	2018-09-03 16:45:36.000000000 +0800
@@ -0,0 +1,1297 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#include "esp_types.h"
+
+//#include "config_esp.h"
+#include "mbedtls/debug.h"
+#include "mbedtls/ssl.h"
+#include "mbedtls/entropy.h"
+#include "mbedtls/ctr_drbg.h"
+#include "mbedtls/error.h"
+#include "mbedtls/certs.h"
+#include "mbedtls/entropy_poll.h"
+
+#include "tlsio.h"
+//#include "tlsio_mbedtls.h"
+#include "socketio.h"
+#include "crt_abstractions.h"
+#include "shared_util_options.h"
+
+#include "singlylinkedlist.h"
+#include "tlsio_options.h"
+
+#include "lwip/app/espconn.h"
+
+typedef struct
+{
+    unsigned char* bytes;
+    size_t size;
+    size_t unsent_size;
+} PENDING_TRANSMISSION;
+
+#define MAX_VALID_PORT 0xffff
+
+// The TLSIO_RECEIVE_BUFFER_SIZE has very little effect on performance, and is kept small
+// to minimize memory consumption.
+#define TLSIO_RECEIVE_BUFFER_SIZE 64
+
+
+static const char* OPTION_X509_CERT = "x509certificate";
+static const char* OPTION_X509_PRIVATE_KEY = "x509privatekey";
+#define OPTION_UNDERLYING_IO_OPTIONS        "underlying_io_options"
+
+
+typedef enum TLSIO_STATE_TAG
+{
+    TLSIO_STATE_CLOSED,
+    TLSIO_STATE_OPENING_WAITING_DNS,
+    TLSIO_STATE_OPENING_WAITING_SOCKET,
+    TLSIO_STATE_OPENING_WAITING_SSL,
+    TLSIO_STATE_OPEN,
+    TLSIO_STATE_ERROR,
+} TLSIO_STATE;
+
+bool is_an_opening_state(TLSIO_STATE state)
+{
+    return state == TLSIO_STATE_OPENING_WAITING_DNS ||
+        state == TLSIO_STATE_OPENING_WAITING_SOCKET ||
+        state == TLSIO_STATE_OPENING_WAITING_SSL;
+}
+
+// This structure definition is mirrored in the unit tests, so if you change
+// this struct, keep it in sync with the one in tlsio_mbedtls_compact_ut.c
+typedef struct TLS_IO_INSTANCE_TAG
+{
+    ON_BYTES_RECEIVED on_bytes_received;
+    ON_IO_ERROR on_io_error;
+    ON_IO_OPEN_COMPLETE on_open_complete;
+    void* on_bytes_received_context;
+    void* on_io_error_context;
+    void* on_open_complete_context;
+    
+    mbedtls_entropy_context    entropy;
+    mbedtls_ctr_drbg_context   ctr_drbg;
+    mbedtls_ssl_context        ssl;
+    mbedtls_ssl_config         config;
+    mbedtls_x509_crt           trusted_certificates_parsed;
+    mbedtls_ssl_session        ssn;
+    mbedtls_x509_crt           client_certificates_parsed;
+    mbedtls_pk_context         pk;
+    char*                      trusted_certificates;
+    char*                      x509certificate;
+    char*                      x509privatekey;
+
+
+    TLSIO_STATE tlsio_state;
+    char* hostname;
+    uint16_t port;
+    SINGLYLINKEDLIST_HANDLE pending_transmission_list;
+    TLSIO_OPTIONS options;
+
+    unsigned char* socket_io_read_bytes;
+    size_t socket_io_read_byte_count;
+} TLS_IO_INSTANCE;
+
+
+
+static os_timer_t user_dns_timer;
+static struct espconn user_tcp_conn;
+static struct _esp_tcp user_tcp;
+static ip_addr_t tcp_server_ip;
+TLS_IO_INSTANCE* g_tls_io_instance;
+
+
+/* Codes_SRS_TLSIO_30_005: [ The phrase "enter TLSIO_STATE_EXT_ERROR" means the adapter shall call the on_io_error function and pass the on_io_error_context that was supplied in tlsio_open_async. ]*/
+static void enter_tlsio_error_state(TLS_IO_INSTANCE* tls_io_instance)
+{
+    if (tls_io_instance->tlsio_state != TLSIO_STATE_ERROR)
+    {
+        tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;
+        tls_io_instance->on_io_error(tls_io_instance->on_io_error_context);
+    }
+}
+
+/* Codes_SRS_TLSIO_30_005: [ When the adapter enters TLSIO_STATE_EXT_ERROR it shall call the  on_io_error function and pass the on_io_error_context that were supplied in  tlsio_open . ]*/
+static void enter_open_error_state(TLS_IO_INSTANCE* tls_io_instance)
+{
+    // save instance variables in case the framework destroys this object before we exit
+    ON_IO_OPEN_COMPLETE on_open_complete = tls_io_instance->on_open_complete;
+    void* on_open_complete_context = tls_io_instance->on_open_complete_context;
+    enter_tlsio_error_state(tls_io_instance);   
+    on_open_complete(on_open_complete_context, IO_OPEN_ERROR);
+}
+
+static bool destroy_head_message(TLS_IO_INSTANCE* tls_io_instance)
+{
+    bool result;
+    LIST_ITEM_HANDLE head_pending_io;
+    
+    head_pending_io = singlylinkedlist_get_head_item(tls_io_instance->pending_transmission_list);
+    if (head_pending_io != NULL)
+    {
+        PENDING_TRANSMISSION* head_message = (PENDING_TRANSMISSION*)singlylinkedlist_item_get_value(head_pending_io);
+        if (singlylinkedlist_remove(tls_io_instance->pending_transmission_list, head_pending_io) != 0)
+        {
+            enter_tlsio_error_state(tls_io_instance);
+            printf("Failed to remove message from list");
+        }
+
+        free(head_message->bytes);
+        free(head_message);
+        result = true;
+    }
+    else
+    {
+        result = false;
+    }
+    return result;
+}
+
+static void internal_close(TLS_IO_INSTANCE* tls_io_instance)
+{
+    // mbedTLS cleanup...
+    printf("==> internal_close\n");
+    mbedtls_ssl_close_notify(&tls_io_instance->ssl);
+    mbedtls_ssl_free(&tls_io_instance->ssl);
+    mbedtls_ssl_config_free(&tls_io_instance->config);
+    mbedtls_x509_crt_free(&tls_io_instance->trusted_certificates_parsed);
+    mbedtls_x509_crt_free(&tls_io_instance->client_certificates_parsed);
+    mbedtls_pk_free(&tls_io_instance->pk);
+    mbedtls_ctr_drbg_free(&tls_io_instance->ctr_drbg);
+    mbedtls_entropy_free(&tls_io_instance->entropy);
+
+
+    while (destroy_head_message(tls_io_instance));
+    // singlylinkedlist_destroy gets called in the main destroy
+
+    tls_io_instance->on_bytes_received = NULL;
+    tls_io_instance->on_io_error = NULL;
+    tls_io_instance->on_bytes_received_context = NULL;
+    tls_io_instance->on_io_error_context = NULL;
+    tls_io_instance->tlsio_state = TLSIO_STATE_CLOSED;
+    tls_io_instance->on_open_complete = NULL;
+    tls_io_instance->on_open_complete_context = NULL;
+}
+
+
+static void tlsio_mbedtls_destroy(CONCRETE_IO_HANDLE tls_io)
+{
+    if (tls_io == NULL)
+    {
+        /* Codes_SRS_TLSIO_30_020: [ If tlsio_handle is NULL, tlsio_destroy shall do nothing. ]*/
+        printf("NULL tlsio");
+    }
+    else
+    {
+        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;
+        if (tls_io_instance->tlsio_state != TLSIO_STATE_CLOSED)
+        {
+            /* Codes_SRS_TLSIO_30_022: [ If the adapter is in any state other than TLSIO_STATE_EX_CLOSED when tlsio_destroy is called, the adapter shall enter TLSIO_STATE_EX_CLOSING and then enter TLSIO_STATE_EX_CLOSED before completing the destroy process. ]*/
+            printf("tlsio_mbedtls_destroy called while not in TLSIO_STATE_CLOSED.");
+            internal_close(tls_io_instance);
+        }
+        /* Codes_SRS_TLSIO_30_021: [ The tlsio_destroy shall release all allocated resources and then release tlsio_handle. ]*/
+        if (tls_io_instance->hostname != NULL)
+        {
+            free(tls_io_instance->hostname);
+        }
+        
+        if (tls_io_instance->trusted_certificates != NULL)
+        {
+            free(tls_io_instance->trusted_certificates);
+        }
+        if(tls_io_instance->x509certificate != NULL)
+        {
+            free(tls_io_instance->x509certificate);
+        }
+        if(tls_io_instance->x509privatekey != NULL)
+        {
+            free(tls_io_instance->x509privatekey);
+        }
+
+        if (tls_io_instance->pending_transmission_list != NULL)
+        {
+            /* Pending messages were cleared in internal_close */
+            singlylinkedlist_destroy(tls_io_instance->pending_transmission_list);
+        }
+
+        free(tls_io_instance);
+    }
+
+    g_tls_io_instance = NULL;
+}
+
+static void ICACHE_FLASH_ATTR  mbedtls_init();
+
+
+static CONCRETE_IO_HANDLE tlsio_mbedtls_create(void* io_create_parameters)
+{
+    TLS_IO_INSTANCE* result;
+
+    if (io_create_parameters == NULL)
+    {
+        printf("NULL tls_io_config\n");
+        result = NULL;
+    }
+    else
+    {
+        TLSIO_CONFIG* tls_io_config = (TLSIO_CONFIG*)io_create_parameters;
+        if (tls_io_config->hostname == NULL)
+        {
+            printf("NULL tls_io_config->hostname\n");
+            result = NULL;
+        }
+        else if (tls_io_config->port < 0 || tls_io_config->port > MAX_VALID_PORT)
+        {
+            printf("tls_io_config->port out of range\n");
+            result = NULL;
+        }
+        else
+        {
+            result = g_tls_io_instance = malloc(sizeof(TLS_IO_INSTANCE));
+            if (result == NULL)
+            {
+                printf("malloc failed");
+            }
+            else
+            {
+                int ms_result;
+                memset(result, 0, sizeof(TLS_IO_INSTANCE));
+                result->port = (uint16_t)tls_io_config->port;
+                result->tlsio_state = TLSIO_STATE_CLOSED;
+                result->hostname = NULL;
+                result->pending_transmission_list = NULL;
+                
+                tlsio_options_initialize(&result->options, TLSIO_OPTION_BIT_TRUSTED_CERTS); //hlx
+                ms_result = mallocAndStrcpy_s(&result->hostname, tls_io_config->hostname);
+                if (ms_result != 0)
+                {
+                    printf("malloc failed\n");
+                    tlsio_mbedtls_destroy(result);
+                    result = NULL;
+                }
+                else
+                {
+                    // Create the message queue
+                    result->pending_transmission_list = singlylinkedlist_create();
+                    if (result->pending_transmission_list == NULL)
+                    {
+                        printf("Failed singlylinkedlist_create\n");
+                        tlsio_mbedtls_destroy(result);
+                        result = NULL;
+                    }
+                }
+                mbedtls_init();
+            }
+        }
+    }
+
+    return (CONCRETE_IO_HANDLE)result;
+}
+
+
+static int ICACHE_FLASH_ATTR  on_io_recv(void *context, unsigned char *buf, size_t sz)
+{
+    printf("==> on_io_recv\n");
+    int result;
+    TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)context;
+    unsigned char* new_socket_io_read_bytes;
+
+    if (tls_io_instance->socket_io_read_byte_count == 0)
+    {
+        printf("no data yet, return\n");
+        return( MBEDTLS_ERR_SSL_WANT_READ );
+    } else {
+        printf("have data now! len: %d, required: %d\n", tls_io_instance->socket_io_read_byte_count, sz);
+    }
+
+    result = tls_io_instance->socket_io_read_byte_count;
+    if (result > sz)
+    {
+        result = sz;
+    }
+
+    if (result > 0)
+    {
+        printf("feed mbedtls lib\n");
+        int i ;
+        printf("%d\n", result);
+        for (i = 0; i < 10; i++) {
+            printf("%x ", tls_io_instance->socket_io_read_bytes[i]);
+        }
+        printf(" ...\n");
+        (void)memcpy((void *)buf, tls_io_instance->socket_io_read_bytes, result);
+        (void)memmove(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_bytes + result, tls_io_instance->socket_io_read_byte_count - result);
+        tls_io_instance->socket_io_read_byte_count -= result;
+        if (tls_io_instance->socket_io_read_byte_count > 0)
+        {
+            printf("trim buffer, mem: %d\n", system_get_free_heap_size());
+            new_socket_io_read_bytes = (unsigned char*)realloc(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_byte_count);
+            if (new_socket_io_read_bytes != NULL)
+            {
+                tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;
+            } else {
+                printf("realloc() error!\n");
+            }
+        }
+        else
+        {
+            
+            free(tls_io_instance->socket_io_read_bytes);
+            printf("tttt, mem: %d\n", system_get_free_heap_size());
+            tls_io_instance->socket_io_read_bytes = NULL;
+        }
+    }
+
+
+    if ((result == 0) && (tls_io_instance->tlsio_state == TLSIO_STATE_OPEN))
+    {
+        result = MBEDTLS_ERR_SSL_WANT_READ;
+    }
+
+    return result;
+}
+
+
+static int add_pending_io(TLS_IO_INSTANCE* tlsio_instance, const void* buffer, size_t size)
+{
+
+    PENDING_TRANSMISSION* pending_transmission = (PENDING_TRANSMISSION*)malloc(sizeof(PENDING_TRANSMISSION));
+    if (pending_transmission == NULL)
+    {
+        /* Codes_SRS_TLSIO_30_064: [ If the supplied message cannot be enqueued for transmission, tlsio_mbedtls_compact_send shall log an error and return FAILURE. ]*/
+        printf("malloc failed");
+        return __FAILURE__;
+    }
+    
+    /* Codes_SRS_TLSIO_30_063: [ The tlsio_mbedtls_compact_send shall enqueue for transmission the on_send_complete, the callback_context, the size, and the contents of buffer. ]*/
+    pending_transmission->bytes = (unsigned char*)malloc(size);
+    if (pending_transmission->bytes == NULL)
+    {
+        /* Codes_SRS_TLSIO_30_064: [ If the supplied message cannot be enqueued for transmission, tlsio_mbedtls_compact_send shall log an error and return FAILURE. ]*/
+        printf("malloc failed");
+        free(pending_transmission);
+        return __FAILURE__;
+    }
+    
+    pending_transmission->size = size;
+    pending_transmission->unsent_size = size;
+    (void)memcpy(pending_transmission->bytes, buffer, size);
+
+    if (singlylinkedlist_add(tlsio_instance->pending_transmission_list, pending_transmission) == NULL)
+    {
+        /* Codes_SRS_TLSIO_30_064: [ If the supplied message cannot be enqueued for transmission, tlsio_mbedtls_compact_send shall log an error and return FAILURE. ]*/
+        printf("Unable to add socket to pending list.");
+        free(pending_transmission->bytes);
+        free(pending_transmission);
+        return __FAILURE__;
+    }
+
+    return 0;
+}
+
+
+static int ICACHE_FLASH_ATTR  on_io_send(void *context, const unsigned char *buf, size_t sz)
+{
+    printf("==> on_io_send ????????????????? sz: %d\n", sz);
+    int result = 0;
+    TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)context;
+    
+    if ((tls_io_instance == NULL) ||
+        (buf == NULL) ||
+        (sz == 0))
+    {
+        /* Invalid arguments */
+        printf("Invalid argument: send given invalid parameter");
+        return 0;
+    }
+
+    printf("add data to pending list or not?\n");
+    LIST_ITEM_HANDLE first_pending_io = singlylinkedlist_get_head_item(tls_io_instance->pending_transmission_list);
+    if (first_pending_io != NULL)
+    {
+        if (add_pending_io(tls_io_instance, buf, sz) != 0)
+        {
+            printf("Failure: add_pending_io failed.");
+            return __FAILURE__;
+        }
+    }
+    else
+    {
+        printf("espconn_send!!! sz:%d\n", sz);
+        signed char send_result = espconn_send( &user_tcp_conn, buf, sz);
+        if (send_result != 0)
+        {
+            printf("1Failure: sending socket failed. %d\n", send_result);
+            switch (send_result) {
+            case ESPCONN_MEM:
+                printf("ESPCONN_MEM\n");
+                result = __FAILURE__;
+                break;
+            case ESPCONN_ARG:
+                printf("ESPCONN_ARG\n");
+                result = __FAILURE__;
+                break;
+            case ESPCONN_MAXNUM:
+                //底层最多缓存 8 包等待发送完成，因此，如果发包太快，缓存已满，就会返回 -7 错误码。
+                printf("ESPCONN_MAXNUM\n");
+                // not an error
+                //result = MBEDTLS_ERR_SSL_WANT_WRITE;
+                printf("add data to pending list\n");
+                if (add_pending_io(tls_io_instance, buf, sz) != 0)
+                {
+                    printf("Failure: add_pending_io failed.");
+                    return 0;
+                }
+                return sz;
+                break;
+            case ESPCONN_IF:
+                printf("ESPCONN_IF\n");
+                result = __FAILURE__;
+                break;
+            default:
+                printf("unknown error\n");
+                result = __FAILURE__;
+                break;
+            }
+            // 告诉 mbedtls 这次啥都没发送，你下次重新发送吧
+            return 0;
+            
+        }
+    }
+    
+    // 告诉 mbedtls 已经成功发送了 sz 字节，可以更新状态机了
+    return sz;
+}
+
+
+static int  ICACHE_FLASH_ATTR tlsio_entropy_poll(void *v, unsigned char *output, size_t len, size_t *olen)
+{
+    uint16_t i;
+
+    srand(time(NULL));
+    char *c = (char*)malloc(len);
+    memset(c, 0, len);
+    for (i = 0; i < len; i++) {
+        c[i] = rand() % 256;
+    }
+    memmove(output, c, len);
+    *olen = len;
+
+    free(c);
+    return(0);
+}
+
+static void ICACHE_FLASH_ATTR  mbedtls_init() 
+{
+    TLS_IO_INSTANCE *result = (TLS_IO_INSTANCE *)g_tls_io_instance;
+    char *pers = "azure_iot_client";
+
+    // mbedTLS initialize...
+    mbedtls_entropy_init(&result->entropy);
+    mbedtls_ctr_drbg_init(&result->ctr_drbg);
+    mbedtls_ssl_init(&result->ssl);
+    mbedtls_ssl_session_init(&result->ssn);
+    mbedtls_ssl_config_init(&result->config);
+    mbedtls_x509_crt_init(&result->trusted_certificates_parsed);
+    mbedtls_x509_crt_init(&result->client_certificates_parsed);
+    mbedtls_pk_init( &result->pk);
+    mbedtls_entropy_add_source(&result->entropy, tlsio_entropy_poll, NULL, 128, 0);
+    mbedtls_ctr_drbg_seed(&result->ctr_drbg, mbedtls_entropy_func, &result->entropy, (const unsigned char *)pers, strlen(pers));
+    mbedtls_ssl_config_defaults(&result->config, MBEDTLS_SSL_IS_CLIENT, MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT);
+    mbedtls_ssl_conf_rng(&result->config, mbedtls_ctr_drbg_random, &result->ctr_drbg);
+    mbedtls_ssl_conf_authmode(&result->config, MBEDTLS_SSL_VERIFY_REQUIRED); // MBEDTLS_SSL_VERIFY_NONE
+    mbedtls_ssl_conf_min_version(&result->config, MBEDTLS_SSL_MAJOR_VERSION_3, MBEDTLS_SSL_MINOR_VERSION_3);          // v1.2
+    mbedtls_ssl_set_bio(&result->ssl, result, on_io_send, on_io_recv, NULL);
+    mbedtls_ssl_set_hostname(&result->ssl, result->hostname);
+    mbedtls_ssl_set_session(&result->ssl, &result->ssn);
+    printf("init mbedtls...........\n");
+    mbedtls_ssl_setup(&result->ssl, &result->config);
+
+    // DEPRECATED: debug functions do not belong in the tree.
+#if defined (MBED_TLS_DEBUG_ENABLE)
+    mbedtls_ssl_conf_dbg(&result->config, mbedtls_debug, NULL);
+    mbedtls_debug_set_threshold(1);
+#endif
+
+    //mbedtls_ssl_setup(&result->ssl, &result->config);
+}
+
+static void  ICACHE_FLASH_ATTR data_received( void *arg, char *pdata, unsigned short len )
+{
+    struct espconn *conn = arg;
+    
+    printf("mem: %d\n", system_get_free_heap_size());
+    os_printf( "%s, len: %d\n", __FUNCTION__, len);
+    int i;
+
+    for (i = 0; i < 10; i++) {
+        printf("%2x ", pdata[i]);
+    }
+    printf("\n");
+    //g_socket_io_instance->on_bytes_received(g_socket_io_instance->on_bytes_received_context, pdata, len);
+
+    unsigned char* new_socket_io_read_bytes = (unsigned char*)realloc(g_tls_io_instance->socket_io_read_bytes, g_tls_io_instance->socket_io_read_byte_count + len);
+
+    if (new_socket_io_read_bytes == NULL)
+    {
+        enter_tlsio_error_state(g_tls_io_instance);
+    }
+    else
+    {
+        g_tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;
+        (void)memcpy(g_tls_io_instance->socket_io_read_bytes + g_tls_io_instance->socket_io_read_byte_count, pdata, len);
+        g_tls_io_instance->socket_io_read_byte_count += len;
+    }
+}
+
+
+static void  ICACHE_FLASH_ATTR tcp_connected( void *arg )
+{
+    struct espconn *conn = arg;
+    
+    os_printf( "%s\n", __FUNCTION__ );
+    os_printf("mem: %d\n", system_get_free_heap_size());
+    espconn_regist_recvcb( conn, data_received );
+
+    
+    g_tls_io_instance->tlsio_state = TLSIO_STATE_OPENING_WAITING_SSL;
+}
+
+
+static void  ICACHE_FLASH_ATTR tcp_disconnected( void *arg )
+{
+    struct espconn *conn = arg;
+    
+    os_printf( "%s\n", __FUNCTION__ );
+    //espconn_regist_recvcb( conn, data_received );
+
+    //todo ...
+}
+
+
+static void ICACHE_FLASH_ATTR  dns_done( const char *name, ip_addr_t *ipaddr, void *arg )
+{
+    struct espconn *conn = arg;
+    
+    printf( "%s\n", __FUNCTION__ );
+    
+    if ( ipaddr == NULL) 
+    {
+        printf("DNS lookup failed\n");
+        wifi_station_disconnect();
+    }
+    else
+    {
+        printf("got DNS IP!!!\n");
+        
+        os_memcpy( conn->proto.tcp->remote_ip, &ipaddr->addr, 4 );
+		tcp_server_ip.addr = ipaddr->addr;
+
+        printf("connecting svr...\n");
+        espconn_regist_connectcb( conn, tcp_connected );
+        espconn_regist_disconcb( conn, tcp_disconnected );
+        espconn_connect( conn );
+
+        g_tls_io_instance->tlsio_state = TLSIO_STATE_OPENING_WAITING_SOCKET;
+
+    }
+}
+
+static void ICACHE_FLASH_ATTR user_tcp_sent_cb(void *arg)
+{
+    struct espconn *pespconn = arg;
+    signed char ret;
+    printf("==> user_tcp_sent_cb!!!!\n");
+
+    LIST_ITEM_HANDLE first_pending_io = singlylinkedlist_get_head_item(g_tls_io_instance->pending_transmission_list);
+    if (first_pending_io) {
+        PENDING_TRANSMISSION* pending_transmission = (PENDING_TRANSMISSION*)singlylinkedlist_item_get_value(first_pending_io);
+        if (!pending_transmission) {
+            printf("singlylinkedlist_item_get_value error\n");
+        }
+        ret = espconn_send(&user_tcp_conn, pending_transmission->bytes, pending_transmission->size);
+        if (ret != 0) {
+            printf("espconn_send error\n");
+            return;
+        }
+
+        free(pending_transmission->bytes);
+        free(pending_transmission);
+        if (singlylinkedlist_remove(g_tls_io_instance->pending_transmission_list, first_pending_io) != 0) {
+            g_tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;
+            printf("Failure: unable to remove socket from list\n");
+        }
+    } else {
+        printf("sendint pipe is empty!\n");
+    }
+}
+
+
+static int tlsio_mbedtls_open_async(CONCRETE_IO_HANDLE tls_io,
+    ON_IO_OPEN_COMPLETE on_io_open_complete, void* on_io_open_complete_context,
+    ON_BYTES_RECEIVED on_bytes_received, void* on_bytes_received_context,
+    ON_IO_ERROR on_io_error, void* on_io_error_context)
+{
+
+    int result;
+    if (on_io_open_complete == NULL)
+    {
+        printf("Required parameter on_io_open_complete is NULL\n");
+        result = __FAILURE__;
+    }
+    else
+    {
+        if (tls_io == NULL)
+        {
+            result = __FAILURE__;
+            printf("NULL tlsio\n");
+        }
+        else
+        {
+            if (on_bytes_received == NULL)
+            {
+                printf("Required parameter on_bytes_received is NULL\n");
+                result = __FAILURE__;
+            }
+            else
+            {
+                if (on_io_error == NULL)
+                {
+                    printf("Required parameter on_io_error is NULL\n");
+                    result = __FAILURE__;
+                }
+                else
+                {
+                    TLS_IO_INSTANCE* tls_io_instance  = (TLS_IO_INSTANCE*)tls_io;
+                    printf("creating espconn...\n");
+                    tcp_server_ip.addr = 0;
+                    memcpy(user_tcp.remote_ip, &tcp_server_ip.addr, 4);
+                    user_tcp.remote_port = tls_io_instance->port;
+                    user_tcp.local_port = espconn_port();
+
+                    user_tcp_conn.type = ESPCONN_TCP;
+                    user_tcp_conn.state = ESPCONN_NONE;
+                    user_tcp_conn.proto.tcp = &user_tcp;
+
+                    // sent cb
+                    espconn_regist_sentcb(&user_tcp_conn, user_tcp_sent_cb);
+
+                    if (tls_io_instance->tlsio_state != TLSIO_STATE_CLOSED)
+                    {
+                        printf("Invalid tlsio_state. Expected state is TLSIO_STATE_CLOSED.\n");
+                        result = __FAILURE__;
+                    }
+                    else
+                    {
+                        //tls_io_instance->dns = dns_async_create(tls_io_instance->hostname, NULL);
+                        printf("espconn_gethostbyname\n");
+			            espconn_gethostbyname( &user_tcp_conn, tls_io_instance->hostname, &tcp_server_ip, dns_done );
+                        
+                        /* Codes_SRS_TLSIO_30_034: [ The tlsio_open shall store the provided on_bytes_received, on_bytes_received_context, on_io_error, on_io_error_context, on_io_open_complete, and on_io_open_complete_context parameters for later use as specified and tested per other line entries in this document. ]*/
+                        tls_io_instance->on_bytes_received = on_bytes_received;
+                        tls_io_instance->on_bytes_received_context = on_bytes_received_context;
+
+                        tls_io_instance->on_io_error = on_io_error;
+                        tls_io_instance->on_io_error_context = on_io_error_context;
+
+                        tls_io_instance->on_open_complete = on_io_open_complete;
+                        tls_io_instance->on_open_complete_context = on_io_open_complete_context;
+
+                        /* Codes_SRS_TLSIO_30_035: [ On tlsio_open success the adapter shall enter TLSIO_STATE_EX_OPENING and return 0. ]*/
+                        // All the real work happens in dowork
+                        tls_io_instance->tlsio_state = TLSIO_STATE_OPENING_WAITING_DNS;
+                        result = 0;
+                        
+                    }
+                }
+            }
+        }
+        /* Codes_SRS_TLSIO_30_039: [ On failure, tlsio_open_async shall not call on_io_open_complete. ]*/
+    }
+
+    return result;
+}
+
+// This implementation does not have asynchronous close, but uses the _async name for consistency with the spec
+static int tlsio_mbedtls_close_async(CONCRETE_IO_HANDLE tls_io, ON_IO_CLOSE_COMPLETE on_io_close_complete, void* callback_context)
+{
+    int result;
+
+    if (tls_io == NULL)
+    {
+        /* Codes_SRS_TLSIO_30_050: [ If the tlsio_handle parameter is NULL, tlsio_mbedtls_close_async shall log an error and return FAILURE. ]*/
+        printf("NULL tlsio");
+        result = __FAILURE__;
+    }
+    else
+    {
+        if (on_io_close_complete == NULL)
+        {
+            /* Codes_SRS_TLSIO_30_055: [ If the on_io_close_complete parameter is NULL, tlsio_mbedtls_close_async shall log an error and return FAILURE. ]*/
+            printf("NULL on_io_close_complete");
+            result = __FAILURE__;
+        }
+        else
+        {
+            TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;
+
+            if (tls_io_instance->tlsio_state != TLSIO_STATE_OPEN &&
+                tls_io_instance->tlsio_state != TLSIO_STATE_ERROR)
+            {
+                /* Codes_SRS_TLSIO_30_053: [ If the adapter is in any state other than TLSIO_STATE_EXT_OPEN or TLSIO_STATE_EXT_ERROR then tlsio_close_async shall log that tlsio_close_async has been called and then continue normally. ]*/
+                // LogInfo rather than printf because this is an unusual but not erroneous situation
+                LogInfo("tlsio_mbedtls_close has been called when in neither TLSIO_STATE_OPEN nor TLSIO_STATE_ERROR.");
+            }
+
+            if (is_an_opening_state(tls_io_instance->tlsio_state))
+            {
+                /* Codes_SRS_TLSIO_30_057: [ On success, if the adapter is in TLSIO_STATE_EXT_OPENING, it shall call on_io_open_complete with the on_io_open_complete_context supplied in tlsio_open_async and IO_OPEN_CANCELLED. This callback shall be made before changing the internal state of the adapter. ]*/
+                tls_io_instance->on_open_complete(tls_io_instance->on_open_complete_context, IO_OPEN_CANCELLED);
+            }
+            // This adapter does not support asynchronous closing
+            /* Codes_SRS_TLSIO_30_056: [ On success the adapter shall enter TLSIO_STATE_EX_CLOSING. ]*/
+            /* Codes_SRS_TLSIO_30_051: [ On success, if the underlying TLS does not support asynchronous closing, then the adapter shall enter TLSIO_STATE_EX_CLOSED immediately after entering TLSIO_STATE_EX_CLOSING. ]*/
+            /* Codes_SRS_TLSIO_30_052: [ On success tlsio_close shall return 0. ]*/
+            internal_close(tls_io_instance);
+            on_io_close_complete(callback_context);
+            result = 0;
+        }
+    }
+    /* Codes_SRS_TLSIO_30_054: [ On failure, the adapter shall not call on_io_close_complete. ]*/
+
+    return result;
+}
+
+static int ICACHE_FLASH_ATTR  decode_ssl_received_bytes(TLS_IO_INSTANCE* tls_io_instance);
+
+static void dowork_read(TLS_IO_INSTANCE* tls_io_instance)
+{
+    printf("==> dowork_read\n");
+    if (tls_io_instance != NULL)
+    {
+        if (tls_io_instance->tlsio_state == TLSIO_STATE_OPEN)
+        {
+            printf("decode recvd data\n");
+            decode_ssl_received_bytes(tls_io_instance);
+        }
+    }
+}
+
+
+static void dowork_send(TLS_IO_INSTANCE* tls_io_instance)
+{
+    printf("==> dowork_send\n");
+    /*printf("sending loop to drain the pending list\n");
+    LIST_ITEM_HANDLE first_pending_io;
+    
+    while ((first_pending_io = singlylinkedlist_get_head_item(tls_io_instance->pending_transmission_list))) {
+        PENDING_TRANSMISSION* pending_message = (PENDING_TRANSMISSION*)singlylinkedlist_item_get_value(first_pending_io);
+        uint8_t* buffer = ((uint8_t*)pending_message->bytes) +
+            pending_message->size - pending_message->unsent_size;
+        int write_result = mbedtls_ssl_write(&tls_io_instance->ssl, buffer, pending_message->unsent_size);
+        
+        if (write_result > 0)
+        {
+            pending_message->unsent_size -= write_result;
+            if (pending_message->unsent_size == 0)
+            {
+                printf("The whole message has been sent successfully\n");
+                process_and_destroy_head_message(tls_io_instance, IO_SEND_OK);
+            }
+            else
+            {
+                printf("Repeat the send on the next pass with the rest of the message\n");
+                // This empty else compiles to nothing but helps readability
+            }
+        }
+        else
+        {
+            // It may just be busy, or it may be broken.
+            if (write_result != MBEDTLS_ERR_SSL_WANT_READ && write_result != MBEDTLS_ERR_SSL_WANT_WRITE)
+            {
+                // This is an unexpected error, and we need to bail out. Probably lost internet connection.
+                LogInfo("Error from SSL_write: %d", hard_error);
+                process_and_destroy_head_message(tls_io_instance, IO_SEND_ERROR);
+            } else {
+                printf("it is busy, try later.\n");
+            }
+            return;
+        }
+        
+    }*/
+}
+
+static void dowork_poll_dns(TLS_IO_INSTANCE* tls_io_instance)
+{
+    printf("==> dowork_poll_dns\n");
+}
+
+static void dowork_poll_socket(TLS_IO_INSTANCE* tls_io_instance)
+{
+    printf("==> dowork_poll_socket\n");
+}
+
+static void dowork_poll_open_ssl(TLS_IO_INSTANCE* tls_io_instance)
+{
+    int result;
+    
+    printf("==> dowork_poll_open_ssl\n");
+    result = mbedtls_ssl_handshake(&tls_io_instance->ssl);
+    if (result == MBEDTLS_ERR_SSL_WANT_READ || result == MBEDTLS_ERR_SSL_WANT_WRITE) {
+        return;
+    }
+
+    printf("mem: %d\n", system_get_free_heap_size());
+    printf("result: %x\n", result);
+    if (result == 0)
+    {
+        printf("handshake successfully!!!!!\n");
+        tls_io_instance->tlsio_state = TLSIO_STATE_OPEN;
+        tls_io_instance->on_open_complete(tls_io_instance->on_open_complete_context, IO_OPEN_OK);
+    }
+    else
+    {
+        printf("handshake failed!!!\n");
+        enter_open_error_state(tls_io_instance);
+    }
+}
+
+static int ICACHE_FLASH_ATTR  decode_ssl_received_bytes(TLS_IO_INSTANCE* tls_io_instance)
+{
+    printf("==> decode_ssl_received_bytes\n");
+    int result = 0;
+    unsigned char buffer[64];
+    int rcv_bytes = 1;
+
+    while (rcv_bytes > 0)
+    {
+        rcv_bytes = mbedtls_ssl_read(&tls_io_instance->ssl, buffer, sizeof(buffer));
+        printf("rcv_bytes: %x\n", rcv_bytes);
+        if (rcv_bytes > 0)
+        {
+            printf("render data to mqtt_client\n");
+            if (tls_io_instance->on_bytes_received != NULL)
+            {
+                tls_io_instance->on_bytes_received(tls_io_instance->on_bytes_received_context, buffer, rcv_bytes);
+            }
+        } else {
+            switch (rcv_bytes) {
+            case MBEDTLS_ERR_SSL_INVALID_MAC:
+                printf("MBEDTLS_ERR_SSL_INVALID_MAC\n");
+                break;
+            case MBEDTLS_ERR_SSL_WANT_READ:
+                printf("MBEDTLS_ERR_SSL_WANT_READ\n");
+                break;
+            default:
+                break;
+            }
+        }
+    }
+
+    return result;
+}
+
+static void tlsio_mbedtls_dowork(CONCRETE_IO_HANDLE tls_io)
+{
+    if (tls_io == NULL)
+    {
+        /* Codes_SRS_TLSIO_30_070: [ If the tlsio_handle parameter is NULL, tlsio_dowork shall do nothing except log an error. ]*/
+        printf("NULL tlsio");
+    }
+    else
+    {
+        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;
+
+        // This switch statement handles all of the state transitions during the opening process
+        switch (tls_io_instance->tlsio_state)
+        {
+        case TLSIO_STATE_CLOSED:
+            /* Codes_SRS_TLSIO_30_075: [ If the adapter is in TLSIO_STATE_EXT_CLOSED then  tlsio_dowork  shall do nothing. ]*/
+            // Waiting to be opened, nothing to do
+            break;
+        case TLSIO_STATE_OPENING_WAITING_DNS:
+            dowork_poll_dns(tls_io_instance);
+            break;
+        case TLSIO_STATE_OPENING_WAITING_SOCKET:
+            dowork_poll_socket(tls_io_instance);
+            break;
+        case TLSIO_STATE_OPENING_WAITING_SSL:
+            dowork_poll_open_ssl(tls_io_instance);
+            break;
+        case TLSIO_STATE_OPEN:
+            dowork_read(tls_io_instance);
+            dowork_send(tls_io_instance);
+            
+            break;
+        case TLSIO_STATE_ERROR:
+            /* Codes_SRS_TLSIO_30_071: [ If the adapter is in TLSIO_STATE_EXT_ERROR then tlsio_dowork shall do nothing. ]*/
+            // There's nothing valid to do here but wait to be retried
+            break;
+        default:
+            printf("Unexpected internal tlsio state");
+            break;
+        }
+    }
+}
+
+static int tlsio_mbedtls_send_async(CONCRETE_IO_HANDLE tls_io, const void* buffer, size_t size, ON_SEND_COMPLETE on_send_complete, void* callback_context)
+{
+    int result = 0;
+    if (on_send_complete == NULL || tls_io == NULL || buffer == NULL || size == 0)
+    {
+        /* Codes_SRS_TLSIO_30_062: [ If the on_send_complete is NULL, tlsio_mbedtls_compact_send shall log the error and return FAILURE. ]*/
+        printf("NULL or 0 check fail");
+        return __FAILURE__;
+    }
+    
+    TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;
+    if (tls_io_instance->tlsio_state != TLSIO_STATE_OPEN)
+    {
+        /* Codes_SRS_TLSIO_30_065: [ If tlsio_mbedtls_compact_open has not been called or the opening process has not been completed, tlsio_mbedtls_compact_send shall log an error and return FAILURE. ]*/
+        printf("tlsio_mbedtls_send_async without a prior successful open");
+        return __FAILURE__;
+    }
+    
+    int write_result = mbedtls_ssl_write(&tls_io_instance->ssl, buffer, size);
+        
+    if (write_result == size)
+    {
+        printf("The whole message has been cached send\n");
+        on_send_complete(callback_context, IO_SEND_OK);
+    }
+    else
+    {
+        // It may just be busy, or it may be broken.
+        if (write_result != MBEDTLS_ERR_SSL_WANT_READ && write_result != MBEDTLS_ERR_SSL_WANT_WRITE)
+        {
+            // This is an unexpected error, and we need to bail out. Probably lost internet connection.
+            LogInfo("Error from SSL_write: %d", hard_error);
+            on_send_complete(callback_context, IO_SEND_ERROR);
+            return __FAILURE__;
+        } 
+        
+        printf("it is busy, try later.\n");
+    }
+    return result;
+}
+#if 0
+static int tlsio_mbedtls_setoption(CONCRETE_IO_HANDLE tls_io, const char* optionName, const void* value)
+{
+    TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;
+    /* Codes_SRS_TLSIO_30_120: [ If the tlsio_handle parameter is NULL, tlsio_mbedtls_compact_setoption shall do nothing except log an error and return FAILURE. ]*/
+    int result;
+    if (tls_io_instance == NULL)
+    {
+        printf("NULL tlsio");
+        result = __FAILURE__;
+    }
+    else
+    {
+        /* Codes_SRS_TLSIO_30_121: [ If the optionName parameter is NULL, tlsio_mbedtls_compact_setoption shall do nothing except log an error and return FAILURE. ]*/
+        /* Codes_SRS_TLSIO_30_122: [ If the value parameter is NULL, tlsio_mbedtls_compact_setoption shall do nothing except log an error and return FAILURE. ]*/
+        /* Codes_SRS_TLSIO_OPENSSL_COMPACT_30_520 [ The tlsio_setoption shall do nothing and return FAILURE. ]*/
+        TLSIO_OPTIONS_RESULT options_result = tlsio_options_set(&tls_io_instance->options, optionName, value);
+        if (options_result != TLSIO_OPTIONS_RESULT_SUCCESS)
+        {
+            printf("Failed tlsio_options_set");
+            result = __FAILURE__;
+        }
+        else
+        {
+            result = 0;
+        }
+    }
+    return result;
+}
+
+
+/* Codes_SRS_TLSIO_OPENSSL_COMPACT_30_560: [ The  tlsio_retrieveoptions  shall do nothing and return an empty options handler. ]*/
+static OPTIONHANDLER_HANDLE tlsio_mbedtls_retrieveoptions(CONCRETE_IO_HANDLE tls_io)
+{
+    TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;
+    /* Codes_SRS_TLSIO_30_160: [ If the tlsio_handle parameter is NULL, tlsio_mbedtls_compact_retrieveoptions shall do nothing except log an error and return FAILURE. ]*/
+    OPTIONHANDLER_HANDLE result;
+    if (tls_io_instance == NULL)
+    {
+        printf("NULL tlsio");
+        result = NULL;
+    }
+    else
+    {
+        result = tlsio_options_retrieve_options(&tls_io_instance->options, tlsio_mbedtls_setoption);
+    }
+    return result;
+}
+#else
+
+
+/*this function will clone an option given by name and value*/
+static void*  ICACHE_FLASH_ATTR tlsio_mbedtls_CloneOption(const char* name, const void* value)
+{
+    void* result;
+    if (
+        (name == NULL) || (value == NULL)
+        )
+    {
+        printf("invalid parameter detected: const char* name=%p, const void* value=%p", name, value);
+        result = NULL;
+    }
+    else
+    {
+        if (strcmp(name, OPTION_UNDERLYING_IO_OPTIONS) == 0)
+        {
+            result = (void*)value;
+        }
+        else if (strcmp(name, OPTION_TRUSTED_CERT) == 0)
+        {
+            if (mallocAndStrcpy_s((char**)&result, value) != 0)
+            {
+                printf("unable to mallocAndStrcpy_s TrustedCerts value");
+                result = NULL;
+            }
+            else
+            {
+                /*return as is*/
+            }
+        }
+        else
+        {
+            printf("not handled option : %s", name);
+            result = NULL;
+        }
+    }
+    return result;
+}
+
+/*this function destroys an option previously created*/
+static void ICACHE_FLASH_ATTR  tlsio_mbedtls_DestroyOption(const char* name, const void* value)
+{
+    /*since all options for this layer are actually string copies., disposing of one is just calling free*/
+    if (name == NULL || value == NULL)
+    {
+        printf("invalid parameter detected: const char* name=%p, const void* value=%p", name, value);
+    }
+    else
+    {
+        if (strcmp(name, OPTION_TRUSTED_CERT) == 0)
+        {
+            free((void*)value);
+        }
+        else if (strcmp(name, OPTION_UNDERLYING_IO_OPTIONS) == 0)
+        {
+            OptionHandler_Destroy((OPTIONHANDLER_HANDLE)value);
+        }
+        else
+        {
+            printf("not handled option : %s", name);
+        }
+    }
+}
+
+
+int  ICACHE_FLASH_ATTR tlsio_mbedtls_setoption(CONCRETE_IO_HANDLE tls_io, const char* optionName, const void* value)
+{
+    printf("==> tlsio_mbedtls_setoption\n");
+    int result;
+
+    if (tls_io == NULL || optionName == NULL)
+    {
+        result = __FAILURE__;
+    }
+    else
+    {
+        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;
+
+        if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)
+        {
+            if (tls_io_instance->trusted_certificates != NULL)
+            {
+                // Free the memory if it has been previously allocated
+                free(tls_io_instance->trusted_certificates);
+                tls_io_instance->trusted_certificates = NULL;
+            }
+            //if (mallocAndStrcpy_s(&tls_io_instance->trusted_certificates, (const char*)value) != 0)
+            //{
+            //    printf("unable to mallocAndStrcpy_s");
+            //    result = __FAILURE__;
+            //}
+            //else
+            //{
+                int parse_result = mbedtls_x509_crt_parse(&tls_io_instance->trusted_certificates_parsed, (const unsigned char *)value, (int)(strlen(value) + 1));
+                if (parse_result != 0)
+                {
+                    printf("Malformed pem certificate");
+                    result = __FAILURE__;
+                }
+                else
+                {
+                    mbedtls_ssl_conf_ca_chain(&tls_io_instance->config, &tls_io_instance->trusted_certificates_parsed, NULL);
+                    result = 0;
+                    printf("mbedtls_ssl_conf_ca_chain successfully!!!!!!!!!!!!!!!\n");
+                }
+            //}
+        }
+        else if (strcmp(OPTION_X509_CERT, optionName) == 0)
+        {
+            if (tls_io_instance->x509certificate != NULL)
+            {
+                printf("unable to set x509 options more than once");
+                result = __FAILURE__;
+            }
+            else
+            {
+                /*let's make a copy of this option*/
+                if (mallocAndStrcpy_s((char**)&tls_io_instance->x509certificate, value) != 0)
+                {
+                    printf("unable to mallocAndStrcpy_s");
+                    result = __FAILURE__;
+                }
+                else
+                {
+                    int parse_result = mbedtls_x509_crt_parse(&tls_io_instance->client_certificates_parsed, (const unsigned char *)value, (int)(strlen(value) + 1));
+                    if (parse_result != 0)
+                    {
+                        printf("Malformed pem certificate");
+                        result = __FAILURE__;
+                    }
+                    else
+                    {
+                        if (tls_io_instance->x509privatekey != NULL && tls_io_instance->x509certificate != NULL)
+                        {
+                            int set_key_result = mbedtls_ssl_conf_own_cert(&tls_io_instance->config, &tls_io_instance->client_certificates_parsed, &tls_io_instance->pk);
+
+                            if (set_key_result != 0)
+                            {
+                                printf("Fail to set private key and certificate");
+                                result = __FAILURE__;
+                            }
+                            else
+                            {
+                                result = 0;
+                            }
+                        }
+                        else
+                        {
+                            result = 0;
+                        }
+                    }
+                }
+            }
+        }
+        else if (strcmp(OPTION_X509_PRIVATE_KEY, optionName) == 0)
+        {
+            if (tls_io_instance->x509privatekey != NULL)
+            {
+                printf("unable to set more than once private key options");
+                result = __FAILURE__;
+            }
+            else
+            {
+                /*let's make a copy of this option*/
+                if (mallocAndStrcpy_s((char**)&tls_io_instance->x509privatekey, value) != 0)
+                {
+                    printf("unable to mallocAndStrcpy_s");
+                    result = __FAILURE__;
+                }
+                else
+                {
+                    int parse_result = mbedtls_pk_parse_key(&tls_io_instance->pk, (const unsigned char *)value, (int)(strlen(value) + 1), NULL, 0);
+                    if (parse_result != 0)
+                    {
+                        printf("Malformed pem private key");
+                        result = __FAILURE__;
+                    }
+                    else
+                    {
+                        if (tls_io_instance->x509privatekey != NULL && tls_io_instance->x509certificate != NULL)
+                        {
+                            int set_key_result = mbedtls_ssl_conf_own_cert(&tls_io_instance->config, &tls_io_instance->client_certificates_parsed, &tls_io_instance->pk);
+
+                            if (set_key_result != 0)
+                            {
+                                printf("Fail to set private key and certificate");
+                                result = __FAILURE__;
+                            }
+                            else
+                            {
+                                result = 0;
+                            }
+                        }
+                        else
+                        {
+                            result = 0;
+                        }
+                    }
+                }
+            }
+        }
+        else
+        {
+            // tls_io_instance->socket_io is never NULL
+            //result = xio_setoption(tls_io_instance->socket_io, optionName, value);
+        }
+    }
+
+    return result;
+}
+
+
+OPTIONHANDLER_HANDLE ICACHE_FLASH_ATTR  tlsio_mbedtls_retrieveoptions(CONCRETE_IO_HANDLE handle)
+{
+    OPTIONHANDLER_HANDLE result;
+    if (handle == NULL)
+    {
+        printf("invalid parameter detected: CONCRETE_IO_HANDLE handle=%p", handle);
+        result = NULL;
+    }
+    else
+    {
+        result = OptionHandler_Create(tlsio_mbedtls_CloneOption, tlsio_mbedtls_DestroyOption, tlsio_mbedtls_setoption);
+        if (result == NULL)
+        {
+            printf("unable to OptionHandler_Create");
+            /*return as is*/
+        }
+        else
+        {
+            /*this layer cares about the certificates*/
+            TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)handle;
+
+            if (tls_io_instance->trusted_certificates != NULL &&
+                OptionHandler_AddOption(result, OPTION_TRUSTED_CERT, tls_io_instance->trusted_certificates) != OPTIONHANDLER_OK)
+            {
+                printf("unable to save TrustedCerts option");
+                OptionHandler_Destroy(result);
+                result = NULL;
+            }
+            else
+            {
+                /*all is fine, all interesting options have been saved*/
+                /*return as is*/
+            }
+        }
+    }
+    return result;
+}
+#endif
+
+/* Codes_SRS_TLSIO_30_008: [ The tlsio_get_interface_description shall return the VTable IO_INTERFACE_DESCRIPTION. ]*/
+static const IO_INTERFACE_DESCRIPTION tlsio_mbedtls_interface_description =
+{
+    tlsio_mbedtls_retrieveoptions,
+    tlsio_mbedtls_create,
+    tlsio_mbedtls_destroy,
+    tlsio_mbedtls_open_async,
+    tlsio_mbedtls_close_async,
+    tlsio_mbedtls_send_async,
+    tlsio_mbedtls_dowork,
+    tlsio_mbedtls_setoption
+};
+
+/* Codes_SRS_TLSIO_30_001: [ The tlsio_mbedtls_compact shall implement and export all the Concrete functions in the VTable IO_INTERFACE_DESCRIPTION defined in the xio.h. ]*/
+const IO_INTERFACE_DESCRIPTION* tlsio_pal_get_interface_description(void)
+{
+    return &tlsio_mbedtls_interface_description;
+}
diff -uNr src/tlsio_options.c src_ok/tlsio_options.c
--- src/tlsio_options.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/tlsio_options.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,17 +1,17 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdlib.h>
+//#include <stdlib.h>
 
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/tlsio_options.h"
-#include "azure_c_shared_utility/shared_util_options.h"
-#include "azure_c_shared_utility/xlogging.h"
-#include "azure_c_shared_utility/crt_abstractions.h"
+#include "esp_types.h"
+#include "tlsio_options.h"
+#include "shared_util_options.h"
+#include "xlogging.h"
+#include "crt_abstractions.h"
 
 
 // Initialize the TLSIO_OPTIONS struct
-void tlsio_options_initialize(TLSIO_OPTIONS* options, int supported_options)
+void  ICACHE_FLASH_ATTR tlsio_options_initialize(TLSIO_OPTIONS* options, int supported_options)
 {
     // Using static function rules, so 'options' is not checked for NULL
     //
@@ -25,13 +25,13 @@
     options->x509_key = NULL;
 }
 
-static int set_and_validate_x509_type(TLSIO_OPTIONS* options, TLSIO_OPTIONS_x509_TYPE x509_type)
+static int  ICACHE_FLASH_ATTR set_and_validate_x509_type(TLSIO_OPTIONS* options, TLSIO_OPTIONS_x509_TYPE x509_type)
 {
     int result;
     if ((options->supported_options & x509_type) == 0)
     {
         // This case also rejects the nonsensical TLSIO_OPTIONS_x509_TYPE_UNSPECIFIED
-        LogError("Unsupported x509 type: %d", x509_type);
+        printf("Unsupported x509 type: %d", x509_type);
         result = __FAILURE__;
     }
     else if (options->x509_type == TLSIO_OPTIONS_x509_TYPE_UNSPECIFIED)
@@ -42,7 +42,7 @@
     }
     else if (options->x509_type != x509_type)
     {
-        LogError("Supplied x509 type conflicts with previously set x509");
+        printf("Supplied x509 type conflicts with previously set x509");
         result = __FAILURE__;
     }
     else
@@ -54,7 +54,7 @@
     return result;
 }
 
-void tlsio_options_release_resources(TLSIO_OPTIONS* options)
+void  ICACHE_FLASH_ATTR tlsio_options_release_resources(TLSIO_OPTIONS* options)
 {
     if (options != NULL)
     {
@@ -64,11 +64,11 @@
     }
     else
     {
-        LogError("NULL options");
+        printf("NULL options");
     }
 }
 
-static bool is_supported_string_option(const char* name)
+static bool ICACHE_FLASH_ATTR  is_supported_string_option(const char* name)
 {
     return 
         (strcmp(name, OPTION_TRUSTED_CERT) == 0) ||
@@ -78,12 +78,12 @@
         (strcmp(name, OPTION_X509_ECC_KEY) == 0);
 }
 
-TLSIO_OPTIONS_RESULT tlsio_options_destroy_option(const char* name, const void* value)
+TLSIO_OPTIONS_RESULT  ICACHE_FLASH_ATTR tlsio_options_destroy_option(const char* name, const void* value)
 {
     TLSIO_OPTIONS_RESULT result;
     if (name == NULL || value == NULL)
     {
-        LogError("NULL parameter: name: %p, value: %p", name, value);
+        printf("NULL parameter: name: %p, value: %p", name, value);
         result = TLSIO_OPTIONS_RESULT_ERROR;
     }
     else if (is_supported_string_option(name))
@@ -98,13 +98,13 @@
     return result;
 }
 
-TLSIO_OPTIONS_RESULT tlsio_options_clone_option(const char* name, const void* value, void** out_value)
+TLSIO_OPTIONS_RESULT ICACHE_FLASH_ATTR  tlsio_options_clone_option(const char* name, const void* value, void** out_value)
 {
     TLSIO_OPTIONS_RESULT result;
 
     if (name == NULL || value == NULL || out_value == NULL)
     {
-        LogError("NULL parameter: name: %p, value: %p, out_value: %p",
+        printf("NULL parameter: name: %p, value: %p, out_value: %p",
             name, value, out_value);
         result = TLSIO_OPTIONS_RESULT_ERROR;
     }
@@ -113,7 +113,7 @@
         *out_value = NULL;
         if (mallocAndStrcpy_s((char**)out_value, value) != 0)
         {
-            LogError("unable to mallocAndStrcpy_s option value");
+            printf("unable to mallocAndStrcpy_s option value");
             result = TLSIO_OPTIONS_RESULT_ERROR;
         }
         else
@@ -128,7 +128,7 @@
     return result;
 }
 
-TLSIO_OPTIONS_RESULT tlsio_options_set(TLSIO_OPTIONS* options,
+TLSIO_OPTIONS_RESULT ICACHE_FLASH_ATTR  tlsio_options_set(TLSIO_OPTIONS* options,
     const char* optionName, const void* value)
 {
     TLSIO_OPTIONS_RESULT result;
@@ -136,7 +136,7 @@
 
     if (options == NULL || optionName == NULL || value == NULL)
     {
-        LogError("NULL parameter: options: %p, optionName: %p, value: %p",
+        printf("NULL parameter: options: %p, optionName: %p, value: %p",
             options, optionName, value);
         result = TLSIO_OPTIONS_RESULT_ERROR;
     }
@@ -146,19 +146,19 @@
     }
     else if(mallocAndStrcpy_s(&copied_value, value) != 0)
     {
-        LogError("unable to mallocAndStrcpy_s option value");
+        printf("unable to mallocAndStrcpy_s option value");
         result = TLSIO_OPTIONS_RESULT_ERROR;
     }
     else if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)
     {
         if ((options->supported_options & TLSIO_OPTION_BIT_TRUSTED_CERTS) == 0)
         {
-            LogError("Trusted certs option not supported");
+            printf("Trusted certs option not supported");
             result = TLSIO_OPTIONS_RESULT_ERROR;
         }
         else if (options->trusted_certs != NULL)
         {
-            LogError("unable to set trusted cert option more than once");
+            printf("unable to set trusted cert option more than once");
             result = TLSIO_OPTIONS_RESULT_ERROR;
         }
         else
@@ -172,7 +172,7 @@
         TLSIO_OPTIONS_x509_TYPE this_type = (strcmp(SU_OPTION_X509_CERT, optionName) == 0) ? TLSIO_OPTIONS_x509_TYPE_RSA : TLSIO_OPTIONS_x509_TYPE_ECC;
         if (options->x509_cert != NULL)
         {
-            LogError("unable to set x509 cert more than once");
+            printf("unable to set x509 cert more than once");
             result = TLSIO_OPTIONS_RESULT_ERROR;
         }
         else if (set_and_validate_x509_type(options, this_type) != 0)
@@ -191,7 +191,7 @@
         TLSIO_OPTIONS_x509_TYPE this_type = (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0) ? TLSIO_OPTIONS_x509_TYPE_RSA : TLSIO_OPTIONS_x509_TYPE_ECC;
         if (options->x509_key != NULL)
         {
-            LogError("unable to set x509 key more than once");
+            printf("unable to set x509 key more than once");
             result = TLSIO_OPTIONS_RESULT_ERROR;
         }
         else if (set_and_validate_x509_type(options, this_type) != 0)
@@ -220,38 +220,38 @@
 }
 
 // A helper that works if the tlsio does not use any extra options
-static void* local_clone_option(const char* name, const void* value)
+static void* ICACHE_FLASH_ATTR  local_clone_option(const char* name, const void* value)
 {
     void* result = NULL;
     if (tlsio_options_clone_option(name, value, &result) != TLSIO_OPTIONS_RESULT_SUCCESS)
     {
-        LogError("Unexpected local_clone_option failure");
+        printf("Unexpected local_clone_option failure");
     }
     return result;
 }
 
 // A helper that works if the tlsio does not use any extra options
-void local_destroy_option(const char* name, const void* value)
+void  ICACHE_FLASH_ATTR local_destroy_option(const char* name, const void* value)
 {
     if (tlsio_options_destroy_option(name, value) != TLSIO_OPTIONS_RESULT_SUCCESS)
     {
-        LogError("Unexpected local_destroy_option failure");
+        printf("Unexpected local_destroy_option failure");
     }
 }
 
-OPTIONHANDLER_HANDLE tlsio_options_retrieve_options(TLSIO_OPTIONS* options, pfSetOption setOption)
+OPTIONHANDLER_HANDLE ICACHE_FLASH_ATTR  tlsio_options_retrieve_options(TLSIO_OPTIONS* options, pfSetOption setOption)
 {
     return tlsio_options_retrieve_options_ex(options, local_clone_option, local_destroy_option, setOption);
 }
 
 
-OPTIONHANDLER_HANDLE tlsio_options_retrieve_options_ex(TLSIO_OPTIONS* options,
+OPTIONHANDLER_HANDLE ICACHE_FLASH_ATTR  tlsio_options_retrieve_options_ex(TLSIO_OPTIONS* options,
     pfCloneOption cloneOption, pfDestroyOption destroyOption, pfSetOption setOption)
 {
     OPTIONHANDLER_HANDLE result;
     if (options == NULL || cloneOption == NULL || destroyOption == NULL || setOption == NULL)
     {
-        LogError("Null parameter in options: %p, cloneOption: %p, destroyOption: %p, setOption: %p",
+        printf("Null parameter in options: %p, cloneOption: %p, destroyOption: %p, setOption: %p",
             options, cloneOption, destroyOption, setOption);
         result = NULL;
     }
@@ -260,7 +260,7 @@
         result = OptionHandler_Create(cloneOption, destroyOption, setOption);
         if (result == NULL)
         {
-            LogError("OptionHandler_Create failed");
+            printf("OptionHandler_Create failed");
             /*return as is*/
         }
         else if (
@@ -268,7 +268,7 @@
                 (OptionHandler_AddOption(result, OPTION_TRUSTED_CERT, options->trusted_certs) != OPTIONHANDLER_OK)
                 )
         {
-            LogError("unable to save TrustedCerts option");
+            printf("unable to save TrustedCerts option");
             OptionHandler_Destroy(result);
             result = NULL;
         }
@@ -291,7 +291,7 @@
                 (OptionHandler_AddOption(result, x509_cert_option, options->x509_cert) != OPTIONHANDLER_OK)
                 )
             {
-                LogError("unable to save x509 cert option");
+                printf("unable to save x509 cert option");
                 OptionHandler_Destroy(result);
                 result = NULL;
             }
@@ -300,7 +300,7 @@
                 (OptionHandler_AddOption(result, x509_key_option, options->x509_key) != OPTIONHANDLER_OK)
                 )
             {
-                LogError("unable to save x509 key option");
+                printf("unable to save x509 key option");
                 OptionHandler_Destroy(result);
                 result = NULL;
             }
diff -uNr src/usha.c src_ok/usha.c
--- src/usha.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/usha.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,263 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-/**************************** usha.c ****************************/
-/******************** See RFC 4634 for details ******************/
-/*
-*  Description:
-*     This file implements a unified interface to the SHA algorithms.
-*/
-
-#include "azure_c_shared_utility/sha.h"
-
-/*
-*  USHAReset
-*
-*  Description:
-*      This function will initialize the SHA Context in preparation
-*      for computing a new SHA message digest.
-*
-*  Parameters:
-*      context: [in/out]
-*          The context to reset.
-*      whichSha: [in]
-*          Selects which SHA reset to call
-*
-*  Returns:
-*      sha Error Code.
-*
-*/
-int USHAReset(USHAContext *ctx, enum SHAversion whichSha)
-{
-    if (ctx) {
-        ctx->whichSha = whichSha;
-        switch (whichSha) {
-        case SHA1:   return SHA1Reset((SHA1Context*)&ctx->ctx);
-        case SHA224: return SHA224Reset((SHA224Context*)&ctx->ctx);
-        case SHA256: return SHA256Reset((SHA256Context*)&ctx->ctx);
-        case SHA384: return SHA384Reset((SHA384Context*)&ctx->ctx);
-        case SHA512: return SHA512Reset((SHA512Context*)&ctx->ctx);
-        default: return shaBadParam;
-        }
-    }
-    else {
-        return shaNull;
-    }
-}
-
-/*
-*  USHAInput
-*
-*  Description:
-*      This function accepts an array of octets as the next portion
-*      of the message.
-*
-*  Parameters:
-*      context: [in/out]
-*          The SHA context to update
-*      message_array: [in]
-*          An array of characters representing the next portion of
-*          the message.
-*      length: [in]
-*          The length of the message in message_array
-*
-*  Returns:
-*      sha Error Code.
-*
-*/
-int USHAInput(USHAContext *ctx,
-    const uint8_t *bytes, unsigned int bytecount)
-{
-    if (ctx) {
-        switch (ctx->whichSha) {
-        case SHA1:
-            return SHA1Input((SHA1Context*)&ctx->ctx, bytes, bytecount);
-        case SHA224:
-            return SHA224Input((SHA224Context*)&ctx->ctx, bytes,
-                bytecount);
-        case SHA256:
-            return SHA256Input((SHA256Context*)&ctx->ctx, bytes,
-                bytecount);
-        case SHA384:
-            return SHA384Input((SHA384Context*)&ctx->ctx, bytes,
-                bytecount);
-        case SHA512:
-            return SHA512Input((SHA512Context*)&ctx->ctx, bytes,
-                bytecount);
-        default: return shaBadParam;
-        }
-    }
-    else {
-        return shaNull;
-    }
-}
-
-/*
-* USHAFinalBits
-*
-* Description:
-*   This function will add in any final bits of the message.
-*
-* Parameters:
-*   context: [in/out]
-*     The SHA context to update
-*   message_bits: [in]
-*     The final bits of the message, in the upper portion of the
-*     byte. (Use 0b###00000 instead of 0b00000### to input the
-*     three bits ###.)
-*   length: [in]
-*     The number of bits in message_bits, between 1 and 7.
-*
-* Returns:
-*   sha Error Code.
-*/
-int USHAFinalBits(USHAContext *ctx,
-const uint8_t bits, unsigned int bitcount)
-{
-    if (ctx) {
-        switch (ctx->whichSha) {
-        case SHA1:
-            return SHA1FinalBits((SHA1Context*)&ctx->ctx, bits, bitcount);
-        case SHA224:
-            return SHA224FinalBits((SHA224Context*)&ctx->ctx, bits,
-                bitcount);
-        case SHA256:
-            return SHA256FinalBits((SHA256Context*)&ctx->ctx, bits,
-                bitcount);
-        case SHA384:
-            return SHA384FinalBits((SHA384Context*)&ctx->ctx, bits,
-                bitcount);
-        case SHA512:
-            return SHA512FinalBits((SHA512Context*)&ctx->ctx, bits,
-                bitcount);
-        default: return shaBadParam;
-        }
-    }
-    else {
-        return shaNull;
-    }
-}
-
-/*
-* USHAResult
-*
-* Description:
-*   This function will return the 160-bit message digest into the
-*   Message_Digest array provided by the caller.
-*   NOTE: The first octet of hash is stored in the 0th element,
-*      the last octet of hash in the 19th element.
-*
-* Parameters:
-*   context: [in/out]
-*     The context to use to calculate the SHA-1 hash.
-*   Message_Digest: [out]
-*     Where the digest is returned.
-*
-* Returns:
-*   sha Error Code.
-*
-*/
-int USHAResult(USHAContext *ctx,
-    uint8_t Message_Digest[USHAMaxHashSize])
-{
-    if (ctx) {
-        switch (ctx->whichSha) {
-        case SHA1:
-            return SHA1Result((SHA1Context*)&ctx->ctx, Message_Digest);
-        case SHA224:
-            return SHA224Result((SHA224Context*)&ctx->ctx, Message_Digest);
-        case SHA256:
-            return SHA256Result((SHA256Context*)&ctx->ctx, Message_Digest);
-        case SHA384:
-            return SHA384Result((SHA384Context*)&ctx->ctx, Message_Digest);
-        case SHA512:
-            return SHA512Result((SHA512Context*)&ctx->ctx, Message_Digest);
-        default: return shaBadParam;
-        }
-    }
-    else {
-        return shaNull;
-    }
-}
-
-/*
-* USHABlockSize
-*
-* Description:
-*   This function will return the blocksize for the given SHA
-*   algorithm.
-*
-* Parameters:
-*   whichSha:
-*     which SHA algorithm to query
-*
-* Returns:
-*   block size
-*
-*/
-int USHABlockSize(enum SHAversion whichSha)
-{
-    switch (whichSha) {
-    case SHA1:   return SHA1_Message_Block_Size;
-    case SHA224: return SHA224_Message_Block_Size;
-    case SHA256: return SHA256_Message_Block_Size;
-    case SHA384: return SHA384_Message_Block_Size;
-    default:
-    case SHA512: return SHA512_Message_Block_Size;
-    }
-}
-
-/*
-* USHAHashSize
-*
-* Description:
-*   This function will return the hashsize for the given SHA
-*   algorithm.
-*
-* Parameters:
-*   whichSha:
-*     which SHA algorithm to query
-*
-* Returns:
-*   hash size
-*
-*/
-int USHAHashSize(enum SHAversion whichSha)
-{
-    switch (whichSha) {
-    case SHA1:   return SHA1HashSize;
-    case SHA224: return SHA224HashSize;
-    case SHA256: return SHA256HashSize;
-    case SHA384: return SHA384HashSize;
-    default:
-    case SHA512: return SHA512HashSize;
-    }
-}
-
-/*
-* USHAHashSizeBits
-*
-* Description:
-*   This function will return the hashsize for the given SHA
-*   algorithm, expressed in bits.
-*
-* Parameters:
-*   whichSha:
-*     which SHA algorithm to query
-*
-* Returns:
-*   hash size in bits
-*
-*/
-int USHAHashSizeBits(enum SHAversion whichSha)
-{
-    switch (whichSha) {
-    case SHA1:   return SHA1HashSizeBits;
-    case SHA224: return SHA224HashSizeBits;
-    case SHA256: return SHA256HashSizeBits;
-    case SHA384: return SHA384HashSizeBits;
-    default:
-    case SHA512: return SHA512HashSizeBits;
-    }
-}
-
diff -uNr src/utf8_checker.c src_ok/utf8_checker.c
--- src/utf8_checker.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/utf8_checker.c	2018-09-03 16:45:36.000000000 +0800
@@ -6,15 +6,16 @@
 #include <cstddef>
 #include <cstdint>
 #else
-#include <stdlib.h>
-#include <stdbool.h>
-#include <stddef.h>
-#include <stdint.h>
+//#include <stdlib.h>
+//#include <stdbool.h>
+//#include <stddef.h>
+//#include <stdint.h>
 #endif
 
-#include "azure_c_shared_utility/utf8_checker.h"
+#include "esp_types.h"
+#include "utf8_checker.h"
 
-bool utf8_checker_is_valid_utf8(const unsigned char* utf8_str, size_t length)
+bool  ICACHE_FLASH_ATTR utf8_checker_is_valid_utf8(const unsigned char* utf8_str, size_t length)
 {
     bool result;
 
diff -uNr src/vector.c src_ok/vector.c
--- src/vector.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/vector.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,22 +1,20 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdlib.h>
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/vector.h"
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/xlogging.h"
+#include "esp_types.h"
+#include "vector.h"
+#include "xlogging.h"
 
-#include "azure_c_shared_utility/vector_types_internal.h"
+#include "vector_types_internal.h"
 
-VECTOR_HANDLE VECTOR_create(size_t elementSize)
+VECTOR_HANDLE  ICACHE_FLASH_ATTR VECTOR_create(size_t elementSize)
 {
     VECTOR_HANDLE result;
 
     /* Codes_SRS_VECTOR_10_002: [VECTOR_create shall fail and return NULL if elementsize is 0.] */
     if (elementSize == 0)
     {
-        LogError("invalid elementSize(%zd).", elementSize);
+        printf("invalid elementSize(%zd).", elementSize);
         result = NULL;
     }
     else
@@ -25,7 +23,7 @@
         /* Codes_SRS_VECTOR_10_002 : [VECTOR_create shall fail and return NULL if malloc fails.] */
         if (result == NULL)
         {
-            LogError("malloc failed.");
+            printf("malloc failed.");
         }
         else
         {
@@ -38,12 +36,12 @@
     return result;
 }
 
-void VECTOR_destroy(VECTOR_HANDLE handle)
+void  ICACHE_FLASH_ATTR VECTOR_destroy(VECTOR_HANDLE handle)
 {
     /* Codes_SRS_VECTOR_10_009: [VECTOR_destroy shall return if the given handle is NULL.] */
     if (handle == NULL)
     {
-        LogError("invalid argument handle(NULL).");
+        printf("invalid argument handle(NULL).");
     }
     else
     {
@@ -53,13 +51,13 @@
     }
 }
 
-VECTOR_HANDLE VECTOR_move(VECTOR_HANDLE handle)
+VECTOR_HANDLE ICACHE_FLASH_ATTR  VECTOR_move(VECTOR_HANDLE handle)
 {
     VECTOR_HANDLE result;
     if (handle == NULL)
     {
         /* Codes_SRS_VECTOR_10_005: [VECTOR_move shall fail and return NULL if the given handle is NULL.] */
-        LogError("invalid argument - handle(NULL).");
+        printf("invalid argument - handle(NULL).");
         result = NULL;
     }
     else
@@ -68,7 +66,7 @@
         if (result == NULL)
         {
             /* Codes_SRS_VECTOR_10_006: [VECTOR_move shall fail and return NULL if malloc fails.] */
-            LogError("malloc failed.");
+            printf("malloc failed.");
         }
         else
         {
@@ -86,7 +84,7 @@
 
 /* insertion */
 
-int VECTOR_push_back(VECTOR_HANDLE handle, const void* elements, size_t numElements)
+int  ICACHE_FLASH_ATTR VECTOR_push_back(VECTOR_HANDLE handle, const void* elements, size_t numElements)
 {
     int result;
     if (handle == NULL || elements == NULL || numElements == 0)
@@ -94,7 +92,7 @@
        /* Codes_SRS_VECTOR_10_011: [VECTOR_push_back shall fail and return non-zero if `handle` is NULL.] */
        /* Codes_SRS_VECTOR_10_034: [VECTOR_push_back shall fail and return non-zero if `elements` is NULL.] */
        /* Codes_SRS_VECTOR_10_035: [VECTOR_push_back shall fail and return non-zero if `numElements` is 0.] */
-        LogError("invalid argument - handle(%p), elements(%p), numElements(%zd).", handle, elements, numElements);
+        printf("invalid argument - handle(%p), elements(%p), numElements(%zd).", handle, elements, numElements);
         result = __FAILURE__;
     }
     else
@@ -106,7 +104,7 @@
         if (temp == NULL)
         {
            /* Codes_SRS_VECTOR_10_012: [VECTOR_push_back shall fail and return non-zero if memory allocation fails.] */
-            LogError("realloc failed.");
+            printf("realloc failed.");
             result = __FAILURE__;
         }
         else
@@ -123,21 +121,21 @@
 
 /* removal */
 
-void VECTOR_erase(VECTOR_HANDLE handle, void* elements, size_t numElements)
+void  ICACHE_FLASH_ATTR VECTOR_erase(VECTOR_HANDLE handle, void* elements, size_t numElements)
 {
     if (handle == NULL || elements == NULL || numElements == 0)
     {
         /* Codes_SRS_VECTOR_10_015: [VECTOR_erase shall return if `handle` is NULL.] */
         /* Codes_SRS_VECTOR_10_038: [VECTOR_erase shall return if `elements` is NULL.] */
         /* Codes_SRS_VECTOR_10_039: [VECTOR_erase shall return if `numElements` is 0.] */
-        LogError("invalid argument - handle(%p), elements(%p), numElements(%zd).", handle, elements, numElements);
+        printf("invalid argument - handle(%p), elements(%p), numElements(%zd).", handle, elements, numElements);
     }
     else
     {
         if (elements < handle->storage)
         {
             /* Codes_SRS_VECTOR_10_040: [VECTOR_erase shall return if `elements` is out of bound.] */
-            LogError("invalid argument elements(%p) is not a member of this object.", elements);
+            printf("invalid argument elements(%p) is not a member of this object.", elements);
         }
         else
         {
@@ -145,7 +143,7 @@
             if ((diff % handle->elementSize) != 0)
             {
                 /* Codes_SRS_VECTOR_10_041: [VECTOR_erase shall return if elements is misaligned.] */
-                LogError("invalid argument - elements(%p) is misaligned", elements);
+                printf("invalid argument - elements(%p) is misaligned", elements);
             }
             else
             {
@@ -155,7 +153,7 @@
                 if (src > srcEnd)
                 {
                     /* Codes_SRS_VECTOR_10_040: [VECTOR_erase shall return if `elements` is out of bound.] */
-                    LogError("invalid argument - numElements(%zd) is out of bound.", numElements);
+                    printf("invalid argument - numElements(%zd) is out of bound.", numElements);
                 }
                 else
                 {
@@ -186,12 +184,12 @@
     }
 }
 
-void VECTOR_clear(VECTOR_HANDLE handle)
+void  ICACHE_FLASH_ATTR VECTOR_clear(VECTOR_HANDLE handle)
 {
     /* Codes_SRS_VECTOR_10_017: [VECTOR_clear shall if the object is NULL or empty.] */
     if (handle == NULL)
     {
-        LogError("invalid argument handle(NULL).");
+        printf("invalid argument handle(NULL).");
     }
     else
     {
@@ -204,13 +202,13 @@
 
 /* access */
 
-void* VECTOR_element(VECTOR_HANDLE handle, size_t index)
+void*  ICACHE_FLASH_ATTR VECTOR_element(VECTOR_HANDLE handle, size_t index)
 {
     void* result;
     if (handle == NULL)
     {
         /* Codes_SRS_VECTOR_10_019: [VECTOR_element shall fail and return NULL if handle is NULL.] */
-        LogError("invalid argument handle(NULL).");
+        printf("invalid argument handle(NULL).");
         result = NULL;
     }
     else
@@ -218,7 +216,7 @@
         if (index >= handle->count)
         {
             /* Codes_SRS_VECTOR_10_020: [VECTOR_element shall fail and return NULL if the given index is out of range.] */
-            LogError("invalid argument - index(%zd); should be >= 0 and < %zd.", index, handle->count);
+            printf("invalid argument - index(%zd); should be >= 0 and < %zd.", index, handle->count);
             result = NULL;
         }
         else
@@ -230,13 +228,13 @@
     return result;
 }
 
-void* VECTOR_front(VECTOR_HANDLE handle)
+void* ICACHE_FLASH_ATTR  VECTOR_front(VECTOR_HANDLE handle)
 {
     void* result;
     if (handle == NULL)
     {
         /* Codes_SRS_VECTOR_10_022: [VECTOR_front shall fail and return NULL if handle is NULL.] */
-        LogError("invalid argument handle (NULL).");
+        printf("invalid argument handle (NULL).");
         result = NULL;
     }
     else
@@ -244,7 +242,7 @@
         if (handle->count == 0)
         {
             /* Codes_SRS_VECTOR_10_028: [VECTOR_front shall return NULL if the vector is empty.] */
-            LogError("vector is empty.");
+            printf("vector is empty.");
             result = NULL;
         }
         else
@@ -256,13 +254,13 @@
     return result;
 }
 
-void* VECTOR_back(VECTOR_HANDLE handle)
+void*  ICACHE_FLASH_ATTR VECTOR_back(VECTOR_HANDLE handle)
 {
     void* result;
     if (handle == NULL)
     {
         /* Codes_SRS_VECTOR_10_024: [VECTOR_back shall fail and return NULL if handle is NULL.] */
-        LogError("invalid argument handle (NULL).");
+        printf("invalid argument handle (NULL).");
         result = NULL;
     }
     else
@@ -270,7 +268,7 @@
         if (handle->count == 0)
         {
             /* Codes_SRS_VECTOR_10_029: [VECTOR_back shall return NULL if the vector is empty.] */
-            LogError("vector is empty.");
+            printf("vector is empty.");
             result = NULL;
         }
         else
@@ -282,14 +280,14 @@
     return result;
 }
 
-void* VECTOR_find_if(VECTOR_HANDLE handle, PREDICATE_FUNCTION pred, const void* value)
+void*  ICACHE_FLASH_ATTR VECTOR_find_if(VECTOR_HANDLE handle, PREDICATE_FUNCTION pred, const void* value)
 {
     void* result;
     if (handle == NULL || pred == NULL)
     {
         /* Codes_SRS_VECTOR_10_030: [VECTOR_find_if shall fail and return NULL if `handle` is NULL.] */
         /* Codes_SRS_VECTOR_10_036: [VECTOR_find_if shall fail and return NULL if `pred` is NULL.] */
-        LogError("invalid argument - handle(%p), pred(%p)", handle, pred);
+        printf("invalid argument - handle(%p), pred(%p)", handle, pred);
         result = NULL;
     }
     else
@@ -320,13 +318,13 @@
 
 /* capacity */
 
-size_t VECTOR_size(VECTOR_HANDLE handle)
+size_t ICACHE_FLASH_ATTR  VECTOR_size(VECTOR_HANDLE handle)
 {
     size_t result;
     if (handle == NULL)
     {
         /* Codes_SRS_VECTOR_10_026: [**VECTOR_size shall return 0 if the given handle is NULL.] */
-        LogError("invalid argument handle(NULL).");
+        printf("invalid argument handle(NULL).");
         result = 0;
     }
     else
diff -uNr src/xio.c src_ok/xio.c
--- src/xio.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/xio.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,12 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include <stdlib.h>
-#include <stddef.h>
-#include "azure_c_shared_utility/gballoc.h"
-#include "azure_c_shared_utility/optimize_size.h"
-#include "azure_c_shared_utility/xio.h"
-#include "azure_c_shared_utility/xlogging.h"
+#include "esp_types.h"
+#include "xio.h"
+#include "xlogging.h"
 
 static const char* CONCRETE_OPTIONS = "concreteOptions";
 
@@ -16,7 +13,7 @@
     CONCRETE_IO_HANDLE concrete_xio_handle;
 } XIO_INSTANCE;
 
-XIO_HANDLE xio_create(const IO_INTERFACE_DESCRIPTION* io_interface_description, const void* xio_create_parameters)
+XIO_HANDLE ICACHE_FLASH_ATTR  xio_create(const IO_INTERFACE_DESCRIPTION* io_interface_description, const void* xio_create_parameters)
 {
     XIO_INSTANCE* xio_instance;
     /* Codes_SRS_XIO_01_003: [If the argument io_interface_description is NULL, xio_create shall return NULL.] */
@@ -57,7 +54,7 @@
     return (XIO_HANDLE)xio_instance;
 }
 
-void xio_destroy(XIO_HANDLE xio)
+void ICACHE_FLASH_ATTR  xio_destroy(XIO_HANDLE xio)
 {
     /* Codes_SRS_XIO_01_007: [If the argument io is NULL, xio_destroy shall do nothing.] */
     if (xio != NULL)
@@ -72,7 +69,7 @@
     }
 }
 
-int xio_open(XIO_HANDLE xio, ON_IO_OPEN_COMPLETE on_io_open_complete, void* on_io_open_complete_context, ON_BYTES_RECEIVED on_bytes_received, void* on_bytes_received_context, ON_IO_ERROR on_io_error, void* on_io_error_context)
+int  ICACHE_FLASH_ATTR xio_open(XIO_HANDLE xio, ON_IO_OPEN_COMPLETE on_io_open_complete, void* on_io_open_complete_context, ON_BYTES_RECEIVED on_bytes_received, void* on_bytes_received_context, ON_IO_ERROR on_io_error, void* on_io_error_context)
 {
     int result;
 
@@ -101,7 +98,7 @@
     return result;
 }
 
-int xio_close(XIO_HANDLE xio, ON_IO_CLOSE_COMPLETE on_io_close_complete, void* callback_context)
+int ICACHE_FLASH_ATTR  xio_close(XIO_HANDLE xio, ON_IO_CLOSE_COMPLETE on_io_close_complete, void* callback_context)
 {
     int result;
 
@@ -130,7 +127,7 @@
     return result;
 }
 
-int xio_send(XIO_HANDLE xio, const void* buffer, size_t size, ON_SEND_COMPLETE on_send_complete, void* callback_context)
+int ICACHE_FLASH_ATTR  xio_send(XIO_HANDLE xio, const void* buffer, size_t size, ON_SEND_COMPLETE on_send_complete, void* callback_context)
 {
     int result;
 
@@ -154,7 +151,7 @@
     return result;
 }
 
-void xio_dowork(XIO_HANDLE xio)
+void ICACHE_FLASH_ATTR  xio_dowork(XIO_HANDLE xio)
 {
     /* Codes_SRS_XIO_01_018: [When the handle argument is NULL, xio_dowork shall do nothing.] */
     if (xio != NULL)
@@ -166,7 +163,7 @@
     }
 }
 
-int xio_setoption(XIO_HANDLE xio, const char* optionName, const void* value)
+int ICACHE_FLASH_ATTR  xio_setoption(XIO_HANDLE xio, const char* optionName, const void* value)
 {
     int result;
 
@@ -184,7 +181,7 @@
             /*then value is a pointer to OPTIONHANDLER_HANDLE*/
             if (OptionHandler_FeedOptions((OPTIONHANDLER_HANDLE)value, xio_instance->concrete_xio_handle) != OPTIONHANDLER_OK)
             {
-                LogError("unable to OptionHandler_FeedOptions");
+                printf("unable to OptionHandler_FeedOptions");
                 result = __FAILURE__;
             }
             else
@@ -204,7 +201,7 @@
     return result;
 }
 
-static void* xio_CloneOption(const char* name, const void* value)
+static void*  ICACHE_FLASH_ATTR xio_CloneOption(const char* name, const void* value)
 {
     void *result;
     if (
@@ -212,7 +209,7 @@
         (value == NULL)
         )
     {
-        LogError("invalid argument detected: const char* name=%p, const void* value=%p", name, value);
+        printf("invalid argument detected: const char* name=%p, const void* value=%p", name, value);
         result = NULL;
     }
     else
@@ -223,7 +220,7 @@
         }
         else
         {
-            LogError("unknown option: %s", name);
+            printf("unknown option: %s", name);
             result = NULL;
         }
     }
@@ -231,14 +228,14 @@
 }
 
 
-static void xio_DestroyOption(const char* name, const void* value)
+static void  ICACHE_FLASH_ATTR xio_DestroyOption(const char* name, const void* value)
 {
     if (
         (name == NULL) ||
         (value == NULL)
         )
     {
-        LogError("invalid argument detected: const char* name=%p, const void* value=%p", name, value);
+        printf("invalid argument detected: const char* name=%p, const void* value=%p", name, value);
     }
     else
     {
@@ -248,18 +245,18 @@
         }
         else
         {
-            LogError("unknown option: %s", name);
+            printf("unknown option: %s", name);
         }
     }
 }
 
-OPTIONHANDLER_HANDLE xio_retrieveoptions(XIO_HANDLE xio)
+OPTIONHANDLER_HANDLE  ICACHE_FLASH_ATTR xio_retrieveoptions(XIO_HANDLE xio)
 {
     OPTIONHANDLER_HANDLE result;
 
     if (xio == NULL)
     {
-        LogError("invalid argument detected: XIO_HANDLE xio=%p", xio);
+        printf("invalid argument detected: XIO_HANDLE xio=%p", xio);
         result = NULL;
     }
     else
@@ -269,7 +266,7 @@
         result = OptionHandler_Create(xio_CloneOption, xio_DestroyOption, (pfSetOption)xio_setoption);
         if (result == NULL)
         {
-            LogError("unable to OptionHandler_Create");
+            printf("unable to OptionHandler_Create");
             /*return as is*/
         }
         else
@@ -277,7 +274,7 @@
             OPTIONHANDLER_HANDLE concreteOptions = xio_instance->io_interface_description->concrete_io_retrieveoptions(xio_instance->concrete_xio_handle);
             if (concreteOptions == NULL)
             {
-                LogError("unable to concrete_io_retrieveoptions");
+                printf("unable to concrete_io_retrieveoptions");
                 OptionHandler_Destroy(result);
                 result = NULL;
             }
@@ -285,7 +282,7 @@
             {
                 if (OptionHandler_AddOption(result, CONCRETE_OPTIONS, concreteOptions) != OPTIONHANDLER_OK)
                 {
-                    LogError("unable to OptionHandler_AddOption");
+                    printf("unable to OptionHandler_AddOption");
                     OptionHandler_Destroy(concreteOptions);
                     OptionHandler_Destroy(result);
                     result = NULL;
diff -uNr src/xlogging.c src_ok/xlogging.c
--- src/xlogging.c	2018-09-03 17:04:20.000000000 +0800
+++ src_ok/xlogging.c	2018-09-03 16:45:36.000000000 +0800
@@ -1,8 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#include "azure_c_shared_utility/xlogging.h"
-#include "azure_c_shared_utility/consolelogger.h"
+#include "xlogging.h"
 
 #ifndef NO_LOGGING
 
